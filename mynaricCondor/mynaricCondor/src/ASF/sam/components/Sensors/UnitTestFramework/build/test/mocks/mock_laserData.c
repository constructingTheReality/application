/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_laserData.h"

static const char* CMockString_CanSequence = "CanSequence";
static const char* CMockString_bAlarmExist = "bAlarmExist";
static const char* CMockString_bCanPort1IsSelected = "bCanPort1IsSelected";
static const char* CMockString_bEnable = "bEnable";
static const char* CMockString_bGetSendConfig = "bGetSendConfig";
static const char* CMockString_bHighAlarm = "bHighAlarm";
static const char* CMockString_bInitBoostMemoryImageFromNvm = "bInitBoostMemoryImageFromNvm";
static const char* CMockString_bInitCommonMemoryImageFromNvm = "bInitCommonMemoryImageFromNvm";
static const char* CMockString_bInitLnaMemoryImageFromNvm = "bInitLnaMemoryImageFromNvm";
static const char* CMockString_bResetIsDemanded = "bResetIsDemanded";
static const char* CMockString_bSelectCan1 = "bSelectCan1";
static const char* CMockString_bValidatePassword = "bValidatePassword";
static const char* CMockString_bVeryHighAlarm = "bVeryHighAlarm";
static const char* CMockString_bVeryLowAlarm = "bVeryLowAlarm";
static const char* CMockString_bWriteMemoryNeeded = "bWriteMemoryNeeded";
static const char* CMockString_c401Status1Definition = "c401Status1Definition";
static const char* CMockString_c402StatusDefinition = "c402StatusDefinition";
static const char* CMockString_c403StatusDefinition = "c403StatusDefinition";
static const char* CMockString_c404StatusDefinition = "c404StatusDefinition";
static const char* CMockString_c405Definition = "c405Definition";
static const char* CMockString_c406PacketControlDefinition = "c406PacketControlDefinition";
static const char* CMockString_c407PacketControlDefinition = "c407PacketControlDefinition";
static const char* CMockString_c408StatusDefinition = "c408StatusDefinition";
static const char* CMockString_c409StatusDefinition = "c409StatusDefinition";
static const char* CMockString_c411StatusDefinition = "c411StatusDefinition";
static const char* CMockString_c412StatusDefinition = "c412StatusDefinition";
static const char* CMockString_c413StatusDefinition = "c413StatusDefinition";
static const char* CMockString_c423StatusDefinition = "c423StatusDefinition";
static const char* CMockString_cGetresetCause = "cGetresetCause";
static const char* CMockString_eLaserGetLimitTemperature = "eLaserGetLimitTemperature";
static const char* CMockString_fHpaMM1and2DerivativeGain = "fHpaMM1and2DerivativeGain";
static const char* CMockString_fHpaMM1and2IntegralGain = "fHpaMM1and2IntegralGain";
static const char* CMockString_fHpaMM1and2Proportional = "fHpaMM1and2Proportional";
static const char* CMockString_fHpaSingleDerivativeGain = "fHpaSingleDerivativeGain";
static const char* CMockString_fHpaSingleIntegralGain = "fHpaSingleIntegralGain";
static const char* CMockString_fHpaSingleProportional = "fHpaSingleProportional";
static const char* CMockString_fLnasingleDerivativeGain = "fLnasingleDerivativeGain";
static const char* CMockString_fLnasingleIntegralGain = "fLnasingleIntegralGain";
static const char* CMockString_fLnasingleProportional = "fLnasingleProportional";
static const char* CMockString_fPvalue = "fPvalue";
static const char* CMockString_fTemperatureReaded = "fTemperatureReaded";
static const char* CMockString_getCanSequence = "getCanSequence";
static const char* CMockString_getLnaPidValues = "getLnaPidValues";
static const char* CMockString_pLaserDataGetCan402Pointer = "pLaserDataGetCan402Pointer";
static const char* CMockString_pLaserDataGetCan414Info = "pLaserDataGetCan414Info";
static const char* CMockString_pLaserDataGetCan415Info = "pLaserDataGetCan415Info";
static const char* CMockString_pLaserDataGetCan428Info = "pLaserDataGetCan428Info";
static const char* CMockString_pLaserDataGetThermistorData = "pLaserDataGetThermistorData";
static const char* CMockString_pfHighLimit = "pfHighLimit";
static const char* CMockString_pfHpaSingleProportional = "pfHpaSingleProportional";
static const char* CMockString_pfHpasingleDerivativeGain = "pfHpasingleDerivativeGain";
static const char* CMockString_pfHpasingleIntegralGain = "pfHpasingleIntegralGain";
static const char* CMockString_pfVeryHighLimit = "pfVeryHighLimit";
static const char* CMockString_pfVeryLowLimit = "pfVeryLowLimit";
static const char* CMockString_setCanSequence = "setCanSequence";
static const char* CMockString_setInternalCriticalErrorFlag = "setInternalCriticalErrorFlag";
static const char* CMockString_setLnaPidDerivativeValue = "setLnaPidDerivativeValue";
static const char* CMockString_setLnaPidIntegralValue = "setLnaPidIntegralValue";
static const char* CMockString_setLnaPidProportionalValue = "setLnaPidProportionalValue";
static const char* CMockString_uSerialNumber = "uSerialNumber";
static const char* CMockString_ucCompanyId = "ucCompanyId";
static const char* CMockString_vClearSpiAdcErrors = "vClearSpiAdcErrors";
static const char* CMockString_vClearSpiFramErrors = "vClearSpiFramErrors";
static const char* CMockString_vControlAlarmInitAlarms = "vControlAlarmInitAlarms";
static const char* CMockString_vCopyImageBoosterNvm = "vCopyImageBoosterNvm";
static const char* CMockString_vCopyImageCommonNvm = "vCopyImageCommonNvm";
static const char* CMockString_vCopyImageLnaNvm = "vCopyImageLnaNvm";
static const char* CMockString_vEnableHpaMultiMode1 = "vEnableHpaMultiMode1";
static const char* CMockString_vEnableHpaMultiMode2 = "vEnableHpaMultiMode2";
static const char* CMockString_vEnableHpaSingleMode = "vEnableHpaSingleMode";
static const char* CMockString_vEnableLna = "vEnableLna";
static const char* CMockString_vGet402Message = "vGet402Message";
static const char* CMockString_vGetCompanyId = "vGetCompanyId";
static const char* CMockString_vGetSerialNumber = "vGetSerialNumber";
static const char* CMockString_vGetUpdateBoosterMemoryWriteNeeded = "vGetUpdateBoosterMemoryWriteNeeded";
static const char* CMockString_vGetUpdateCommonMemoryWriteNeeded = "vGetUpdateCommonMemoryWriteNeeded";
static const char* CMockString_vGetUpdateLnaMemoryWriteNeeded = "vGetUpdateLnaMemoryWriteNeeded";
static const char* CMockString_vGetUpdateMemoryWriteNeeded = "vGetUpdateMemoryWriteNeeded";
static const char* CMockString_vGetpxBoosterParameters = "vGetpxBoosterParameters";
static const char* CMockString_vGetpxCommonControlParameters = "vGetpxCommonControlParameters";
static const char* CMockString_vGetpxLnaParameters = "vGetpxLnaParameters";
static const char* CMockString_vGetxAmplifierDescriptor = "vGetxAmplifierDescriptor";
static const char* CMockString_vIncreaseCanErrors = "vIncreaseCanErrors";
static const char* CMockString_vIncreaseSpiAdcErrors = "vIncreaseSpiAdcErrors";
static const char* CMockString_vIncreaseSpiFramErrors = "vIncreaseSpiFramErrors";
static const char* CMockString_vInitWithFullResetRequest = "vInitWithFullResetRequest";
static const char* CMockString_vLaserBeamsFactoryBoosterDefaultValues = "vLaserBeamsFactoryBoosterDefaultValues";
static const char* CMockString_vLaserBeamsFactoryCommonDefaultValues = "vLaserBeamsFactoryCommonDefaultValues";
static const char* CMockString_vLaserBeamsFactoryLnaDefaultValues = "vLaserBeamsFactoryLnaDefaultValues";
static const char* CMockString_vLaserDataGetCan401Info = "vLaserDataGetCan401Info";
static const char* CMockString_vLaserDataGetCan402Info = "vLaserDataGetCan402Info";
static const char* CMockString_vLaserDataGetCan403Info = "vLaserDataGetCan403Info";
static const char* CMockString_vLaserDataGetCan404Info = "vLaserDataGetCan404Info";
static const char* CMockString_vLaserDataGetCan405Info = "vLaserDataGetCan405Info";
static const char* CMockString_vLaserDataGetCan406Info = "vLaserDataGetCan406Info";
static const char* CMockString_vLaserDataGetCan407Info = "vLaserDataGetCan407Info";
static const char* CMockString_vLaserDataGetCan408Info = "vLaserDataGetCan408Info";
static const char* CMockString_vLaserDataGetCan409Info = "vLaserDataGetCan409Info";
static const char* CMockString_vLaserDataGetCan409Pointer = "vLaserDataGetCan409Pointer";
static const char* CMockString_vLaserDataGetCan40AInfo = "vLaserDataGetCan40AInfo";
static const char* CMockString_vLaserDataGetCan411Info = "vLaserDataGetCan411Info";
static const char* CMockString_vLaserDataGetCan423Info = "vLaserDataGetCan423Info";
static const char* CMockString_vLaserDataGetData402 = "vLaserDataGetData402";
static const char* CMockString_vLaserDataGetData403 = "vLaserDataGetData403";
static const char* CMockString_vLaserDataGetData404 = "vLaserDataGetData404";
static const char* CMockString_vLaserDataGetData406 = "vLaserDataGetData406";
static const char* CMockString_vLaserDataGetData407 = "vLaserDataGetData407";
static const char* CMockString_vLaserDataGetData408 = "vLaserDataGetData408";
static const char* CMockString_vLaserDataGetData409 = "vLaserDataGetData409";
static const char* CMockString_vLaserDataGetData410 = "vLaserDataGetData410";
static const char* CMockString_vLaserDataGetData412 = "vLaserDataGetData412";
static const char* CMockString_vLaserDataGetData413 = "vLaserDataGetData413";
static const char* CMockString_vLaserDataInit = "vLaserDataInit";
static const char* CMockString_vLaserDataSetCan406Info = "vLaserDataSetCan406Info";
static const char* CMockString_vLaserDataSetCan407Info = "vLaserDataSetCan407Info";
static const char* CMockString_vLaserInitBooster = "vLaserInitBooster";
static const char* CMockString_vLaserInitLna = "vLaserInitLna";
static const char* CMockString_vLaserSetCurrentAlarm = "vLaserSetCurrentAlarm";
static const char* CMockString_vLaserSetTemperatureFlagAlarm = "vLaserSetTemperatureFlagAlarm";
static const char* CMockString_vLaserSetTemperatureInCan = "vLaserSetTemperatureInCan";
static const char* CMockString_vResetSendConfig = "vResetSendConfig";
static const char* CMockString_vSetCanPort1 = "vSetCanPort1";
static const char* CMockString_vSetCompanyId = "vSetCompanyId";
static const char* CMockString_vSetSendConfig = "vSetSendConfig";
static const char* CMockString_vSetSerialNumber = "vSetSerialNumber";
static const char* CMockString_vSetUpdateBoosterMemoryWriteNeeded = "vSetUpdateBoosterMemoryWriteNeeded";
static const char* CMockString_vSetUpdateCommonMemoryWriteNeeded = "vSetUpdateCommonMemoryWriteNeeded";
static const char* CMockString_vSetUpdateLnaMemoryWriteNeeded = "vSetUpdateLnaMemoryWriteNeeded";
static const char* CMockString_vSetUpdateMemoryWriteNeeded = "vSetUpdateMemoryWriteNeeded";
static const char* CMockString_vUpdateBoostNvmMemory = "vUpdateBoostNvmMemory";
static const char* CMockString_vUpdateCommonNvmMemory = "vUpdateCommonNvmMemory";
static const char* CMockString_vUpdateConfigInfo = "vUpdateConfigInfo";
static const char* CMockString_vUpdateHpaMm1PIDValues = "vUpdateHpaMm1PIDValues";
static const char* CMockString_vUpdateHpaMm1and2PIDValues = "vUpdateHpaMm1and2PIDValues";
static const char* CMockString_vUpdateHpaMm2PIDValues = "vUpdateHpaMm2PIDValues";
static const char* CMockString_vUpdateHpaSmPIDValues = "vUpdateHpaSmPIDValues";
static const char* CMockString_vUpdateLnaNvmMemory = "vUpdateLnaNvmMemory";
static const char* CMockString_vUpdateLnaPIDValues = "vUpdateLnaPIDValues";
static const char* CMockString_vUploadHpaSmPIDValues = "vUploadHpaSmPIDValues";
static const char* CMockString_value = "value";
static const char* CMockString_vpGetPumpTemperatureLimits = "vpGetPumpTemperatureLimits";
static const char* CMockString_xStream = "xStream";

typedef struct _CMOCK_vLaserInitBooster_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vLaserInitBooster_CALL_INSTANCE;

typedef struct _CMOCK_vLaserInitLna_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vLaserInitLna_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vLaserDataInit_CALL_INSTANCE;

typedef struct _CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE;

typedef struct _CMOCK_getCanSequence_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  CanSequence_t ReturnVal;
  int CallOrder;

} CMOCK_getCanSequence_CALL_INSTANCE;

typedef struct _CMOCK_setCanSequence_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  CanSequence_t Expected_CanSequence;
  char IgnoreArg_CanSequence;

} CMOCK_setCanSequence_CALL_INSTANCE;

typedef struct _CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE;

typedef struct _CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE;

typedef struct _CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE;

typedef struct _CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xAmplifierDescriptor_t* ReturnVal;
  int CallOrder;

} CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE;

typedef struct _CMOCK_vGetpxLnaParameters_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xLnaParameters_t* ReturnVal;
  int CallOrder;

} CMOCK_vGetpxLnaParameters_CALL_INSTANCE;

typedef struct _CMOCK_vGetpxBoosterParameters_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xBoosterParameters_t* ReturnVal;
  int CallOrder;

} CMOCK_vGetpxBoosterParameters_CALL_INSTANCE;

typedef struct _CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  handle_t Expected_xStream;
  float Expected_fTemperatureReaded;
  char IgnoreArg_xStream;
  char IgnoreArg_fTemperatureReaded;

} CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE;

typedef struct _CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eMpbError_t ReturnVal;
  int CallOrder;
  handle_t Expected_xStream;
  float* Expected_pfVeryHighLimit;
  float* Expected_pfVeryLowLimit;
  float* Expected_pfHighLimit;
  int Expected_pfVeryHighLimit_Depth;
  int Expected_pfVeryLowLimit_Depth;
  int Expected_pfHighLimit_Depth;
  char ReturnThruPtr_pfVeryHighLimit_Used;
  float* ReturnThruPtr_pfVeryHighLimit_Val;
  size_t ReturnThruPtr_pfVeryHighLimit_Size;
  char ReturnThruPtr_pfVeryLowLimit_Used;
  float* ReturnThruPtr_pfVeryLowLimit_Val;
  size_t ReturnThruPtr_pfVeryLowLimit_Size;
  char ReturnThruPtr_pfHighLimit_Used;
  float* ReturnThruPtr_pfHighLimit_Val;
  size_t ReturnThruPtr_pfHighLimit_Size;
  char IgnoreArg_xStream;
  char IgnoreArg_pfVeryHighLimit;
  char IgnoreArg_pfVeryLowLimit;
  char IgnoreArg_pfHighLimit;

} CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE;

typedef struct _CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  handle_t Expected_xStream;
  eBool_t Expected_bVeryLowAlarm;
  eBool_t Expected_bVeryHighAlarm;
  eBool_t Expected_bHighAlarm;
  char IgnoreArg_xStream;
  char IgnoreArg_bVeryLowAlarm;
  char IgnoreArg_bVeryHighAlarm;
  char IgnoreArg_bHighAlarm;

} CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE;

typedef struct _CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xCommonControlParameters_t* ReturnVal;
  int CallOrder;

} CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE;

typedef struct _CMOCK_vGet402Message_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c402StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vGet402Message_CALL_INSTANCE;

typedef struct _CMOCK_bCanPort1IsSelected_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_bCanPort1IsSelected_CALL_INSTANCE;

typedef struct _CMOCK_vSetCanPort1_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bSelectCan1;
  char IgnoreArg_bSelectCan1;

} CMOCK_vSetCanPort1_CALL_INSTANCE;

typedef struct _CMOCK_vGetSerialNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  uint32_t* Expected_uSerialNumber;
  int Expected_uSerialNumber_Depth;
  char ReturnThruPtr_uSerialNumber_Used;
  uint32_t* ReturnThruPtr_uSerialNumber_Val;
  size_t ReturnThruPtr_uSerialNumber_Size;
  char IgnoreArg_uSerialNumber;

} CMOCK_vGetSerialNumber_CALL_INSTANCE;

typedef struct _CMOCK_vSetSerialNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  uint32_t Expected_uSerialNumber;
  char IgnoreArg_uSerialNumber;

} CMOCK_vSetSerialNumber_CALL_INSTANCE;

typedef struct _CMOCK_vSetSendConfig_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vSetSendConfig_CALL_INSTANCE;

typedef struct _CMOCK_bGetSendConfig_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_bGetSendConfig_CALL_INSTANCE;

typedef struct _CMOCK_vResetSendConfig_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vResetSendConfig_CALL_INSTANCE;

typedef struct _CMOCK_vGetCompanyId_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  uint8_t* Expected_ucCompanyId;
  int Expected_ucCompanyId_Depth;
  char ReturnThruPtr_ucCompanyId_Used;
  uint8_t* ReturnThruPtr_ucCompanyId_Val;
  size_t ReturnThruPtr_ucCompanyId_Size;
  char IgnoreArg_ucCompanyId;

} CMOCK_vGetCompanyId_CALL_INSTANCE;

typedef struct _CMOCK_vSetCompanyId_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  uint8_t Expected_ucCompanyId;
  char IgnoreArg_ucCompanyId;

} CMOCK_vSetCompanyId_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c401StatusDefinition_t* Expected_c401Status1Definition;
  int Expected_c401Status1Definition_Depth;
  char ReturnThruPtr_c401Status1Definition_Used;
  c401StatusDefinition_t* ReturnThruPtr_c401Status1Definition_Val;
  size_t ReturnThruPtr_c401Status1Definition_Size;
  char IgnoreArg_c401Status1Definition;

} CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE;

typedef struct _CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c414StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE;

typedef struct _CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c415StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData402_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c402StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData402_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c402StatusDefinition_t* Expected_c402StatusDefinition;
  int Expected_c402StatusDefinition_Depth;
  char ReturnThruPtr_c402StatusDefinition_Used;
  c402StatusDefinition_t* ReturnThruPtr_c402StatusDefinition_Val;
  size_t ReturnThruPtr_c402StatusDefinition_Size;
  char IgnoreArg_c402StatusDefinition;

} CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE;

typedef struct _CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c402StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c403StatusDefinition_t* Expected_c403StatusDefinition;
  int Expected_c403StatusDefinition_Depth;
  char ReturnThruPtr_c403StatusDefinition_Used;
  c403StatusDefinition_t* ReturnThruPtr_c403StatusDefinition_Val;
  size_t ReturnThruPtr_c403StatusDefinition_Size;
  char IgnoreArg_c403StatusDefinition;

} CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c404StatusDefinition_t* Expected_c404StatusDefinition;
  int Expected_c404StatusDefinition_Depth;
  char ReturnThruPtr_c404StatusDefinition_Used;
  c404StatusDefinition_t* ReturnThruPtr_c404StatusDefinition_Val;
  size_t ReturnThruPtr_c404StatusDefinition_Size;
  char IgnoreArg_c404StatusDefinition;

} CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c405Definition_t* Expected_c405Definition;
  int Expected_c405Definition_Depth;
  char ReturnThruPtr_c405Definition_Used;
  c405Definition_t* ReturnThruPtr_c405Definition_Val;
  size_t ReturnThruPtr_c405Definition_Size;
  char IgnoreArg_c405Definition;

} CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData406_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c406PacketControlDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData406_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c406PacketControlDefinition_t* Expected_c406PacketControlDefinition;
  int Expected_c406PacketControlDefinition_Depth;
  char ReturnThruPtr_c406PacketControlDefinition_Used;
  c406PacketControlDefinition_t* ReturnThruPtr_c406PacketControlDefinition_Val;
  size_t ReturnThruPtr_c406PacketControlDefinition_Size;
  char IgnoreArg_c406PacketControlDefinition;

} CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c406PacketControlDefinition_t* Expected_c406PacketControlDefinition;
  int Expected_c406PacketControlDefinition_Depth;
  char ReturnThruPtr_c406PacketControlDefinition_Used;
  c406PacketControlDefinition_t* ReturnThruPtr_c406PacketControlDefinition_Val;
  size_t ReturnThruPtr_c406PacketControlDefinition_Size;
  char IgnoreArg_c406PacketControlDefinition;

} CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData407_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c407PacketControlDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData407_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c407PacketControlDefinition_t* Expected_c407PacketControlDefinition;
  int Expected_c407PacketControlDefinition_Depth;
  char ReturnThruPtr_c407PacketControlDefinition_Used;
  c407PacketControlDefinition_t* ReturnThruPtr_c407PacketControlDefinition_Val;
  size_t ReturnThruPtr_c407PacketControlDefinition_Size;
  char IgnoreArg_c407PacketControlDefinition;

} CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c407PacketControlDefinition_t* Expected_c407PacketControlDefinition;
  int Expected_c407PacketControlDefinition_Depth;
  char ReturnThruPtr_c407PacketControlDefinition_Used;
  c407PacketControlDefinition_t* ReturnThruPtr_c407PacketControlDefinition_Val;
  size_t ReturnThruPtr_c407PacketControlDefinition_Size;
  char IgnoreArg_c407PacketControlDefinition;

} CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData408_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c408StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData408_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c408StatusDefinition_t* Expected_c408StatusDefinition;
  int Expected_c408StatusDefinition_Depth;
  char ReturnThruPtr_c408StatusDefinition_Used;
  c408StatusDefinition_t* ReturnThruPtr_c408StatusDefinition_Val;
  size_t ReturnThruPtr_c408StatusDefinition_Size;
  char IgnoreArg_c408StatusDefinition;

} CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData403_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c403StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData403_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData404_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c404StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData404_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData409_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c409StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData409_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData410_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c410StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData410_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData412_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c412StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData412_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetData413_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c413StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetData413_CALL_INSTANCE;

typedef struct _CMOCK_bValidatePassword_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;
  c412StatusDefinition_t* Expected_c412StatusDefinition;
  c413StatusDefinition_t* Expected_c413StatusDefinition;
  int Expected_c412StatusDefinition_Depth;
  int Expected_c413StatusDefinition_Depth;
  char ReturnThruPtr_c412StatusDefinition_Used;
  c412StatusDefinition_t* ReturnThruPtr_c412StatusDefinition_Val;
  size_t ReturnThruPtr_c412StatusDefinition_Size;
  char ReturnThruPtr_c413StatusDefinition_Used;
  c413StatusDefinition_t* ReturnThruPtr_c413StatusDefinition_Val;
  size_t ReturnThruPtr_c413StatusDefinition_Size;
  char IgnoreArg_c412StatusDefinition;
  char IgnoreArg_c413StatusDefinition;

} CMOCK_bValidatePassword_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c409StatusDefinition_t* Expected_c409StatusDefinition;
  int Expected_c409StatusDefinition_Depth;
  char ReturnThruPtr_c409StatusDefinition_Used;
  c409StatusDefinition_t* ReturnThruPtr_c409StatusDefinition_Val;
  size_t ReturnThruPtr_c409StatusDefinition_Size;
  char IgnoreArg_c409StatusDefinition;

} CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c409StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c40AStatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c423StatusDefinition_t* Expected_c423StatusDefinition;
  int Expected_c423StatusDefinition_Depth;
  char ReturnThruPtr_c423StatusDefinition_Used;
  c423StatusDefinition_t* ReturnThruPtr_c423StatusDefinition_Val;
  size_t ReturnThruPtr_c423StatusDefinition_Size;
  char IgnoreArg_c423StatusDefinition;

} CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE;

typedef struct _CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  c428StatusDefinition_t* ReturnVal;
  int CallOrder;

} CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE;

typedef struct _CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xExternalAnalogThermistorsInputs_t* ReturnVal;
  int CallOrder;

} CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE;

typedef struct _CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  c411StatusDefinition_t* Expected_c411StatusDefinition;
  int Expected_c411StatusDefinition_Depth;
  char ReturnThruPtr_c411StatusDefinition_Used;
  c411StatusDefinition_t* ReturnThruPtr_c411StatusDefinition_Val;
  size_t ReturnThruPtr_c411StatusDefinition_Size;
  char IgnoreArg_c411StatusDefinition;

} CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateConfigInfo_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vUpdateConfigInfo_CALL_INSTANCE;

typedef struct _CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE;

typedef struct _CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE;

typedef struct _CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE;

typedef struct _CMOCK_getLnaPidValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xPidValues_t* ReturnVal;
  int CallOrder;

} CMOCK_getLnaPidValues_CALL_INSTANCE;

typedef struct _CMOCK_setLnaPidProportionalValue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fPvalue;
  char IgnoreArg_fPvalue;

} CMOCK_setLnaPidProportionalValue_CALL_INSTANCE;

typedef struct _CMOCK_setLnaPidIntegralValue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fPvalue;
  char IgnoreArg_fPvalue;

} CMOCK_setLnaPidIntegralValue_CALL_INSTANCE;

typedef struct _CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fPvalue;
  char IgnoreArg_fPvalue;

} CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE;

typedef struct _CMOCK_cGetresetCause_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint8_t ReturnVal;
  int CallOrder;

} CMOCK_cGetresetCause_CALL_INSTANCE;

typedef struct _CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_value;
  char IgnoreArg_value;

} CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE;

typedef struct _CMOCK_vInitWithFullResetRequest_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vInitWithFullResetRequest_CALL_INSTANCE;

typedef struct _CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE;

typedef struct _CMOCK_vClearSpiAdcErrors_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vClearSpiAdcErrors_CALL_INSTANCE;

typedef struct _CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE;

typedef struct _CMOCK_vClearSpiFramErrors_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vClearSpiFramErrors_CALL_INSTANCE;

typedef struct _CMOCK_vIncreaseCanErrors_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vIncreaseCanErrors_CALL_INSTANCE;

typedef struct _CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_bResetIsDemanded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_bResetIsDemanded_CALL_INSTANCE;

typedef struct _CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;

} CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bWriteMemoryNeeded;
  char IgnoreArg_bWriteMemoryNeeded;

} CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bWriteMemoryNeeded;
  char IgnoreArg_bWriteMemoryNeeded;

} CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bWriteMemoryNeeded;
  char IgnoreArg_bWriteMemoryNeeded;

} CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bWriteMemoryNeeded;
  char IgnoreArg_bWriteMemoryNeeded;

} CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE;

typedef struct _CMOCK_vCopyImageCommonNvm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vCopyImageCommonNvm_CALL_INSTANCE;

typedef struct _CMOCK_vCopyImageLnaNvm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vCopyImageLnaNvm_CALL_INSTANCE;

typedef struct _CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE;

typedef struct _CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bAlarmExist;
  char IgnoreArg_bAlarmExist;

} CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fLnasingleProportional;
  float Expected_fLnasingleIntegralGain;
  float Expected_fLnasingleDerivativeGain;
  char IgnoreArg_fLnasingleProportional;
  char IgnoreArg_fLnasingleIntegralGain;
  char IgnoreArg_fLnasingleDerivativeGain;

} CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fHpaSingleProportional;
  float Expected_fHpaSingleIntegralGain;
  float Expected_fHpaSingleDerivativeGain;
  char IgnoreArg_fHpaSingleProportional;
  char IgnoreArg_fHpaSingleIntegralGain;
  char IgnoreArg_fHpaSingleDerivativeGain;

} CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE;

typedef struct _CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float* Expected_pfHpaSingleProportional;
  float* Expected_pfHpasingleIntegralGain;
  float* Expected_pfHpasingleDerivativeGain;
  int Expected_pfHpaSingleProportional_Depth;
  int Expected_pfHpasingleIntegralGain_Depth;
  int Expected_pfHpasingleDerivativeGain_Depth;
  char ReturnThruPtr_pfHpaSingleProportional_Used;
  float* ReturnThruPtr_pfHpaSingleProportional_Val;
  size_t ReturnThruPtr_pfHpaSingleProportional_Size;
  char ReturnThruPtr_pfHpasingleIntegralGain_Used;
  float* ReturnThruPtr_pfHpasingleIntegralGain_Val;
  size_t ReturnThruPtr_pfHpasingleIntegralGain_Size;
  char ReturnThruPtr_pfHpasingleDerivativeGain_Used;
  float* ReturnThruPtr_pfHpasingleDerivativeGain_Val;
  size_t ReturnThruPtr_pfHpasingleDerivativeGain_Size;
  char IgnoreArg_pfHpaSingleProportional;
  char IgnoreArg_pfHpasingleIntegralGain;
  char IgnoreArg_pfHpasingleDerivativeGain;

} CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fHpaSingleProportional;
  float Expected_fHpaSingleIntegralGain;
  float Expected_fHpaSingleDerivativeGain;
  char IgnoreArg_fHpaSingleProportional;
  char IgnoreArg_fHpaSingleIntegralGain;
  char IgnoreArg_fHpaSingleDerivativeGain;

} CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fHpaSingleProportional;
  float Expected_fHpaSingleIntegralGain;
  float Expected_fHpaSingleDerivativeGain;
  char IgnoreArg_fHpaSingleProportional;
  char IgnoreArg_fHpaSingleIntegralGain;
  char IgnoreArg_fHpaSingleDerivativeGain;

} CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE;

typedef struct _CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fHpaMM1and2Proportional;
  float Expected_fHpaMM1and2IntegralGain;
  float Expected_fHpaMM1and2DerivativeGain;
  char IgnoreArg_fHpaMM1and2Proportional;
  char IgnoreArg_fHpaMM1and2IntegralGain;
  char IgnoreArg_fHpaMM1and2DerivativeGain;

} CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE;

typedef struct _CMOCK_vEnableLna_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bEnable;
  char IgnoreArg_bEnable;

} CMOCK_vEnableLna_CALL_INSTANCE;

typedef struct _CMOCK_vEnableHpaSingleMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bEnable;
  char IgnoreArg_bEnable;

} CMOCK_vEnableHpaSingleMode_CALL_INSTANCE;

typedef struct _CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bEnable;
  char IgnoreArg_bEnable;

} CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE;

typedef struct _CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  eBool_t Expected_bEnable;
  char IgnoreArg_bEnable;

} CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE;

typedef struct _CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  xPumpTemperaturesLimits_t* ReturnVal;
  int CallOrder;

} CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE;

static struct mock_laserDataInstance
{
  char vLaserInitBooster_IgnoreBool;
  char vLaserInitBooster_CallbackBool;
  CMOCK_vLaserInitBooster_CALLBACK vLaserInitBooster_CallbackFunctionPointer;
  int vLaserInitBooster_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserInitBooster_CallInstance;
  char vLaserInitLna_IgnoreBool;
  char vLaserInitLna_CallbackBool;
  CMOCK_vLaserInitLna_CALLBACK vLaserInitLna_CallbackFunctionPointer;
  int vLaserInitLna_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserInitLna_CallInstance;
  char vLaserDataInit_IgnoreBool;
  char vLaserDataInit_CallbackBool;
  CMOCK_vLaserDataInit_CALLBACK vLaserDataInit_CallbackFunctionPointer;
  int vLaserDataInit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataInit_CallInstance;
  char vControlAlarmInitAlarms_IgnoreBool;
  char vControlAlarmInitAlarms_CallbackBool;
  CMOCK_vControlAlarmInitAlarms_CALLBACK vControlAlarmInitAlarms_CallbackFunctionPointer;
  int vControlAlarmInitAlarms_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vControlAlarmInitAlarms_CallInstance;
  char getCanSequence_IgnoreBool;
  CanSequence_t getCanSequence_FinalReturn;
  char getCanSequence_CallbackBool;
  CMOCK_getCanSequence_CALLBACK getCanSequence_CallbackFunctionPointer;
  int getCanSequence_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE getCanSequence_CallInstance;
  char setCanSequence_IgnoreBool;
  char setCanSequence_CallbackBool;
  CMOCK_setCanSequence_CALLBACK setCanSequence_CallbackFunctionPointer;
  int setCanSequence_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE setCanSequence_CallInstance;
  char vLaserBeamsFactoryCommonDefaultValues_IgnoreBool;
  char vLaserBeamsFactoryCommonDefaultValues_CallbackBool;
  CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALLBACK vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer;
  int vLaserBeamsFactoryCommonDefaultValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserBeamsFactoryCommonDefaultValues_CallInstance;
  char vLaserBeamsFactoryLnaDefaultValues_IgnoreBool;
  char vLaserBeamsFactoryLnaDefaultValues_CallbackBool;
  CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALLBACK vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer;
  int vLaserBeamsFactoryLnaDefaultValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserBeamsFactoryLnaDefaultValues_CallInstance;
  char vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool;
  char vLaserBeamsFactoryBoosterDefaultValues_CallbackBool;
  CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALLBACK vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer;
  int vLaserBeamsFactoryBoosterDefaultValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserBeamsFactoryBoosterDefaultValues_CallInstance;
  char vGetxAmplifierDescriptor_IgnoreBool;
  xAmplifierDescriptor_t* vGetxAmplifierDescriptor_FinalReturn;
  char vGetxAmplifierDescriptor_CallbackBool;
  CMOCK_vGetxAmplifierDescriptor_CALLBACK vGetxAmplifierDescriptor_CallbackFunctionPointer;
  int vGetxAmplifierDescriptor_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetxAmplifierDescriptor_CallInstance;
  char vGetpxLnaParameters_IgnoreBool;
  xLnaParameters_t* vGetpxLnaParameters_FinalReturn;
  char vGetpxLnaParameters_CallbackBool;
  CMOCK_vGetpxLnaParameters_CALLBACK vGetpxLnaParameters_CallbackFunctionPointer;
  int vGetpxLnaParameters_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetpxLnaParameters_CallInstance;
  char vGetpxBoosterParameters_IgnoreBool;
  xBoosterParameters_t* vGetpxBoosterParameters_FinalReturn;
  char vGetpxBoosterParameters_CallbackBool;
  CMOCK_vGetpxBoosterParameters_CALLBACK vGetpxBoosterParameters_CallbackFunctionPointer;
  int vGetpxBoosterParameters_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetpxBoosterParameters_CallInstance;
  char vLaserSetTemperatureInCan_IgnoreBool;
  char vLaserSetTemperatureInCan_CallbackBool;
  CMOCK_vLaserSetTemperatureInCan_CALLBACK vLaserSetTemperatureInCan_CallbackFunctionPointer;
  int vLaserSetTemperatureInCan_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserSetTemperatureInCan_CallInstance;
  char eLaserGetLimitTemperature_IgnoreBool;
  eMpbError_t eLaserGetLimitTemperature_FinalReturn;
  char eLaserGetLimitTemperature_CallbackBool;
  CMOCK_eLaserGetLimitTemperature_CALLBACK eLaserGetLimitTemperature_CallbackFunctionPointer;
  int eLaserGetLimitTemperature_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE eLaserGetLimitTemperature_CallInstance;
  char vLaserSetTemperatureFlagAlarm_IgnoreBool;
  char vLaserSetTemperatureFlagAlarm_CallbackBool;
  CMOCK_vLaserSetTemperatureFlagAlarm_CALLBACK vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer;
  int vLaserSetTemperatureFlagAlarm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserSetTemperatureFlagAlarm_CallInstance;
  char vGetpxCommonControlParameters_IgnoreBool;
  xCommonControlParameters_t* vGetpxCommonControlParameters_FinalReturn;
  char vGetpxCommonControlParameters_CallbackBool;
  CMOCK_vGetpxCommonControlParameters_CALLBACK vGetpxCommonControlParameters_CallbackFunctionPointer;
  int vGetpxCommonControlParameters_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetpxCommonControlParameters_CallInstance;
  char vGet402Message_IgnoreBool;
  c402StatusDefinition_t* vGet402Message_FinalReturn;
  char vGet402Message_CallbackBool;
  CMOCK_vGet402Message_CALLBACK vGet402Message_CallbackFunctionPointer;
  int vGet402Message_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGet402Message_CallInstance;
  char bCanPort1IsSelected_IgnoreBool;
  eBool_t bCanPort1IsSelected_FinalReturn;
  char bCanPort1IsSelected_CallbackBool;
  CMOCK_bCanPort1IsSelected_CALLBACK bCanPort1IsSelected_CallbackFunctionPointer;
  int bCanPort1IsSelected_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bCanPort1IsSelected_CallInstance;
  char vSetCanPort1_IgnoreBool;
  char vSetCanPort1_CallbackBool;
  CMOCK_vSetCanPort1_CALLBACK vSetCanPort1_CallbackFunctionPointer;
  int vSetCanPort1_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetCanPort1_CallInstance;
  char vGetSerialNumber_IgnoreBool;
  char vGetSerialNumber_CallbackBool;
  CMOCK_vGetSerialNumber_CALLBACK vGetSerialNumber_CallbackFunctionPointer;
  int vGetSerialNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetSerialNumber_CallInstance;
  char vSetSerialNumber_IgnoreBool;
  char vSetSerialNumber_CallbackBool;
  CMOCK_vSetSerialNumber_CALLBACK vSetSerialNumber_CallbackFunctionPointer;
  int vSetSerialNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetSerialNumber_CallInstance;
  char vSetSendConfig_IgnoreBool;
  char vSetSendConfig_CallbackBool;
  CMOCK_vSetSendConfig_CALLBACK vSetSendConfig_CallbackFunctionPointer;
  int vSetSendConfig_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetSendConfig_CallInstance;
  char bGetSendConfig_IgnoreBool;
  eBool_t bGetSendConfig_FinalReturn;
  char bGetSendConfig_CallbackBool;
  CMOCK_bGetSendConfig_CALLBACK bGetSendConfig_CallbackFunctionPointer;
  int bGetSendConfig_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bGetSendConfig_CallInstance;
  char vResetSendConfig_IgnoreBool;
  char vResetSendConfig_CallbackBool;
  CMOCK_vResetSendConfig_CALLBACK vResetSendConfig_CallbackFunctionPointer;
  int vResetSendConfig_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vResetSendConfig_CallInstance;
  char vGetCompanyId_IgnoreBool;
  char vGetCompanyId_CallbackBool;
  CMOCK_vGetCompanyId_CALLBACK vGetCompanyId_CallbackFunctionPointer;
  int vGetCompanyId_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetCompanyId_CallInstance;
  char vSetCompanyId_IgnoreBool;
  char vSetCompanyId_CallbackBool;
  CMOCK_vSetCompanyId_CALLBACK vSetCompanyId_CallbackFunctionPointer;
  int vSetCompanyId_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetCompanyId_CallInstance;
  char vLaserDataGetCan401Info_IgnoreBool;
  char vLaserDataGetCan401Info_CallbackBool;
  CMOCK_vLaserDataGetCan401Info_CALLBACK vLaserDataGetCan401Info_CallbackFunctionPointer;
  int vLaserDataGetCan401Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan401Info_CallInstance;
  char pLaserDataGetCan414Info_IgnoreBool;
  c414StatusDefinition_t* pLaserDataGetCan414Info_FinalReturn;
  char pLaserDataGetCan414Info_CallbackBool;
  CMOCK_pLaserDataGetCan414Info_CALLBACK pLaserDataGetCan414Info_CallbackFunctionPointer;
  int pLaserDataGetCan414Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pLaserDataGetCan414Info_CallInstance;
  char pLaserDataGetCan415Info_IgnoreBool;
  c415StatusDefinition_t* pLaserDataGetCan415Info_FinalReturn;
  char pLaserDataGetCan415Info_CallbackBool;
  CMOCK_pLaserDataGetCan415Info_CALLBACK pLaserDataGetCan415Info_CallbackFunctionPointer;
  int pLaserDataGetCan415Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pLaserDataGetCan415Info_CallInstance;
  char vLaserDataGetData402_IgnoreBool;
  c402StatusDefinition_t* vLaserDataGetData402_FinalReturn;
  char vLaserDataGetData402_CallbackBool;
  CMOCK_vLaserDataGetData402_CALLBACK vLaserDataGetData402_CallbackFunctionPointer;
  int vLaserDataGetData402_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData402_CallInstance;
  char vLaserDataGetCan402Info_IgnoreBool;
  char vLaserDataGetCan402Info_CallbackBool;
  CMOCK_vLaserDataGetCan402Info_CALLBACK vLaserDataGetCan402Info_CallbackFunctionPointer;
  int vLaserDataGetCan402Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan402Info_CallInstance;
  char pLaserDataGetCan402Pointer_IgnoreBool;
  c402StatusDefinition_t* pLaserDataGetCan402Pointer_FinalReturn;
  char pLaserDataGetCan402Pointer_CallbackBool;
  CMOCK_pLaserDataGetCan402Pointer_CALLBACK pLaserDataGetCan402Pointer_CallbackFunctionPointer;
  int pLaserDataGetCan402Pointer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pLaserDataGetCan402Pointer_CallInstance;
  char vLaserDataGetCan403Info_IgnoreBool;
  char vLaserDataGetCan403Info_CallbackBool;
  CMOCK_vLaserDataGetCan403Info_CALLBACK vLaserDataGetCan403Info_CallbackFunctionPointer;
  int vLaserDataGetCan403Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan403Info_CallInstance;
  char vLaserDataGetCan404Info_IgnoreBool;
  char vLaserDataGetCan404Info_CallbackBool;
  CMOCK_vLaserDataGetCan404Info_CALLBACK vLaserDataGetCan404Info_CallbackFunctionPointer;
  int vLaserDataGetCan404Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan404Info_CallInstance;
  char vLaserDataGetCan405Info_IgnoreBool;
  char vLaserDataGetCan405Info_CallbackBool;
  CMOCK_vLaserDataGetCan405Info_CALLBACK vLaserDataGetCan405Info_CallbackFunctionPointer;
  int vLaserDataGetCan405Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan405Info_CallInstance;
  char vLaserDataGetData406_IgnoreBool;
  c406PacketControlDefinition_t* vLaserDataGetData406_FinalReturn;
  char vLaserDataGetData406_CallbackBool;
  CMOCK_vLaserDataGetData406_CALLBACK vLaserDataGetData406_CallbackFunctionPointer;
  int vLaserDataGetData406_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData406_CallInstance;
  char vLaserDataGetCan406Info_IgnoreBool;
  char vLaserDataGetCan406Info_CallbackBool;
  CMOCK_vLaserDataGetCan406Info_CALLBACK vLaserDataGetCan406Info_CallbackFunctionPointer;
  int vLaserDataGetCan406Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan406Info_CallInstance;
  char vLaserDataSetCan406Info_IgnoreBool;
  char vLaserDataSetCan406Info_CallbackBool;
  CMOCK_vLaserDataSetCan406Info_CALLBACK vLaserDataSetCan406Info_CallbackFunctionPointer;
  int vLaserDataSetCan406Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataSetCan406Info_CallInstance;
  char vLaserDataGetData407_IgnoreBool;
  c407PacketControlDefinition_t* vLaserDataGetData407_FinalReturn;
  char vLaserDataGetData407_CallbackBool;
  CMOCK_vLaserDataGetData407_CALLBACK vLaserDataGetData407_CallbackFunctionPointer;
  int vLaserDataGetData407_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData407_CallInstance;
  char vLaserDataGetCan407Info_IgnoreBool;
  char vLaserDataGetCan407Info_CallbackBool;
  CMOCK_vLaserDataGetCan407Info_CALLBACK vLaserDataGetCan407Info_CallbackFunctionPointer;
  int vLaserDataGetCan407Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan407Info_CallInstance;
  char vLaserDataSetCan407Info_IgnoreBool;
  char vLaserDataSetCan407Info_CallbackBool;
  CMOCK_vLaserDataSetCan407Info_CALLBACK vLaserDataSetCan407Info_CallbackFunctionPointer;
  int vLaserDataSetCan407Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataSetCan407Info_CallInstance;
  char vLaserDataGetData408_IgnoreBool;
  c408StatusDefinition_t* vLaserDataGetData408_FinalReturn;
  char vLaserDataGetData408_CallbackBool;
  CMOCK_vLaserDataGetData408_CALLBACK vLaserDataGetData408_CallbackFunctionPointer;
  int vLaserDataGetData408_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData408_CallInstance;
  char vLaserDataGetCan408Info_IgnoreBool;
  char vLaserDataGetCan408Info_CallbackBool;
  CMOCK_vLaserDataGetCan408Info_CALLBACK vLaserDataGetCan408Info_CallbackFunctionPointer;
  int vLaserDataGetCan408Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan408Info_CallInstance;
  char vLaserDataGetData403_IgnoreBool;
  c403StatusDefinition_t* vLaserDataGetData403_FinalReturn;
  char vLaserDataGetData403_CallbackBool;
  CMOCK_vLaserDataGetData403_CALLBACK vLaserDataGetData403_CallbackFunctionPointer;
  int vLaserDataGetData403_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData403_CallInstance;
  char vLaserDataGetData404_IgnoreBool;
  c404StatusDefinition_t* vLaserDataGetData404_FinalReturn;
  char vLaserDataGetData404_CallbackBool;
  CMOCK_vLaserDataGetData404_CALLBACK vLaserDataGetData404_CallbackFunctionPointer;
  int vLaserDataGetData404_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData404_CallInstance;
  char vLaserDataGetData409_IgnoreBool;
  c409StatusDefinition_t* vLaserDataGetData409_FinalReturn;
  char vLaserDataGetData409_CallbackBool;
  CMOCK_vLaserDataGetData409_CALLBACK vLaserDataGetData409_CallbackFunctionPointer;
  int vLaserDataGetData409_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData409_CallInstance;
  char vLaserDataGetData410_IgnoreBool;
  c410StatusDefinition_t* vLaserDataGetData410_FinalReturn;
  char vLaserDataGetData410_CallbackBool;
  CMOCK_vLaserDataGetData410_CALLBACK vLaserDataGetData410_CallbackFunctionPointer;
  int vLaserDataGetData410_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData410_CallInstance;
  char vLaserDataGetData412_IgnoreBool;
  c412StatusDefinition_t* vLaserDataGetData412_FinalReturn;
  char vLaserDataGetData412_CallbackBool;
  CMOCK_vLaserDataGetData412_CALLBACK vLaserDataGetData412_CallbackFunctionPointer;
  int vLaserDataGetData412_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData412_CallInstance;
  char vLaserDataGetData413_IgnoreBool;
  c413StatusDefinition_t* vLaserDataGetData413_FinalReturn;
  char vLaserDataGetData413_CallbackBool;
  CMOCK_vLaserDataGetData413_CALLBACK vLaserDataGetData413_CallbackFunctionPointer;
  int vLaserDataGetData413_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetData413_CallInstance;
  char bValidatePassword_IgnoreBool;
  eBool_t bValidatePassword_FinalReturn;
  char bValidatePassword_CallbackBool;
  CMOCK_bValidatePassword_CALLBACK bValidatePassword_CallbackFunctionPointer;
  int bValidatePassword_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bValidatePassword_CallInstance;
  char vLaserDataGetCan409Info_IgnoreBool;
  char vLaserDataGetCan409Info_CallbackBool;
  CMOCK_vLaserDataGetCan409Info_CALLBACK vLaserDataGetCan409Info_CallbackFunctionPointer;
  int vLaserDataGetCan409Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan409Info_CallInstance;
  char vLaserDataGetCan409Pointer_IgnoreBool;
  c409StatusDefinition_t* vLaserDataGetCan409Pointer_FinalReturn;
  char vLaserDataGetCan409Pointer_CallbackBool;
  CMOCK_vLaserDataGetCan409Pointer_CALLBACK vLaserDataGetCan409Pointer_CallbackFunctionPointer;
  int vLaserDataGetCan409Pointer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan409Pointer_CallInstance;
  char vLaserDataGetCan40AInfo_IgnoreBool;
  c40AStatusDefinition_t* vLaserDataGetCan40AInfo_FinalReturn;
  char vLaserDataGetCan40AInfo_CallbackBool;
  CMOCK_vLaserDataGetCan40AInfo_CALLBACK vLaserDataGetCan40AInfo_CallbackFunctionPointer;
  int vLaserDataGetCan40AInfo_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan40AInfo_CallInstance;
  char vLaserDataGetCan423Info_IgnoreBool;
  char vLaserDataGetCan423Info_CallbackBool;
  CMOCK_vLaserDataGetCan423Info_CALLBACK vLaserDataGetCan423Info_CallbackFunctionPointer;
  int vLaserDataGetCan423Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan423Info_CallInstance;
  char pLaserDataGetCan428Info_IgnoreBool;
  c428StatusDefinition_t* pLaserDataGetCan428Info_FinalReturn;
  char pLaserDataGetCan428Info_CallbackBool;
  CMOCK_pLaserDataGetCan428Info_CALLBACK pLaserDataGetCan428Info_CallbackFunctionPointer;
  int pLaserDataGetCan428Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pLaserDataGetCan428Info_CallInstance;
  char pLaserDataGetThermistorData_IgnoreBool;
  xExternalAnalogThermistorsInputs_t* pLaserDataGetThermistorData_FinalReturn;
  char pLaserDataGetThermistorData_CallbackBool;
  CMOCK_pLaserDataGetThermistorData_CALLBACK pLaserDataGetThermistorData_CallbackFunctionPointer;
  int pLaserDataGetThermistorData_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pLaserDataGetThermistorData_CallInstance;
  char vLaserDataGetCan411Info_IgnoreBool;
  char vLaserDataGetCan411Info_CallbackBool;
  CMOCK_vLaserDataGetCan411Info_CALLBACK vLaserDataGetCan411Info_CallbackFunctionPointer;
  int vLaserDataGetCan411Info_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserDataGetCan411Info_CallInstance;
  char vUpdateCommonNvmMemory_IgnoreBool;
  char vUpdateCommonNvmMemory_CallbackBool;
  CMOCK_vUpdateCommonNvmMemory_CALLBACK vUpdateCommonNvmMemory_CallbackFunctionPointer;
  int vUpdateCommonNvmMemory_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateCommonNvmMemory_CallInstance;
  char vUpdateLnaNvmMemory_IgnoreBool;
  char vUpdateLnaNvmMemory_CallbackBool;
  CMOCK_vUpdateLnaNvmMemory_CALLBACK vUpdateLnaNvmMemory_CallbackFunctionPointer;
  int vUpdateLnaNvmMemory_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateLnaNvmMemory_CallInstance;
  char vUpdateBoostNvmMemory_IgnoreBool;
  char vUpdateBoostNvmMemory_CallbackBool;
  CMOCK_vUpdateBoostNvmMemory_CALLBACK vUpdateBoostNvmMemory_CallbackFunctionPointer;
  int vUpdateBoostNvmMemory_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateBoostNvmMemory_CallInstance;
  char vUpdateConfigInfo_IgnoreBool;
  char vUpdateConfigInfo_CallbackBool;
  CMOCK_vUpdateConfigInfo_CALLBACK vUpdateConfigInfo_CallbackFunctionPointer;
  int vUpdateConfigInfo_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateConfigInfo_CallInstance;
  char bInitCommonMemoryImageFromNvm_IgnoreBool;
  eBool_t bInitCommonMemoryImageFromNvm_FinalReturn;
  char bInitCommonMemoryImageFromNvm_CallbackBool;
  CMOCK_bInitCommonMemoryImageFromNvm_CALLBACK bInitCommonMemoryImageFromNvm_CallbackFunctionPointer;
  int bInitCommonMemoryImageFromNvm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bInitCommonMemoryImageFromNvm_CallInstance;
  char bInitLnaMemoryImageFromNvm_IgnoreBool;
  eBool_t bInitLnaMemoryImageFromNvm_FinalReturn;
  char bInitLnaMemoryImageFromNvm_CallbackBool;
  CMOCK_bInitLnaMemoryImageFromNvm_CALLBACK bInitLnaMemoryImageFromNvm_CallbackFunctionPointer;
  int bInitLnaMemoryImageFromNvm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bInitLnaMemoryImageFromNvm_CallInstance;
  char bInitBoostMemoryImageFromNvm_IgnoreBool;
  eBool_t bInitBoostMemoryImageFromNvm_FinalReturn;
  char bInitBoostMemoryImageFromNvm_CallbackBool;
  CMOCK_bInitBoostMemoryImageFromNvm_CALLBACK bInitBoostMemoryImageFromNvm_CallbackFunctionPointer;
  int bInitBoostMemoryImageFromNvm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bInitBoostMemoryImageFromNvm_CallInstance;
  char getLnaPidValues_IgnoreBool;
  xPidValues_t* getLnaPidValues_FinalReturn;
  char getLnaPidValues_CallbackBool;
  CMOCK_getLnaPidValues_CALLBACK getLnaPidValues_CallbackFunctionPointer;
  int getLnaPidValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE getLnaPidValues_CallInstance;
  char setLnaPidProportionalValue_IgnoreBool;
  char setLnaPidProportionalValue_CallbackBool;
  CMOCK_setLnaPidProportionalValue_CALLBACK setLnaPidProportionalValue_CallbackFunctionPointer;
  int setLnaPidProportionalValue_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE setLnaPidProportionalValue_CallInstance;
  char setLnaPidIntegralValue_IgnoreBool;
  char setLnaPidIntegralValue_CallbackBool;
  CMOCK_setLnaPidIntegralValue_CALLBACK setLnaPidIntegralValue_CallbackFunctionPointer;
  int setLnaPidIntegralValue_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE setLnaPidIntegralValue_CallInstance;
  char setLnaPidDerivativeValue_IgnoreBool;
  char setLnaPidDerivativeValue_CallbackBool;
  CMOCK_setLnaPidDerivativeValue_CALLBACK setLnaPidDerivativeValue_CallbackFunctionPointer;
  int setLnaPidDerivativeValue_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE setLnaPidDerivativeValue_CallInstance;
  char cGetresetCause_IgnoreBool;
  uint8_t cGetresetCause_FinalReturn;
  char cGetresetCause_CallbackBool;
  CMOCK_cGetresetCause_CALLBACK cGetresetCause_CallbackFunctionPointer;
  int cGetresetCause_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE cGetresetCause_CallInstance;
  char setInternalCriticalErrorFlag_IgnoreBool;
  char setInternalCriticalErrorFlag_CallbackBool;
  CMOCK_setInternalCriticalErrorFlag_CALLBACK setInternalCriticalErrorFlag_CallbackFunctionPointer;
  int setInternalCriticalErrorFlag_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE setInternalCriticalErrorFlag_CallInstance;
  char vInitWithFullResetRequest_IgnoreBool;
  char vInitWithFullResetRequest_CallbackBool;
  CMOCK_vInitWithFullResetRequest_CALLBACK vInitWithFullResetRequest_CallbackFunctionPointer;
  int vInitWithFullResetRequest_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vInitWithFullResetRequest_CallInstance;
  char vIncreaseSpiAdcErrors_IgnoreBool;
  char vIncreaseSpiAdcErrors_CallbackBool;
  CMOCK_vIncreaseSpiAdcErrors_CALLBACK vIncreaseSpiAdcErrors_CallbackFunctionPointer;
  int vIncreaseSpiAdcErrors_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vIncreaseSpiAdcErrors_CallInstance;
  char vClearSpiAdcErrors_IgnoreBool;
  char vClearSpiAdcErrors_CallbackBool;
  CMOCK_vClearSpiAdcErrors_CALLBACK vClearSpiAdcErrors_CallbackFunctionPointer;
  int vClearSpiAdcErrors_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vClearSpiAdcErrors_CallInstance;
  char vIncreaseSpiFramErrors_IgnoreBool;
  char vIncreaseSpiFramErrors_CallbackBool;
  CMOCK_vIncreaseSpiFramErrors_CALLBACK vIncreaseSpiFramErrors_CallbackFunctionPointer;
  int vIncreaseSpiFramErrors_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vIncreaseSpiFramErrors_CallInstance;
  char vClearSpiFramErrors_IgnoreBool;
  char vClearSpiFramErrors_CallbackBool;
  CMOCK_vClearSpiFramErrors_CALLBACK vClearSpiFramErrors_CallbackFunctionPointer;
  int vClearSpiFramErrors_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vClearSpiFramErrors_CallInstance;
  char vIncreaseCanErrors_IgnoreBool;
  char vIncreaseCanErrors_CallbackBool;
  CMOCK_vIncreaseCanErrors_CALLBACK vIncreaseCanErrors_CallbackFunctionPointer;
  int vIncreaseCanErrors_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vIncreaseCanErrors_CallInstance;
  char vGetUpdateMemoryWriteNeeded_IgnoreBool;
  eBool_t vGetUpdateMemoryWriteNeeded_FinalReturn;
  char vGetUpdateMemoryWriteNeeded_CallbackBool;
  CMOCK_vGetUpdateMemoryWriteNeeded_CALLBACK vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer;
  int vGetUpdateMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetUpdateMemoryWriteNeeded_CallInstance;
  char bResetIsDemanded_IgnoreBool;
  eBool_t bResetIsDemanded_FinalReturn;
  char bResetIsDemanded_CallbackBool;
  CMOCK_bResetIsDemanded_CALLBACK bResetIsDemanded_CallbackFunctionPointer;
  int bResetIsDemanded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bResetIsDemanded_CallInstance;
  char vGetUpdateCommonMemoryWriteNeeded_IgnoreBool;
  eBool_t vGetUpdateCommonMemoryWriteNeeded_FinalReturn;
  char vGetUpdateCommonMemoryWriteNeeded_CallbackBool;
  CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALLBACK vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer;
  int vGetUpdateCommonMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetUpdateCommonMemoryWriteNeeded_CallInstance;
  char vGetUpdateLnaMemoryWriteNeeded_IgnoreBool;
  eBool_t vGetUpdateLnaMemoryWriteNeeded_FinalReturn;
  char vGetUpdateLnaMemoryWriteNeeded_CallbackBool;
  CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALLBACK vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer;
  int vGetUpdateLnaMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetUpdateLnaMemoryWriteNeeded_CallInstance;
  char vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool;
  eBool_t vGetUpdateBoosterMemoryWriteNeeded_FinalReturn;
  char vGetUpdateBoosterMemoryWriteNeeded_CallbackBool;
  CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALLBACK vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer;
  int vGetUpdateBoosterMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetUpdateBoosterMemoryWriteNeeded_CallInstance;
  char vSetUpdateMemoryWriteNeeded_IgnoreBool;
  char vSetUpdateMemoryWriteNeeded_CallbackBool;
  CMOCK_vSetUpdateMemoryWriteNeeded_CALLBACK vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer;
  int vSetUpdateMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetUpdateMemoryWriteNeeded_CallInstance;
  char vSetUpdateCommonMemoryWriteNeeded_IgnoreBool;
  char vSetUpdateCommonMemoryWriteNeeded_CallbackBool;
  CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALLBACK vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer;
  int vSetUpdateCommonMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetUpdateCommonMemoryWriteNeeded_CallInstance;
  char vSetUpdateLnaMemoryWriteNeeded_IgnoreBool;
  char vSetUpdateLnaMemoryWriteNeeded_CallbackBool;
  CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALLBACK vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer;
  int vSetUpdateLnaMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetUpdateLnaMemoryWriteNeeded_CallInstance;
  char vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool;
  char vSetUpdateBoosterMemoryWriteNeeded_CallbackBool;
  CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALLBACK vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer;
  int vSetUpdateBoosterMemoryWriteNeeded_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetUpdateBoosterMemoryWriteNeeded_CallInstance;
  char vCopyImageCommonNvm_IgnoreBool;
  char vCopyImageCommonNvm_CallbackBool;
  CMOCK_vCopyImageCommonNvm_CALLBACK vCopyImageCommonNvm_CallbackFunctionPointer;
  int vCopyImageCommonNvm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vCopyImageCommonNvm_CallInstance;
  char vCopyImageLnaNvm_IgnoreBool;
  char vCopyImageLnaNvm_CallbackBool;
  CMOCK_vCopyImageLnaNvm_CALLBACK vCopyImageLnaNvm_CallbackFunctionPointer;
  int vCopyImageLnaNvm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vCopyImageLnaNvm_CallInstance;
  char vCopyImageBoosterNvm_IgnoreBool;
  char vCopyImageBoosterNvm_CallbackBool;
  CMOCK_vCopyImageBoosterNvm_CALLBACK vCopyImageBoosterNvm_CallbackFunctionPointer;
  int vCopyImageBoosterNvm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vCopyImageBoosterNvm_CallInstance;
  char vLaserSetCurrentAlarm_IgnoreBool;
  char vLaserSetCurrentAlarm_CallbackBool;
  CMOCK_vLaserSetCurrentAlarm_CALLBACK vLaserSetCurrentAlarm_CallbackFunctionPointer;
  int vLaserSetCurrentAlarm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vLaserSetCurrentAlarm_CallInstance;
  char vUpdateLnaPIDValues_IgnoreBool;
  char vUpdateLnaPIDValues_CallbackBool;
  CMOCK_vUpdateLnaPIDValues_CALLBACK vUpdateLnaPIDValues_CallbackFunctionPointer;
  int vUpdateLnaPIDValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateLnaPIDValues_CallInstance;
  char vUpdateHpaSmPIDValues_IgnoreBool;
  char vUpdateHpaSmPIDValues_CallbackBool;
  CMOCK_vUpdateHpaSmPIDValues_CALLBACK vUpdateHpaSmPIDValues_CallbackFunctionPointer;
  int vUpdateHpaSmPIDValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateHpaSmPIDValues_CallInstance;
  char vUploadHpaSmPIDValues_IgnoreBool;
  char vUploadHpaSmPIDValues_CallbackBool;
  CMOCK_vUploadHpaSmPIDValues_CALLBACK vUploadHpaSmPIDValues_CallbackFunctionPointer;
  int vUploadHpaSmPIDValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUploadHpaSmPIDValues_CallInstance;
  char vUpdateHpaMm1PIDValues_IgnoreBool;
  char vUpdateHpaMm1PIDValues_CallbackBool;
  CMOCK_vUpdateHpaMm1PIDValues_CALLBACK vUpdateHpaMm1PIDValues_CallbackFunctionPointer;
  int vUpdateHpaMm1PIDValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateHpaMm1PIDValues_CallInstance;
  char vUpdateHpaMm2PIDValues_IgnoreBool;
  char vUpdateHpaMm2PIDValues_CallbackBool;
  CMOCK_vUpdateHpaMm2PIDValues_CALLBACK vUpdateHpaMm2PIDValues_CallbackFunctionPointer;
  int vUpdateHpaMm2PIDValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateHpaMm2PIDValues_CallInstance;
  char vUpdateHpaMm1and2PIDValues_IgnoreBool;
  char vUpdateHpaMm1and2PIDValues_CallbackBool;
  CMOCK_vUpdateHpaMm1and2PIDValues_CALLBACK vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer;
  int vUpdateHpaMm1and2PIDValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vUpdateHpaMm1and2PIDValues_CallInstance;
  char vEnableLna_IgnoreBool;
  char vEnableLna_CallbackBool;
  CMOCK_vEnableLna_CALLBACK vEnableLna_CallbackFunctionPointer;
  int vEnableLna_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEnableLna_CallInstance;
  char vEnableHpaSingleMode_IgnoreBool;
  char vEnableHpaSingleMode_CallbackBool;
  CMOCK_vEnableHpaSingleMode_CALLBACK vEnableHpaSingleMode_CallbackFunctionPointer;
  int vEnableHpaSingleMode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEnableHpaSingleMode_CallInstance;
  char vEnableHpaMultiMode1_IgnoreBool;
  char vEnableHpaMultiMode1_CallbackBool;
  CMOCK_vEnableHpaMultiMode1_CALLBACK vEnableHpaMultiMode1_CallbackFunctionPointer;
  int vEnableHpaMultiMode1_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEnableHpaMultiMode1_CallInstance;
  char vEnableHpaMultiMode2_IgnoreBool;
  char vEnableHpaMultiMode2_CallbackBool;
  CMOCK_vEnableHpaMultiMode2_CALLBACK vEnableHpaMultiMode2_CallbackFunctionPointer;
  int vEnableHpaMultiMode2_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEnableHpaMultiMode2_CallInstance;
  char vpGetPumpTemperatureLimits_IgnoreBool;
  xPumpTemperaturesLimits_t* vpGetPumpTemperatureLimits_FinalReturn;
  char vpGetPumpTemperatureLimits_CallbackBool;
  CMOCK_vpGetPumpTemperatureLimits_CALLBACK vpGetPumpTemperatureLimits_CallbackFunctionPointer;
  int vpGetPumpTemperatureLimits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vpGetPumpTemperatureLimits_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_laserData_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.vLaserInitBooster_CallInstance;
  if (Mock.vLaserInitBooster_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserInitBooster);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserInitBooster_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserInitLna_CallInstance;
  if (Mock.vLaserInitLna_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserInitLna);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserInitLna_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataInit_CallInstance;
  if (Mock.vLaserDataInit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataInit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vControlAlarmInitAlarms_CallInstance;
  if (Mock.vControlAlarmInitAlarms_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vControlAlarmInitAlarms);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vControlAlarmInitAlarms_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.getCanSequence_CallInstance;
  if (Mock.getCanSequence_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_getCanSequence);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.getCanSequence_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.setCanSequence_CallInstance;
  if (Mock.setCanSequence_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setCanSequence);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.setCanSequence_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserBeamsFactoryCommonDefaultValues_CallInstance;
  if (Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserBeamsFactoryCommonDefaultValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserBeamsFactoryLnaDefaultValues_CallInstance;
  if (Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserBeamsFactoryLnaDefaultValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserBeamsFactoryBoosterDefaultValues_CallInstance;
  if (Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserBeamsFactoryBoosterDefaultValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetxAmplifierDescriptor_CallInstance;
  if (Mock.vGetxAmplifierDescriptor_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetxAmplifierDescriptor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetpxLnaParameters_CallInstance;
  if (Mock.vGetpxLnaParameters_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetpxLnaParameters);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetpxLnaParameters_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetpxBoosterParameters_CallInstance;
  if (Mock.vGetpxBoosterParameters_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetpxBoosterParameters);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetpxBoosterParameters_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserSetTemperatureInCan_CallInstance;
  if (Mock.vLaserSetTemperatureInCan_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserSetTemperatureInCan);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.eLaserGetLimitTemperature_CallInstance;
  if (Mock.eLaserGetLimitTemperature_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eLaserGetLimitTemperature);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.eLaserGetLimitTemperature_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserSetTemperatureFlagAlarm_CallInstance;
  if (Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserSetTemperatureFlagAlarm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetpxCommonControlParameters_CallInstance;
  if (Mock.vGetpxCommonControlParameters_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetpxCommonControlParameters);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetpxCommonControlParameters_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGet402Message_CallInstance;
  if (Mock.vGet402Message_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGet402Message);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGet402Message_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bCanPort1IsSelected_CallInstance;
  if (Mock.bCanPort1IsSelected_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bCanPort1IsSelected);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bCanPort1IsSelected_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetCanPort1_CallInstance;
  if (Mock.vSetCanPort1_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetCanPort1);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetCanPort1_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetSerialNumber_CallInstance;
  if (Mock.vGetSerialNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetSerialNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetSerialNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetSerialNumber_CallInstance;
  if (Mock.vSetSerialNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetSerialNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetSerialNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetSendConfig_CallInstance;
  if (Mock.vSetSendConfig_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetSendConfig);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetSendConfig_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bGetSendConfig_CallInstance;
  if (Mock.bGetSendConfig_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bGetSendConfig);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bGetSendConfig_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vResetSendConfig_CallInstance;
  if (Mock.vResetSendConfig_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vResetSendConfig);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vResetSendConfig_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetCompanyId_CallInstance;
  if (Mock.vGetCompanyId_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetCompanyId);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetCompanyId_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetCompanyId_CallInstance;
  if (Mock.vSetCompanyId_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetCompanyId);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetCompanyId_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan401Info_CallInstance;
  if (Mock.vLaserDataGetCan401Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan401Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan401Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pLaserDataGetCan414Info_CallInstance;
  if (Mock.pLaserDataGetCan414Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pLaserDataGetCan414Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pLaserDataGetCan414Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pLaserDataGetCan415Info_CallInstance;
  if (Mock.pLaserDataGetCan415Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pLaserDataGetCan415Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pLaserDataGetCan415Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData402_CallInstance;
  if (Mock.vLaserDataGetData402_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData402);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData402_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan402Info_CallInstance;
  if (Mock.vLaserDataGetCan402Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan402Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan402Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pLaserDataGetCan402Pointer_CallInstance;
  if (Mock.pLaserDataGetCan402Pointer_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pLaserDataGetCan402Pointer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan403Info_CallInstance;
  if (Mock.vLaserDataGetCan403Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan403Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan403Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan404Info_CallInstance;
  if (Mock.vLaserDataGetCan404Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan404Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan404Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan405Info_CallInstance;
  if (Mock.vLaserDataGetCan405Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan405Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan405Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData406_CallInstance;
  if (Mock.vLaserDataGetData406_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData406);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData406_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan406Info_CallInstance;
  if (Mock.vLaserDataGetCan406Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan406Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan406Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataSetCan406Info_CallInstance;
  if (Mock.vLaserDataSetCan406Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataSetCan406Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataSetCan406Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData407_CallInstance;
  if (Mock.vLaserDataGetData407_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData407);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData407_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan407Info_CallInstance;
  if (Mock.vLaserDataGetCan407Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan407Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan407Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataSetCan407Info_CallInstance;
  if (Mock.vLaserDataSetCan407Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataSetCan407Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataSetCan407Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData408_CallInstance;
  if (Mock.vLaserDataGetData408_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData408);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData408_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan408Info_CallInstance;
  if (Mock.vLaserDataGetCan408Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan408Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan408Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData403_CallInstance;
  if (Mock.vLaserDataGetData403_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData403);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData403_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData404_CallInstance;
  if (Mock.vLaserDataGetData404_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData404);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData404_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData409_CallInstance;
  if (Mock.vLaserDataGetData409_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData409);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData409_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData410_CallInstance;
  if (Mock.vLaserDataGetData410_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData410);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData410_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData412_CallInstance;
  if (Mock.vLaserDataGetData412_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData412);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData412_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetData413_CallInstance;
  if (Mock.vLaserDataGetData413_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetData413);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetData413_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bValidatePassword_CallInstance;
  if (Mock.bValidatePassword_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bValidatePassword);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bValidatePassword_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan409Info_CallInstance;
  if (Mock.vLaserDataGetCan409Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan409Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan409Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan409Pointer_CallInstance;
  if (Mock.vLaserDataGetCan409Pointer_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan409Pointer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan40AInfo_CallInstance;
  if (Mock.vLaserDataGetCan40AInfo_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan40AInfo);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan423Info_CallInstance;
  if (Mock.vLaserDataGetCan423Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan423Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan423Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pLaserDataGetCan428Info_CallInstance;
  if (Mock.pLaserDataGetCan428Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pLaserDataGetCan428Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pLaserDataGetCan428Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pLaserDataGetThermistorData_CallInstance;
  if (Mock.pLaserDataGetThermistorData_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pLaserDataGetThermistorData);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pLaserDataGetThermistorData_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserDataGetCan411Info_CallInstance;
  if (Mock.vLaserDataGetCan411Info_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserDataGetCan411Info);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserDataGetCan411Info_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateCommonNvmMemory_CallInstance;
  if (Mock.vUpdateCommonNvmMemory_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateCommonNvmMemory);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateLnaNvmMemory_CallInstance;
  if (Mock.vUpdateLnaNvmMemory_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateLnaNvmMemory);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateBoostNvmMemory_CallInstance;
  if (Mock.vUpdateBoostNvmMemory_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateBoostNvmMemory);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateConfigInfo_CallInstance;
  if (Mock.vUpdateConfigInfo_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateConfigInfo);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateConfigInfo_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bInitCommonMemoryImageFromNvm_CallInstance;
  if (Mock.bInitCommonMemoryImageFromNvm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bInitCommonMemoryImageFromNvm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bInitLnaMemoryImageFromNvm_CallInstance;
  if (Mock.bInitLnaMemoryImageFromNvm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bInitLnaMemoryImageFromNvm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bInitBoostMemoryImageFromNvm_CallInstance;
  if (Mock.bInitBoostMemoryImageFromNvm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bInitBoostMemoryImageFromNvm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.getLnaPidValues_CallInstance;
  if (Mock.getLnaPidValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_getLnaPidValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.getLnaPidValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.setLnaPidProportionalValue_CallInstance;
  if (Mock.setLnaPidProportionalValue_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setLnaPidProportionalValue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.setLnaPidProportionalValue_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.setLnaPidIntegralValue_CallInstance;
  if (Mock.setLnaPidIntegralValue_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setLnaPidIntegralValue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.setLnaPidIntegralValue_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.setLnaPidDerivativeValue_CallInstance;
  if (Mock.setLnaPidDerivativeValue_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setLnaPidDerivativeValue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.setLnaPidDerivativeValue_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.cGetresetCause_CallInstance;
  if (Mock.cGetresetCause_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_cGetresetCause);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.cGetresetCause_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.setInternalCriticalErrorFlag_CallInstance;
  if (Mock.setInternalCriticalErrorFlag_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setInternalCriticalErrorFlag);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vInitWithFullResetRequest_CallInstance;
  if (Mock.vInitWithFullResetRequest_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vInitWithFullResetRequest);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vInitWithFullResetRequest_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vIncreaseSpiAdcErrors_CallInstance;
  if (Mock.vIncreaseSpiAdcErrors_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vIncreaseSpiAdcErrors);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vClearSpiAdcErrors_CallInstance;
  if (Mock.vClearSpiAdcErrors_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vClearSpiAdcErrors);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vClearSpiAdcErrors_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vIncreaseSpiFramErrors_CallInstance;
  if (Mock.vIncreaseSpiFramErrors_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vIncreaseSpiFramErrors);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vClearSpiFramErrors_CallInstance;
  if (Mock.vClearSpiFramErrors_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vClearSpiFramErrors);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vClearSpiFramErrors_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vIncreaseCanErrors_CallInstance;
  if (Mock.vIncreaseCanErrors_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vIncreaseCanErrors);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vIncreaseCanErrors_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetUpdateMemoryWriteNeeded_CallInstance;
  if (Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetUpdateMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bResetIsDemanded_CallInstance;
  if (Mock.bResetIsDemanded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bResetIsDemanded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bResetIsDemanded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance;
  if (Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetUpdateCommonMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance;
  if (Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetUpdateLnaMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance;
  if (Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetUpdateBoosterMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetUpdateMemoryWriteNeeded_CallInstance;
  if (Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetUpdateMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance;
  if (Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetUpdateCommonMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance;
  if (Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetUpdateLnaMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance;
  if (Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetUpdateBoosterMemoryWriteNeeded);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vCopyImageCommonNvm_CallInstance;
  if (Mock.vCopyImageCommonNvm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vCopyImageCommonNvm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vCopyImageCommonNvm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vCopyImageLnaNvm_CallInstance;
  if (Mock.vCopyImageLnaNvm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vCopyImageLnaNvm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vCopyImageLnaNvm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vCopyImageBoosterNvm_CallInstance;
  if (Mock.vCopyImageBoosterNvm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vCopyImageBoosterNvm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vCopyImageBoosterNvm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vLaserSetCurrentAlarm_CallInstance;
  if (Mock.vLaserSetCurrentAlarm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vLaserSetCurrentAlarm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateLnaPIDValues_CallInstance;
  if (Mock.vUpdateLnaPIDValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateLnaPIDValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateLnaPIDValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateHpaSmPIDValues_CallInstance;
  if (Mock.vUpdateHpaSmPIDValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateHpaSmPIDValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUploadHpaSmPIDValues_CallInstance;
  if (Mock.vUploadHpaSmPIDValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUploadHpaSmPIDValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateHpaMm1PIDValues_CallInstance;
  if (Mock.vUpdateHpaMm1PIDValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateHpaMm1PIDValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateHpaMm2PIDValues_CallInstance;
  if (Mock.vUpdateHpaMm2PIDValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateHpaMm2PIDValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vUpdateHpaMm1and2PIDValues_CallInstance;
  if (Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vUpdateHpaMm1and2PIDValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEnableLna_CallInstance;
  if (Mock.vEnableLna_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEnableLna);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEnableLna_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEnableHpaSingleMode_CallInstance;
  if (Mock.vEnableHpaSingleMode_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEnableHpaSingleMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEnableHpaSingleMode_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEnableHpaMultiMode1_CallInstance;
  if (Mock.vEnableHpaMultiMode1_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEnableHpaMultiMode1);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEnableHpaMultiMode1_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEnableHpaMultiMode2_CallInstance;
  if (Mock.vEnableHpaMultiMode2_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEnableHpaMultiMode2);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEnableHpaMultiMode2_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vpGetPumpTemperatureLimits_CallInstance;
  if (Mock.vpGetPumpTemperatureLimits_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vpGetPumpTemperatureLimits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_laserData_Init(void)
{
  mock_laserData_Destroy();
}

void mock_laserData_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

void vLaserInitBooster(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserInitBooster_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserInitBooster);
  cmock_call_instance = (CMOCK_vLaserInitBooster_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserInitBooster_CallInstance);
  Mock.vLaserInitBooster_CallInstance = CMock_Guts_MemNext(Mock.vLaserInitBooster_CallInstance);
  if (Mock.vLaserInitBooster_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserInitBooster_CallbackBool &&
      Mock.vLaserInitBooster_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserInitBooster_CallbackFunctionPointer(Mock.vLaserInitBooster_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserInitBooster_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserInitBooster_CallbackFunctionPointer(Mock.vLaserInitBooster_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vLaserInitBooster_CMockIgnore(void)
{
  Mock.vLaserInitBooster_IgnoreBool = (char)1;
}

void vLaserInitBooster_CMockStopIgnore(void)
{
  Mock.vLaserInitBooster_IgnoreBool = (char)0;
}

void vLaserInitBooster_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserInitBooster_CALL_INSTANCE));
  CMOCK_vLaserInitBooster_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserInitBooster_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserInitBooster_CallInstance = CMock_Guts_MemChain(Mock.vLaserInitBooster_CallInstance, cmock_guts_index);
  Mock.vLaserInitBooster_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vLaserInitBooster_AddCallback(CMOCK_vLaserInitBooster_CALLBACK Callback)
{
  Mock.vLaserInitBooster_IgnoreBool = (char)0;
  Mock.vLaserInitBooster_CallbackBool = (char)1;
  Mock.vLaserInitBooster_CallbackFunctionPointer = Callback;
}

void vLaserInitBooster_Stub(CMOCK_vLaserInitBooster_CALLBACK Callback)
{
  Mock.vLaserInitBooster_IgnoreBool = (char)0;
  Mock.vLaserInitBooster_CallbackBool = (char)0;
  Mock.vLaserInitBooster_CallbackFunctionPointer = Callback;
}

void vLaserInitLna(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserInitLna_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserInitLna);
  cmock_call_instance = (CMOCK_vLaserInitLna_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserInitLna_CallInstance);
  Mock.vLaserInitLna_CallInstance = CMock_Guts_MemNext(Mock.vLaserInitLna_CallInstance);
  if (Mock.vLaserInitLna_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserInitLna_CallbackBool &&
      Mock.vLaserInitLna_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserInitLna_CallbackFunctionPointer(Mock.vLaserInitLna_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserInitLna_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserInitLna_CallbackFunctionPointer(Mock.vLaserInitLna_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vLaserInitLna_CMockIgnore(void)
{
  Mock.vLaserInitLna_IgnoreBool = (char)1;
}

void vLaserInitLna_CMockStopIgnore(void)
{
  Mock.vLaserInitLna_IgnoreBool = (char)0;
}

void vLaserInitLna_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserInitLna_CALL_INSTANCE));
  CMOCK_vLaserInitLna_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserInitLna_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserInitLna_CallInstance = CMock_Guts_MemChain(Mock.vLaserInitLna_CallInstance, cmock_guts_index);
  Mock.vLaserInitLna_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vLaserInitLna_AddCallback(CMOCK_vLaserInitLna_CALLBACK Callback)
{
  Mock.vLaserInitLna_IgnoreBool = (char)0;
  Mock.vLaserInitLna_CallbackBool = (char)1;
  Mock.vLaserInitLna_CallbackFunctionPointer = Callback;
}

void vLaserInitLna_Stub(CMOCK_vLaserInitLna_CALLBACK Callback)
{
  Mock.vLaserInitLna_IgnoreBool = (char)0;
  Mock.vLaserInitLna_CallbackBool = (char)0;
  Mock.vLaserInitLna_CallbackFunctionPointer = Callback;
}

void vLaserDataInit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataInit);
  cmock_call_instance = (CMOCK_vLaserDataInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataInit_CallInstance);
  Mock.vLaserDataInit_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataInit_CallInstance);
  if (Mock.vLaserDataInit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataInit_CallbackBool &&
      Mock.vLaserDataInit_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataInit_CallbackFunctionPointer(Mock.vLaserDataInit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataInit_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataInit_CallbackFunctionPointer(Mock.vLaserDataInit_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vLaserDataInit_CMockIgnore(void)
{
  Mock.vLaserDataInit_IgnoreBool = (char)1;
}

void vLaserDataInit_CMockStopIgnore(void)
{
  Mock.vLaserDataInit_IgnoreBool = (char)0;
}

void vLaserDataInit_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataInit_CALL_INSTANCE));
  CMOCK_vLaserDataInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataInit_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataInit_CallInstance, cmock_guts_index);
  Mock.vLaserDataInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vLaserDataInit_AddCallback(CMOCK_vLaserDataInit_CALLBACK Callback)
{
  Mock.vLaserDataInit_IgnoreBool = (char)0;
  Mock.vLaserDataInit_CallbackBool = (char)1;
  Mock.vLaserDataInit_CallbackFunctionPointer = Callback;
}

void vLaserDataInit_Stub(CMOCK_vLaserDataInit_CALLBACK Callback)
{
  Mock.vLaserDataInit_IgnoreBool = (char)0;
  Mock.vLaserDataInit_CallbackBool = (char)0;
  Mock.vLaserDataInit_CallbackFunctionPointer = Callback;
}

void vControlAlarmInitAlarms(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vControlAlarmInitAlarms);
  cmock_call_instance = (CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vControlAlarmInitAlarms_CallInstance);
  Mock.vControlAlarmInitAlarms_CallInstance = CMock_Guts_MemNext(Mock.vControlAlarmInitAlarms_CallInstance);
  if (Mock.vControlAlarmInitAlarms_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vControlAlarmInitAlarms_CallbackBool &&
      Mock.vControlAlarmInitAlarms_CallbackFunctionPointer != NULL)
  {
    Mock.vControlAlarmInitAlarms_CallbackFunctionPointer(Mock.vControlAlarmInitAlarms_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vControlAlarmInitAlarms_CallbackFunctionPointer != NULL)
  {
    Mock.vControlAlarmInitAlarms_CallbackFunctionPointer(Mock.vControlAlarmInitAlarms_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vControlAlarmInitAlarms_CMockIgnore(void)
{
  Mock.vControlAlarmInitAlarms_IgnoreBool = (char)1;
}

void vControlAlarmInitAlarms_CMockStopIgnore(void)
{
  Mock.vControlAlarmInitAlarms_IgnoreBool = (char)0;
}

void vControlAlarmInitAlarms_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE));
  CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlAlarmInitAlarms_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlAlarmInitAlarms_CallInstance = CMock_Guts_MemChain(Mock.vControlAlarmInitAlarms_CallInstance, cmock_guts_index);
  Mock.vControlAlarmInitAlarms_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vControlAlarmInitAlarms_AddCallback(CMOCK_vControlAlarmInitAlarms_CALLBACK Callback)
{
  Mock.vControlAlarmInitAlarms_IgnoreBool = (char)0;
  Mock.vControlAlarmInitAlarms_CallbackBool = (char)1;
  Mock.vControlAlarmInitAlarms_CallbackFunctionPointer = Callback;
}

void vControlAlarmInitAlarms_Stub(CMOCK_vControlAlarmInitAlarms_CALLBACK Callback)
{
  Mock.vControlAlarmInitAlarms_IgnoreBool = (char)0;
  Mock.vControlAlarmInitAlarms_CallbackBool = (char)0;
  Mock.vControlAlarmInitAlarms_CallbackFunctionPointer = Callback;
}

CanSequence_t getCanSequence(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_getCanSequence_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_getCanSequence);
  cmock_call_instance = (CMOCK_getCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.getCanSequence_CallInstance);
  Mock.getCanSequence_CallInstance = CMock_Guts_MemNext(Mock.getCanSequence_CallInstance);
  if (Mock.getCanSequence_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.getCanSequence_FinalReturn;
    memcpy((void*)(&Mock.getCanSequence_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(CanSequence_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(CanSequence_t) ? 1 : -1])); /* add CanSequence_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.getCanSequence_CallbackBool &&
      Mock.getCanSequence_CallbackFunctionPointer != NULL)
  {
    CanSequence_t cmock_cb_ret = Mock.getCanSequence_CallbackFunctionPointer(Mock.getCanSequence_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.getCanSequence_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.getCanSequence_CallbackFunctionPointer(Mock.getCanSequence_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void getCanSequence_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, CanSequence_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getCanSequence_CALL_INSTANCE));
  CMOCK_getCanSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_getCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getCanSequence_CallInstance = CMock_Guts_MemChain(Mock.getCanSequence_CallInstance, cmock_guts_index);
  Mock.getCanSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.getCanSequence_IgnoreBool = (char)1;
}

void getCanSequence_CMockStopIgnore(void)
{
  if(Mock.getCanSequence_IgnoreBool)
    Mock.getCanSequence_CallInstance = CMock_Guts_MemNext(Mock.getCanSequence_CallInstance);
  Mock.getCanSequence_IgnoreBool = (char)0;
}

void getCanSequence_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CanSequence_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getCanSequence_CALL_INSTANCE));
  CMOCK_getCanSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_getCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getCanSequence_CallInstance = CMock_Guts_MemChain(Mock.getCanSequence_CallInstance, cmock_guts_index);
  Mock.getCanSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(CanSequence_t[sizeof(cmock_to_return) == sizeof(CanSequence_t) ? 1 : -1])); /* add CanSequence_t to :treat_as_array if this causes an error */
}

void getCanSequence_AddCallback(CMOCK_getCanSequence_CALLBACK Callback)
{
  Mock.getCanSequence_IgnoreBool = (char)0;
  Mock.getCanSequence_CallbackBool = (char)1;
  Mock.getCanSequence_CallbackFunctionPointer = Callback;
}

void getCanSequence_Stub(CMOCK_getCanSequence_CALLBACK Callback)
{
  Mock.getCanSequence_IgnoreBool = (char)0;
  Mock.getCanSequence_CallbackBool = (char)0;
  Mock.getCanSequence_CallbackFunctionPointer = Callback;
}

void setCanSequence(CanSequence_t CanSequence)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setCanSequence_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setCanSequence);
  cmock_call_instance = (CMOCK_setCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setCanSequence_CallInstance);
  Mock.setCanSequence_CallInstance = CMock_Guts_MemNext(Mock.setCanSequence_CallInstance);
  if (Mock.setCanSequence_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.setCanSequence_CallbackBool &&
      Mock.setCanSequence_CallbackFunctionPointer != NULL)
  {
    Mock.setCanSequence_CallbackFunctionPointer(CanSequence, Mock.setCanSequence_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_CanSequence)
  {
    UNITY_SET_DETAILS(CMockString_setCanSequence,CMockString_CanSequence);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_CanSequence), (void*)(&CanSequence), sizeof(CanSequence_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.setCanSequence_CallbackFunctionPointer != NULL)
  {
    Mock.setCanSequence_CallbackFunctionPointer(CanSequence, Mock.setCanSequence_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_setCanSequence(CMOCK_setCanSequence_CALL_INSTANCE* cmock_call_instance, CanSequence_t CanSequence);
void CMockExpectParameters_setCanSequence(CMOCK_setCanSequence_CALL_INSTANCE* cmock_call_instance, CanSequence_t CanSequence)
{
  memcpy((void*)(&cmock_call_instance->Expected_CanSequence), (void*)(&CanSequence),
         sizeof(CanSequence_t[sizeof(CanSequence) == sizeof(CanSequence_t) ? 1 : -1])); /* add CanSequence_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_CanSequence = 0;
}

void setCanSequence_CMockIgnore(void)
{
  Mock.setCanSequence_IgnoreBool = (char)1;
}

void setCanSequence_CMockStopIgnore(void)
{
  Mock.setCanSequence_IgnoreBool = (char)0;
}

void setCanSequence_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setCanSequence_CALL_INSTANCE));
  CMOCK_setCanSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_setCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setCanSequence_CallInstance = CMock_Guts_MemChain(Mock.setCanSequence_CallInstance, cmock_guts_index);
  Mock.setCanSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void setCanSequence_CMockExpect(UNITY_LINE_TYPE cmock_line, CanSequence_t CanSequence)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setCanSequence_CALL_INSTANCE));
  CMOCK_setCanSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_setCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setCanSequence_CallInstance = CMock_Guts_MemChain(Mock.setCanSequence_CallInstance, cmock_guts_index);
  Mock.setCanSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_setCanSequence(cmock_call_instance, CanSequence);
}

void setCanSequence_AddCallback(CMOCK_setCanSequence_CALLBACK Callback)
{
  Mock.setCanSequence_IgnoreBool = (char)0;
  Mock.setCanSequence_CallbackBool = (char)1;
  Mock.setCanSequence_CallbackFunctionPointer = Callback;
}

void setCanSequence_Stub(CMOCK_setCanSequence_CALLBACK Callback)
{
  Mock.setCanSequence_IgnoreBool = (char)0;
  Mock.setCanSequence_CallbackBool = (char)0;
  Mock.setCanSequence_CallbackFunctionPointer = Callback;
}

void setCanSequence_CMockIgnoreArg_CanSequence(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_setCanSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_setCanSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.setCanSequence_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_CanSequence = 1;
}

void vLaserBeamsFactoryCommonDefaultValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserBeamsFactoryCommonDefaultValues);
  cmock_call_instance = (CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserBeamsFactoryCommonDefaultValues_CallInstance);
  Mock.vLaserBeamsFactoryCommonDefaultValues_CallInstance = CMock_Guts_MemNext(Mock.vLaserBeamsFactoryCommonDefaultValues_CallInstance);
  if (Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackBool &&
      Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer(Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer(Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vLaserBeamsFactoryCommonDefaultValues_CMockIgnore(void)
{
  Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool = (char)1;
}

void vLaserBeamsFactoryCommonDefaultValues_CMockStopIgnore(void)
{
  Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool = (char)0;
}

void vLaserBeamsFactoryCommonDefaultValues_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE));
  CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserBeamsFactoryCommonDefaultValues_CallInstance = CMock_Guts_MemChain(Mock.vLaserBeamsFactoryCommonDefaultValues_CallInstance, cmock_guts_index);
  Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vLaserBeamsFactoryCommonDefaultValues_AddCallback(CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALLBACK Callback)
{
  Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool = (char)0;
  Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackBool = (char)1;
  Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer = Callback;
}

void vLaserBeamsFactoryCommonDefaultValues_Stub(CMOCK_vLaserBeamsFactoryCommonDefaultValues_CALLBACK Callback)
{
  Mock.vLaserBeamsFactoryCommonDefaultValues_IgnoreBool = (char)0;
  Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackBool = (char)0;
  Mock.vLaserBeamsFactoryCommonDefaultValues_CallbackFunctionPointer = Callback;
}

void vLaserBeamsFactoryLnaDefaultValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserBeamsFactoryLnaDefaultValues);
  cmock_call_instance = (CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserBeamsFactoryLnaDefaultValues_CallInstance);
  Mock.vLaserBeamsFactoryLnaDefaultValues_CallInstance = CMock_Guts_MemNext(Mock.vLaserBeamsFactoryLnaDefaultValues_CallInstance);
  if (Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackBool &&
      Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer(Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer(Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vLaserBeamsFactoryLnaDefaultValues_CMockIgnore(void)
{
  Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool = (char)1;
}

void vLaserBeamsFactoryLnaDefaultValues_CMockStopIgnore(void)
{
  Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool = (char)0;
}

void vLaserBeamsFactoryLnaDefaultValues_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE));
  CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserBeamsFactoryLnaDefaultValues_CallInstance = CMock_Guts_MemChain(Mock.vLaserBeamsFactoryLnaDefaultValues_CallInstance, cmock_guts_index);
  Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vLaserBeamsFactoryLnaDefaultValues_AddCallback(CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALLBACK Callback)
{
  Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool = (char)0;
  Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackBool = (char)1;
  Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer = Callback;
}

void vLaserBeamsFactoryLnaDefaultValues_Stub(CMOCK_vLaserBeamsFactoryLnaDefaultValues_CALLBACK Callback)
{
  Mock.vLaserBeamsFactoryLnaDefaultValues_IgnoreBool = (char)0;
  Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackBool = (char)0;
  Mock.vLaserBeamsFactoryLnaDefaultValues_CallbackFunctionPointer = Callback;
}

void vLaserBeamsFactoryBoosterDefaultValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserBeamsFactoryBoosterDefaultValues);
  cmock_call_instance = (CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserBeamsFactoryBoosterDefaultValues_CallInstance);
  Mock.vLaserBeamsFactoryBoosterDefaultValues_CallInstance = CMock_Guts_MemNext(Mock.vLaserBeamsFactoryBoosterDefaultValues_CallInstance);
  if (Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackBool &&
      Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer(Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer(Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vLaserBeamsFactoryBoosterDefaultValues_CMockIgnore(void)
{
  Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool = (char)1;
}

void vLaserBeamsFactoryBoosterDefaultValues_CMockStopIgnore(void)
{
  Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool = (char)0;
}

void vLaserBeamsFactoryBoosterDefaultValues_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE));
  CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserBeamsFactoryBoosterDefaultValues_CallInstance = CMock_Guts_MemChain(Mock.vLaserBeamsFactoryBoosterDefaultValues_CallInstance, cmock_guts_index);
  Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vLaserBeamsFactoryBoosterDefaultValues_AddCallback(CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALLBACK Callback)
{
  Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool = (char)0;
  Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackBool = (char)1;
  Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer = Callback;
}

void vLaserBeamsFactoryBoosterDefaultValues_Stub(CMOCK_vLaserBeamsFactoryBoosterDefaultValues_CALLBACK Callback)
{
  Mock.vLaserBeamsFactoryBoosterDefaultValues_IgnoreBool = (char)0;
  Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackBool = (char)0;
  Mock.vLaserBeamsFactoryBoosterDefaultValues_CallbackFunctionPointer = Callback;
}

xAmplifierDescriptor_t* vGetxAmplifierDescriptor(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetxAmplifierDescriptor);
  cmock_call_instance = (CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetxAmplifierDescriptor_CallInstance);
  Mock.vGetxAmplifierDescriptor_CallInstance = CMock_Guts_MemNext(Mock.vGetxAmplifierDescriptor_CallInstance);
  if (Mock.vGetxAmplifierDescriptor_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetxAmplifierDescriptor_FinalReturn;
    Mock.vGetxAmplifierDescriptor_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetxAmplifierDescriptor_CallbackBool &&
      Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer != NULL)
  {
    xAmplifierDescriptor_t* cmock_cb_ret = Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer(Mock.vGetxAmplifierDescriptor_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer(Mock.vGetxAmplifierDescriptor_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetxAmplifierDescriptor_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xAmplifierDescriptor_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE));
  CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetxAmplifierDescriptor_CallInstance = CMock_Guts_MemChain(Mock.vGetxAmplifierDescriptor_CallInstance, cmock_guts_index);
  Mock.vGetxAmplifierDescriptor_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetxAmplifierDescriptor_IgnoreBool = (char)1;
}

void vGetxAmplifierDescriptor_CMockStopIgnore(void)
{
  if(Mock.vGetxAmplifierDescriptor_IgnoreBool)
    Mock.vGetxAmplifierDescriptor_CallInstance = CMock_Guts_MemNext(Mock.vGetxAmplifierDescriptor_CallInstance);
  Mock.vGetxAmplifierDescriptor_IgnoreBool = (char)0;
}

void vGetxAmplifierDescriptor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xAmplifierDescriptor_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE));
  CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetxAmplifierDescriptor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetxAmplifierDescriptor_CallInstance = CMock_Guts_MemChain(Mock.vGetxAmplifierDescriptor_CallInstance, cmock_guts_index);
  Mock.vGetxAmplifierDescriptor_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vGetxAmplifierDescriptor_AddCallback(CMOCK_vGetxAmplifierDescriptor_CALLBACK Callback)
{
  Mock.vGetxAmplifierDescriptor_IgnoreBool = (char)0;
  Mock.vGetxAmplifierDescriptor_CallbackBool = (char)1;
  Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer = Callback;
}

void vGetxAmplifierDescriptor_Stub(CMOCK_vGetxAmplifierDescriptor_CALLBACK Callback)
{
  Mock.vGetxAmplifierDescriptor_IgnoreBool = (char)0;
  Mock.vGetxAmplifierDescriptor_CallbackBool = (char)0;
  Mock.vGetxAmplifierDescriptor_CallbackFunctionPointer = Callback;
}

xLnaParameters_t* vGetpxLnaParameters(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetpxLnaParameters_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetpxLnaParameters);
  cmock_call_instance = (CMOCK_vGetpxLnaParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetpxLnaParameters_CallInstance);
  Mock.vGetpxLnaParameters_CallInstance = CMock_Guts_MemNext(Mock.vGetpxLnaParameters_CallInstance);
  if (Mock.vGetpxLnaParameters_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetpxLnaParameters_FinalReturn;
    Mock.vGetpxLnaParameters_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetpxLnaParameters_CallbackBool &&
      Mock.vGetpxLnaParameters_CallbackFunctionPointer != NULL)
  {
    xLnaParameters_t* cmock_cb_ret = Mock.vGetpxLnaParameters_CallbackFunctionPointer(Mock.vGetpxLnaParameters_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetpxLnaParameters_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetpxLnaParameters_CallbackFunctionPointer(Mock.vGetpxLnaParameters_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetpxLnaParameters_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xLnaParameters_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetpxLnaParameters_CALL_INSTANCE));
  CMOCK_vGetpxLnaParameters_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetpxLnaParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetpxLnaParameters_CallInstance = CMock_Guts_MemChain(Mock.vGetpxLnaParameters_CallInstance, cmock_guts_index);
  Mock.vGetpxLnaParameters_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetpxLnaParameters_IgnoreBool = (char)1;
}

void vGetpxLnaParameters_CMockStopIgnore(void)
{
  if(Mock.vGetpxLnaParameters_IgnoreBool)
    Mock.vGetpxLnaParameters_CallInstance = CMock_Guts_MemNext(Mock.vGetpxLnaParameters_CallInstance);
  Mock.vGetpxLnaParameters_IgnoreBool = (char)0;
}

void vGetpxLnaParameters_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xLnaParameters_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetpxLnaParameters_CALL_INSTANCE));
  CMOCK_vGetpxLnaParameters_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetpxLnaParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetpxLnaParameters_CallInstance = CMock_Guts_MemChain(Mock.vGetpxLnaParameters_CallInstance, cmock_guts_index);
  Mock.vGetpxLnaParameters_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vGetpxLnaParameters_AddCallback(CMOCK_vGetpxLnaParameters_CALLBACK Callback)
{
  Mock.vGetpxLnaParameters_IgnoreBool = (char)0;
  Mock.vGetpxLnaParameters_CallbackBool = (char)1;
  Mock.vGetpxLnaParameters_CallbackFunctionPointer = Callback;
}

void vGetpxLnaParameters_Stub(CMOCK_vGetpxLnaParameters_CALLBACK Callback)
{
  Mock.vGetpxLnaParameters_IgnoreBool = (char)0;
  Mock.vGetpxLnaParameters_CallbackBool = (char)0;
  Mock.vGetpxLnaParameters_CallbackFunctionPointer = Callback;
}

xBoosterParameters_t* vGetpxBoosterParameters(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetpxBoosterParameters_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetpxBoosterParameters);
  cmock_call_instance = (CMOCK_vGetpxBoosterParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetpxBoosterParameters_CallInstance);
  Mock.vGetpxBoosterParameters_CallInstance = CMock_Guts_MemNext(Mock.vGetpxBoosterParameters_CallInstance);
  if (Mock.vGetpxBoosterParameters_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetpxBoosterParameters_FinalReturn;
    Mock.vGetpxBoosterParameters_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetpxBoosterParameters_CallbackBool &&
      Mock.vGetpxBoosterParameters_CallbackFunctionPointer != NULL)
  {
    xBoosterParameters_t* cmock_cb_ret = Mock.vGetpxBoosterParameters_CallbackFunctionPointer(Mock.vGetpxBoosterParameters_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetpxBoosterParameters_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetpxBoosterParameters_CallbackFunctionPointer(Mock.vGetpxBoosterParameters_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetpxBoosterParameters_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xBoosterParameters_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetpxBoosterParameters_CALL_INSTANCE));
  CMOCK_vGetpxBoosterParameters_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetpxBoosterParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetpxBoosterParameters_CallInstance = CMock_Guts_MemChain(Mock.vGetpxBoosterParameters_CallInstance, cmock_guts_index);
  Mock.vGetpxBoosterParameters_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetpxBoosterParameters_IgnoreBool = (char)1;
}

void vGetpxBoosterParameters_CMockStopIgnore(void)
{
  if(Mock.vGetpxBoosterParameters_IgnoreBool)
    Mock.vGetpxBoosterParameters_CallInstance = CMock_Guts_MemNext(Mock.vGetpxBoosterParameters_CallInstance);
  Mock.vGetpxBoosterParameters_IgnoreBool = (char)0;
}

void vGetpxBoosterParameters_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xBoosterParameters_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetpxBoosterParameters_CALL_INSTANCE));
  CMOCK_vGetpxBoosterParameters_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetpxBoosterParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetpxBoosterParameters_CallInstance = CMock_Guts_MemChain(Mock.vGetpxBoosterParameters_CallInstance, cmock_guts_index);
  Mock.vGetpxBoosterParameters_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vGetpxBoosterParameters_AddCallback(CMOCK_vGetpxBoosterParameters_CALLBACK Callback)
{
  Mock.vGetpxBoosterParameters_IgnoreBool = (char)0;
  Mock.vGetpxBoosterParameters_CallbackBool = (char)1;
  Mock.vGetpxBoosterParameters_CallbackFunctionPointer = Callback;
}

void vGetpxBoosterParameters_Stub(CMOCK_vGetpxBoosterParameters_CALLBACK Callback)
{
  Mock.vGetpxBoosterParameters_IgnoreBool = (char)0;
  Mock.vGetpxBoosterParameters_CallbackBool = (char)0;
  Mock.vGetpxBoosterParameters_CallbackFunctionPointer = Callback;
}

void vLaserSetTemperatureInCan(handle_t xStream, float fTemperatureReaded)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserSetTemperatureInCan);
  cmock_call_instance = (CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserSetTemperatureInCan_CallInstance);
  Mock.vLaserSetTemperatureInCan_CallInstance = CMock_Guts_MemNext(Mock.vLaserSetTemperatureInCan_CallInstance);
  if (Mock.vLaserSetTemperatureInCan_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserSetTemperatureInCan_CallbackBool &&
      Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer(xStream, fTemperatureReaded, Mock.vLaserSetTemperatureInCan_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStream)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetTemperatureInCan,CMockString_xStream);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStream), (void*)(&xStream), sizeof(handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fTemperatureReaded)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetTemperatureInCan,CMockString_fTemperatureReaded);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fTemperatureReaded, fTemperatureReaded, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer(xStream, fTemperatureReaded, Mock.vLaserSetTemperatureInCan_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserSetTemperatureInCan(CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance, handle_t xStream, float fTemperatureReaded);
void CMockExpectParameters_vLaserSetTemperatureInCan(CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance, handle_t xStream, float fTemperatureReaded)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStream), (void*)(&xStream),
         sizeof(handle_t[sizeof(xStream) == sizeof(handle_t) ? 1 : -1])); /* add handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStream = 0;
  cmock_call_instance->Expected_fTemperatureReaded = fTemperatureReaded;
  cmock_call_instance->IgnoreArg_fTemperatureReaded = 0;
}

void vLaserSetTemperatureInCan_CMockIgnore(void)
{
  Mock.vLaserSetTemperatureInCan_IgnoreBool = (char)1;
}

void vLaserSetTemperatureInCan_CMockStopIgnore(void)
{
  Mock.vLaserSetTemperatureInCan_IgnoreBool = (char)0;
}

void vLaserSetTemperatureInCan_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE));
  CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserSetTemperatureInCan_CallInstance = CMock_Guts_MemChain(Mock.vLaserSetTemperatureInCan_CallInstance, cmock_guts_index);
  Mock.vLaserSetTemperatureInCan_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserSetTemperatureInCan_CMockExpect(UNITY_LINE_TYPE cmock_line, handle_t xStream, float fTemperatureReaded)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE));
  CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserSetTemperatureInCan_CallInstance = CMock_Guts_MemChain(Mock.vLaserSetTemperatureInCan_CallInstance, cmock_guts_index);
  Mock.vLaserSetTemperatureInCan_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserSetTemperatureInCan(cmock_call_instance, xStream, fTemperatureReaded);
}

void vLaserSetTemperatureInCan_AddCallback(CMOCK_vLaserSetTemperatureInCan_CALLBACK Callback)
{
  Mock.vLaserSetTemperatureInCan_IgnoreBool = (char)0;
  Mock.vLaserSetTemperatureInCan_CallbackBool = (char)1;
  Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer = Callback;
}

void vLaserSetTemperatureInCan_Stub(CMOCK_vLaserSetTemperatureInCan_CALLBACK Callback)
{
  Mock.vLaserSetTemperatureInCan_IgnoreBool = (char)0;
  Mock.vLaserSetTemperatureInCan_CallbackBool = (char)0;
  Mock.vLaserSetTemperatureInCan_CallbackFunctionPointer = Callback;
}

void vLaserSetTemperatureInCan_CMockIgnoreArg_xStream(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetTemperatureInCan_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStream = 1;
}

void vLaserSetTemperatureInCan_CMockIgnoreArg_fTemperatureReaded(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureInCan_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetTemperatureInCan_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fTemperatureReaded = 1;
}

eMpbError_t eLaserGetLimitTemperature(handle_t xStream, float* pfVeryHighLimit, float* pfVeryLowLimit, float* pfHighLimit)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eLaserGetLimitTemperature);
  cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eLaserGetLimitTemperature_CallInstance);
  Mock.eLaserGetLimitTemperature_CallInstance = CMock_Guts_MemNext(Mock.eLaserGetLimitTemperature_CallInstance);
  if (Mock.eLaserGetLimitTemperature_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.eLaserGetLimitTemperature_FinalReturn;
    memcpy((void*)(&Mock.eLaserGetLimitTemperature_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eMpbError_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eMpbError_t) ? 1 : -1])); /* add eMpbError_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.eLaserGetLimitTemperature_CallbackBool &&
      Mock.eLaserGetLimitTemperature_CallbackFunctionPointer != NULL)
  {
    eMpbError_t cmock_cb_ret = Mock.eLaserGetLimitTemperature_CallbackFunctionPointer(xStream, pfVeryHighLimit, pfVeryLowLimit, pfHighLimit, Mock.eLaserGetLimitTemperature_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStream)
  {
    UNITY_SET_DETAILS(CMockString_eLaserGetLimitTemperature,CMockString_xStream);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStream), (void*)(&xStream), sizeof(handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pfVeryHighLimit)
  {
    UNITY_SET_DETAILS(CMockString_eLaserGetLimitTemperature,CMockString_pfVeryHighLimit);
    if (cmock_call_instance->Expected_pfVeryHighLimit == NULL)
      { UNITY_TEST_ASSERT_NULL(pfVeryHighLimit, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfVeryHighLimit, pfVeryHighLimit, cmock_call_instance->Expected_pfVeryHighLimit_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pfVeryLowLimit)
  {
    UNITY_SET_DETAILS(CMockString_eLaserGetLimitTemperature,CMockString_pfVeryLowLimit);
    if (cmock_call_instance->Expected_pfVeryLowLimit == NULL)
      { UNITY_TEST_ASSERT_NULL(pfVeryLowLimit, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfVeryLowLimit, pfVeryLowLimit, cmock_call_instance->Expected_pfVeryLowLimit_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pfHighLimit)
  {
    UNITY_SET_DETAILS(CMockString_eLaserGetLimitTemperature,CMockString_pfHighLimit);
    if (cmock_call_instance->Expected_pfHighLimit == NULL)
      { UNITY_TEST_ASSERT_NULL(pfHighLimit, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfHighLimit, pfHighLimit, cmock_call_instance->Expected_pfHighLimit_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.eLaserGetLimitTemperature_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.eLaserGetLimitTemperature_CallbackFunctionPointer(xStream, pfVeryHighLimit, pfVeryLowLimit, pfHighLimit, Mock.eLaserGetLimitTemperature_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfVeryHighLimit, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfVeryHighLimit, (void*)cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Val,
      cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfVeryLowLimit, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfVeryLowLimit, (void*)cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Val,
      cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pfHighLimit_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfHighLimit, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfHighLimit, (void*)cmock_call_instance->ReturnThruPtr_pfHighLimit_Val,
      cmock_call_instance->ReturnThruPtr_pfHighLimit_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_eLaserGetLimitTemperature(CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance, handle_t xStream, float* pfVeryHighLimit, int pfVeryHighLimit_Depth, float* pfVeryLowLimit, int pfVeryLowLimit_Depth, float* pfHighLimit, int pfHighLimit_Depth);
void CMockExpectParameters_eLaserGetLimitTemperature(CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance, handle_t xStream, float* pfVeryHighLimit, int pfVeryHighLimit_Depth, float* pfVeryLowLimit, int pfVeryLowLimit_Depth, float* pfHighLimit, int pfHighLimit_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStream), (void*)(&xStream),
         sizeof(handle_t[sizeof(xStream) == sizeof(handle_t) ? 1 : -1])); /* add handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStream = 0;
  cmock_call_instance->Expected_pfVeryHighLimit = pfVeryHighLimit;
  cmock_call_instance->Expected_pfVeryHighLimit_Depth = pfVeryHighLimit_Depth;
  cmock_call_instance->IgnoreArg_pfVeryHighLimit = 0;
  cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Used = 0;
  cmock_call_instance->Expected_pfVeryLowLimit = pfVeryLowLimit;
  cmock_call_instance->Expected_pfVeryLowLimit_Depth = pfVeryLowLimit_Depth;
  cmock_call_instance->IgnoreArg_pfVeryLowLimit = 0;
  cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Used = 0;
  cmock_call_instance->Expected_pfHighLimit = pfHighLimit;
  cmock_call_instance->Expected_pfHighLimit_Depth = pfHighLimit_Depth;
  cmock_call_instance->IgnoreArg_pfHighLimit = 0;
  cmock_call_instance->ReturnThruPtr_pfHighLimit_Used = 0;
}

void eLaserGetLimitTemperature_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eMpbError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE));
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eLaserGetLimitTemperature_CallInstance = CMock_Guts_MemChain(Mock.eLaserGetLimitTemperature_CallInstance, cmock_guts_index);
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)1;
}

void eLaserGetLimitTemperature_CMockStopIgnore(void)
{
  if(Mock.eLaserGetLimitTemperature_IgnoreBool)
    Mock.eLaserGetLimitTemperature_CallInstance = CMock_Guts_MemNext(Mock.eLaserGetLimitTemperature_CallInstance);
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
}

void eLaserGetLimitTemperature_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, eMpbError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE));
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eLaserGetLimitTemperature_CallInstance = CMock_Guts_MemChain(Mock.eLaserGetLimitTemperature_CallInstance, cmock_guts_index);
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void eLaserGetLimitTemperature_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, handle_t xStream, float* pfVeryHighLimit, float* pfVeryLowLimit, float* pfHighLimit, eMpbError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE));
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eLaserGetLimitTemperature_CallInstance = CMock_Guts_MemChain(Mock.eLaserGetLimitTemperature_CallInstance, cmock_guts_index);
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eLaserGetLimitTemperature(cmock_call_instance, xStream, pfVeryHighLimit, 1, pfVeryLowLimit, 1, pfHighLimit, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eMpbError_t[sizeof(cmock_to_return) == sizeof(eMpbError_t) ? 1 : -1])); /* add eMpbError_t to :treat_as_array if this causes an error */
}

void eLaserGetLimitTemperature_AddCallback(CMOCK_eLaserGetLimitTemperature_CALLBACK Callback)
{
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
  Mock.eLaserGetLimitTemperature_CallbackBool = (char)1;
  Mock.eLaserGetLimitTemperature_CallbackFunctionPointer = Callback;
}

void eLaserGetLimitTemperature_Stub(CMOCK_eLaserGetLimitTemperature_CALLBACK Callback)
{
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
  Mock.eLaserGetLimitTemperature_CallbackBool = (char)0;
  Mock.eLaserGetLimitTemperature_CallbackFunctionPointer = Callback;
}

void eLaserGetLimitTemperature_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, handle_t xStream, float* pfVeryHighLimit, int pfVeryHighLimit_Depth, float* pfVeryLowLimit, int pfVeryLowLimit_Depth, float* pfHighLimit, int pfHighLimit_Depth, eMpbError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE));
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eLaserGetLimitTemperature_CallInstance = CMock_Guts_MemChain(Mock.eLaserGetLimitTemperature_CallInstance, cmock_guts_index);
  Mock.eLaserGetLimitTemperature_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eLaserGetLimitTemperature(cmock_call_instance, xStream, pfVeryHighLimit, pfVeryHighLimit_Depth, pfVeryLowLimit, pfVeryLowLimit_Depth, pfHighLimit, pfHighLimit_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void eLaserGetLimitTemperature_CMockReturnMemThruPtr_pfVeryHighLimit(UNITY_LINE_TYPE cmock_line, float* pfVeryHighLimit, size_t cmock_size)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Val = pfVeryHighLimit;
  cmock_call_instance->ReturnThruPtr_pfVeryHighLimit_Size = cmock_size;
}

void eLaserGetLimitTemperature_CMockReturnMemThruPtr_pfVeryLowLimit(UNITY_LINE_TYPE cmock_line, float* pfVeryLowLimit, size_t cmock_size)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Val = pfVeryLowLimit;
  cmock_call_instance->ReturnThruPtr_pfVeryLowLimit_Size = cmock_size;
}

void eLaserGetLimitTemperature_CMockReturnMemThruPtr_pfHighLimit(UNITY_LINE_TYPE cmock_line, float* pfHighLimit, size_t cmock_size)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfHighLimit_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfHighLimit_Val = pfHighLimit;
  cmock_call_instance->ReturnThruPtr_pfHighLimit_Size = cmock_size;
}

void eLaserGetLimitTemperature_CMockIgnoreArg_xStream(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStream = 1;
}

void eLaserGetLimitTemperature_CMockIgnoreArg_pfVeryHighLimit(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfVeryHighLimit = 1;
}

void eLaserGetLimitTemperature_CMockIgnoreArg_pfVeryLowLimit(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfVeryLowLimit = 1;
}

void eLaserGetLimitTemperature_CMockIgnoreArg_pfHighLimit(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_eLaserGetLimitTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eLaserGetLimitTemperature_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfHighLimit = 1;
}

void vLaserSetTemperatureFlagAlarm(handle_t xStream, eBool_t bVeryLowAlarm, eBool_t bVeryHighAlarm, eBool_t bHighAlarm)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserSetTemperatureFlagAlarm);
  cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserSetTemperatureFlagAlarm_CallInstance);
  Mock.vLaserSetTemperatureFlagAlarm_CallInstance = CMock_Guts_MemNext(Mock.vLaserSetTemperatureFlagAlarm_CallInstance);
  if (Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserSetTemperatureFlagAlarm_CallbackBool &&
      Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer(xStream, bVeryLowAlarm, bVeryHighAlarm, bHighAlarm, Mock.vLaserSetTemperatureFlagAlarm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStream)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetTemperatureFlagAlarm,CMockString_xStream);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStream), (void*)(&xStream), sizeof(handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_bVeryLowAlarm)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetTemperatureFlagAlarm,CMockString_bVeryLowAlarm);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bVeryLowAlarm), (void*)(&bVeryLowAlarm), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_bVeryHighAlarm)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetTemperatureFlagAlarm,CMockString_bVeryHighAlarm);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bVeryHighAlarm), (void*)(&bVeryHighAlarm), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_bHighAlarm)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetTemperatureFlagAlarm,CMockString_bHighAlarm);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bHighAlarm), (void*)(&bHighAlarm), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer(xStream, bVeryLowAlarm, bVeryHighAlarm, bHighAlarm, Mock.vLaserSetTemperatureFlagAlarm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserSetTemperatureFlagAlarm(CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance, handle_t xStream, eBool_t bVeryLowAlarm, eBool_t bVeryHighAlarm, eBool_t bHighAlarm);
void CMockExpectParameters_vLaserSetTemperatureFlagAlarm(CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance, handle_t xStream, eBool_t bVeryLowAlarm, eBool_t bVeryHighAlarm, eBool_t bHighAlarm)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStream), (void*)(&xStream),
         sizeof(handle_t[sizeof(xStream) == sizeof(handle_t) ? 1 : -1])); /* add handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStream = 0;
  memcpy((void*)(&cmock_call_instance->Expected_bVeryLowAlarm), (void*)(&bVeryLowAlarm),
         sizeof(eBool_t[sizeof(bVeryLowAlarm) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bVeryLowAlarm = 0;
  memcpy((void*)(&cmock_call_instance->Expected_bVeryHighAlarm), (void*)(&bVeryHighAlarm),
         sizeof(eBool_t[sizeof(bVeryHighAlarm) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bVeryHighAlarm = 0;
  memcpy((void*)(&cmock_call_instance->Expected_bHighAlarm), (void*)(&bHighAlarm),
         sizeof(eBool_t[sizeof(bHighAlarm) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bHighAlarm = 0;
}

void vLaserSetTemperatureFlagAlarm_CMockIgnore(void)
{
  Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool = (char)1;
}

void vLaserSetTemperatureFlagAlarm_CMockStopIgnore(void)
{
  Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool = (char)0;
}

void vLaserSetTemperatureFlagAlarm_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE));
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserSetTemperatureFlagAlarm_CallInstance = CMock_Guts_MemChain(Mock.vLaserSetTemperatureFlagAlarm_CallInstance, cmock_guts_index);
  Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserSetTemperatureFlagAlarm_CMockExpect(UNITY_LINE_TYPE cmock_line, handle_t xStream, eBool_t bVeryLowAlarm, eBool_t bVeryHighAlarm, eBool_t bHighAlarm)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE));
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserSetTemperatureFlagAlarm_CallInstance = CMock_Guts_MemChain(Mock.vLaserSetTemperatureFlagAlarm_CallInstance, cmock_guts_index);
  Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserSetTemperatureFlagAlarm(cmock_call_instance, xStream, bVeryLowAlarm, bVeryHighAlarm, bHighAlarm);
}

void vLaserSetTemperatureFlagAlarm_AddCallback(CMOCK_vLaserSetTemperatureFlagAlarm_CALLBACK Callback)
{
  Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool = (char)0;
  Mock.vLaserSetTemperatureFlagAlarm_CallbackBool = (char)1;
  Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer = Callback;
}

void vLaserSetTemperatureFlagAlarm_Stub(CMOCK_vLaserSetTemperatureFlagAlarm_CALLBACK Callback)
{
  Mock.vLaserSetTemperatureFlagAlarm_IgnoreBool = (char)0;
  Mock.vLaserSetTemperatureFlagAlarm_CallbackBool = (char)0;
  Mock.vLaserSetTemperatureFlagAlarm_CallbackFunctionPointer = Callback;
}

void vLaserSetTemperatureFlagAlarm_CMockIgnoreArg_xStream(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetTemperatureFlagAlarm_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStream = 1;
}

void vLaserSetTemperatureFlagAlarm_CMockIgnoreArg_bVeryLowAlarm(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetTemperatureFlagAlarm_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bVeryLowAlarm = 1;
}

void vLaserSetTemperatureFlagAlarm_CMockIgnoreArg_bVeryHighAlarm(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetTemperatureFlagAlarm_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bVeryHighAlarm = 1;
}

void vLaserSetTemperatureFlagAlarm_CMockIgnoreArg_bHighAlarm(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetTemperatureFlagAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetTemperatureFlagAlarm_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bHighAlarm = 1;
}

xCommonControlParameters_t* vGetpxCommonControlParameters(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetpxCommonControlParameters);
  cmock_call_instance = (CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetpxCommonControlParameters_CallInstance);
  Mock.vGetpxCommonControlParameters_CallInstance = CMock_Guts_MemNext(Mock.vGetpxCommonControlParameters_CallInstance);
  if (Mock.vGetpxCommonControlParameters_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetpxCommonControlParameters_FinalReturn;
    Mock.vGetpxCommonControlParameters_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetpxCommonControlParameters_CallbackBool &&
      Mock.vGetpxCommonControlParameters_CallbackFunctionPointer != NULL)
  {
    xCommonControlParameters_t* cmock_cb_ret = Mock.vGetpxCommonControlParameters_CallbackFunctionPointer(Mock.vGetpxCommonControlParameters_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetpxCommonControlParameters_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetpxCommonControlParameters_CallbackFunctionPointer(Mock.vGetpxCommonControlParameters_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetpxCommonControlParameters_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xCommonControlParameters_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE));
  CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetpxCommonControlParameters_CallInstance = CMock_Guts_MemChain(Mock.vGetpxCommonControlParameters_CallInstance, cmock_guts_index);
  Mock.vGetpxCommonControlParameters_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetpxCommonControlParameters_IgnoreBool = (char)1;
}

void vGetpxCommonControlParameters_CMockStopIgnore(void)
{
  if(Mock.vGetpxCommonControlParameters_IgnoreBool)
    Mock.vGetpxCommonControlParameters_CallInstance = CMock_Guts_MemNext(Mock.vGetpxCommonControlParameters_CallInstance);
  Mock.vGetpxCommonControlParameters_IgnoreBool = (char)0;
}

void vGetpxCommonControlParameters_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xCommonControlParameters_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE));
  CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetpxCommonControlParameters_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetpxCommonControlParameters_CallInstance = CMock_Guts_MemChain(Mock.vGetpxCommonControlParameters_CallInstance, cmock_guts_index);
  Mock.vGetpxCommonControlParameters_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vGetpxCommonControlParameters_AddCallback(CMOCK_vGetpxCommonControlParameters_CALLBACK Callback)
{
  Mock.vGetpxCommonControlParameters_IgnoreBool = (char)0;
  Mock.vGetpxCommonControlParameters_CallbackBool = (char)1;
  Mock.vGetpxCommonControlParameters_CallbackFunctionPointer = Callback;
}

void vGetpxCommonControlParameters_Stub(CMOCK_vGetpxCommonControlParameters_CALLBACK Callback)
{
  Mock.vGetpxCommonControlParameters_IgnoreBool = (char)0;
  Mock.vGetpxCommonControlParameters_CallbackBool = (char)0;
  Mock.vGetpxCommonControlParameters_CallbackFunctionPointer = Callback;
}

c402StatusDefinition_t* vGet402Message(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGet402Message_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGet402Message);
  cmock_call_instance = (CMOCK_vGet402Message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGet402Message_CallInstance);
  Mock.vGet402Message_CallInstance = CMock_Guts_MemNext(Mock.vGet402Message_CallInstance);
  if (Mock.vGet402Message_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGet402Message_FinalReturn;
    Mock.vGet402Message_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGet402Message_CallbackBool &&
      Mock.vGet402Message_CallbackFunctionPointer != NULL)
  {
    c402StatusDefinition_t* cmock_cb_ret = Mock.vGet402Message_CallbackFunctionPointer(Mock.vGet402Message_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGet402Message_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGet402Message_CallbackFunctionPointer(Mock.vGet402Message_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGet402Message_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGet402Message_CALL_INSTANCE));
  CMOCK_vGet402Message_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGet402Message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGet402Message_CallInstance = CMock_Guts_MemChain(Mock.vGet402Message_CallInstance, cmock_guts_index);
  Mock.vGet402Message_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGet402Message_IgnoreBool = (char)1;
}

void vGet402Message_CMockStopIgnore(void)
{
  if(Mock.vGet402Message_IgnoreBool)
    Mock.vGet402Message_CallInstance = CMock_Guts_MemNext(Mock.vGet402Message_CallInstance);
  Mock.vGet402Message_IgnoreBool = (char)0;
}

void vGet402Message_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGet402Message_CALL_INSTANCE));
  CMOCK_vGet402Message_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGet402Message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGet402Message_CallInstance = CMock_Guts_MemChain(Mock.vGet402Message_CallInstance, cmock_guts_index);
  Mock.vGet402Message_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vGet402Message_AddCallback(CMOCK_vGet402Message_CALLBACK Callback)
{
  Mock.vGet402Message_IgnoreBool = (char)0;
  Mock.vGet402Message_CallbackBool = (char)1;
  Mock.vGet402Message_CallbackFunctionPointer = Callback;
}

void vGet402Message_Stub(CMOCK_vGet402Message_CALLBACK Callback)
{
  Mock.vGet402Message_IgnoreBool = (char)0;
  Mock.vGet402Message_CallbackBool = (char)0;
  Mock.vGet402Message_CallbackFunctionPointer = Callback;
}

eBool_t bCanPort1IsSelected(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bCanPort1IsSelected_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bCanPort1IsSelected);
  cmock_call_instance = (CMOCK_bCanPort1IsSelected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bCanPort1IsSelected_CallInstance);
  Mock.bCanPort1IsSelected_CallInstance = CMock_Guts_MemNext(Mock.bCanPort1IsSelected_CallInstance);
  if (Mock.bCanPort1IsSelected_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bCanPort1IsSelected_FinalReturn;
    memcpy((void*)(&Mock.bCanPort1IsSelected_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bCanPort1IsSelected_CallbackBool &&
      Mock.bCanPort1IsSelected_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bCanPort1IsSelected_CallbackFunctionPointer(Mock.bCanPort1IsSelected_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.bCanPort1IsSelected_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bCanPort1IsSelected_CallbackFunctionPointer(Mock.bCanPort1IsSelected_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void bCanPort1IsSelected_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bCanPort1IsSelected_CALL_INSTANCE));
  CMOCK_bCanPort1IsSelected_CALL_INSTANCE* cmock_call_instance = (CMOCK_bCanPort1IsSelected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bCanPort1IsSelected_CallInstance = CMock_Guts_MemChain(Mock.bCanPort1IsSelected_CallInstance, cmock_guts_index);
  Mock.bCanPort1IsSelected_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bCanPort1IsSelected_IgnoreBool = (char)1;
}

void bCanPort1IsSelected_CMockStopIgnore(void)
{
  if(Mock.bCanPort1IsSelected_IgnoreBool)
    Mock.bCanPort1IsSelected_CallInstance = CMock_Guts_MemNext(Mock.bCanPort1IsSelected_CallInstance);
  Mock.bCanPort1IsSelected_IgnoreBool = (char)0;
}

void bCanPort1IsSelected_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bCanPort1IsSelected_CALL_INSTANCE));
  CMOCK_bCanPort1IsSelected_CALL_INSTANCE* cmock_call_instance = (CMOCK_bCanPort1IsSelected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bCanPort1IsSelected_CallInstance = CMock_Guts_MemChain(Mock.bCanPort1IsSelected_CallInstance, cmock_guts_index);
  Mock.bCanPort1IsSelected_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bCanPort1IsSelected_AddCallback(CMOCK_bCanPort1IsSelected_CALLBACK Callback)
{
  Mock.bCanPort1IsSelected_IgnoreBool = (char)0;
  Mock.bCanPort1IsSelected_CallbackBool = (char)1;
  Mock.bCanPort1IsSelected_CallbackFunctionPointer = Callback;
}

void bCanPort1IsSelected_Stub(CMOCK_bCanPort1IsSelected_CALLBACK Callback)
{
  Mock.bCanPort1IsSelected_IgnoreBool = (char)0;
  Mock.bCanPort1IsSelected_CallbackBool = (char)0;
  Mock.bCanPort1IsSelected_CallbackFunctionPointer = Callback;
}

void vSetCanPort1(eBool_t bSelectCan1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetCanPort1_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetCanPort1);
  cmock_call_instance = (CMOCK_vSetCanPort1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetCanPort1_CallInstance);
  Mock.vSetCanPort1_CallInstance = CMock_Guts_MemNext(Mock.vSetCanPort1_CallInstance);
  if (Mock.vSetCanPort1_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetCanPort1_CallbackBool &&
      Mock.vSetCanPort1_CallbackFunctionPointer != NULL)
  {
    Mock.vSetCanPort1_CallbackFunctionPointer(bSelectCan1, Mock.vSetCanPort1_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bSelectCan1)
  {
    UNITY_SET_DETAILS(CMockString_vSetCanPort1,CMockString_bSelectCan1);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bSelectCan1), (void*)(&bSelectCan1), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetCanPort1_CallbackFunctionPointer != NULL)
  {
    Mock.vSetCanPort1_CallbackFunctionPointer(bSelectCan1, Mock.vSetCanPort1_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetCanPort1(CMOCK_vSetCanPort1_CALL_INSTANCE* cmock_call_instance, eBool_t bSelectCan1);
void CMockExpectParameters_vSetCanPort1(CMOCK_vSetCanPort1_CALL_INSTANCE* cmock_call_instance, eBool_t bSelectCan1)
{
  memcpy((void*)(&cmock_call_instance->Expected_bSelectCan1), (void*)(&bSelectCan1),
         sizeof(eBool_t[sizeof(bSelectCan1) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bSelectCan1 = 0;
}

void vSetCanPort1_CMockIgnore(void)
{
  Mock.vSetCanPort1_IgnoreBool = (char)1;
}

void vSetCanPort1_CMockStopIgnore(void)
{
  Mock.vSetCanPort1_IgnoreBool = (char)0;
}

void vSetCanPort1_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetCanPort1_CALL_INSTANCE));
  CMOCK_vSetCanPort1_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetCanPort1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetCanPort1_CallInstance = CMock_Guts_MemChain(Mock.vSetCanPort1_CallInstance, cmock_guts_index);
  Mock.vSetCanPort1_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetCanPort1_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bSelectCan1)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetCanPort1_CALL_INSTANCE));
  CMOCK_vSetCanPort1_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetCanPort1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetCanPort1_CallInstance = CMock_Guts_MemChain(Mock.vSetCanPort1_CallInstance, cmock_guts_index);
  Mock.vSetCanPort1_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetCanPort1(cmock_call_instance, bSelectCan1);
}

void vSetCanPort1_AddCallback(CMOCK_vSetCanPort1_CALLBACK Callback)
{
  Mock.vSetCanPort1_IgnoreBool = (char)0;
  Mock.vSetCanPort1_CallbackBool = (char)1;
  Mock.vSetCanPort1_CallbackFunctionPointer = Callback;
}

void vSetCanPort1_Stub(CMOCK_vSetCanPort1_CALLBACK Callback)
{
  Mock.vSetCanPort1_IgnoreBool = (char)0;
  Mock.vSetCanPort1_CallbackBool = (char)0;
  Mock.vSetCanPort1_CallbackFunctionPointer = Callback;
}

void vSetCanPort1_CMockIgnoreArg_bSelectCan1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetCanPort1_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetCanPort1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetCanPort1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bSelectCan1 = 1;
}

void vGetSerialNumber(uint32_t* uSerialNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetSerialNumber);
  cmock_call_instance = (CMOCK_vGetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetSerialNumber_CallInstance);
  Mock.vGetSerialNumber_CallInstance = CMock_Guts_MemNext(Mock.vGetSerialNumber_CallInstance);
  if (Mock.vGetSerialNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vGetSerialNumber_CallbackBool &&
      Mock.vGetSerialNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vGetSerialNumber_CallbackFunctionPointer(uSerialNumber, Mock.vGetSerialNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uSerialNumber)
  {
    UNITY_SET_DETAILS(CMockString_vGetSerialNumber,CMockString_uSerialNumber);
    if (cmock_call_instance->Expected_uSerialNumber == NULL)
      { UNITY_TEST_ASSERT_NULL(uSerialNumber, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_uSerialNumber, uSerialNumber, cmock_call_instance->Expected_uSerialNumber_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vGetSerialNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vGetSerialNumber_CallbackFunctionPointer(uSerialNumber, Mock.vGetSerialNumber_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_uSerialNumber_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(uSerialNumber, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)uSerialNumber, (void*)cmock_call_instance->ReturnThruPtr_uSerialNumber_Val,
      cmock_call_instance->ReturnThruPtr_uSerialNumber_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vGetSerialNumber(CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance, uint32_t* uSerialNumber, int uSerialNumber_Depth);
void CMockExpectParameters_vGetSerialNumber(CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance, uint32_t* uSerialNumber, int uSerialNumber_Depth)
{
  cmock_call_instance->Expected_uSerialNumber = uSerialNumber;
  cmock_call_instance->Expected_uSerialNumber_Depth = uSerialNumber_Depth;
  cmock_call_instance->IgnoreArg_uSerialNumber = 0;
  cmock_call_instance->ReturnThruPtr_uSerialNumber_Used = 0;
}

void vGetSerialNumber_CMockIgnore(void)
{
  Mock.vGetSerialNumber_IgnoreBool = (char)1;
}

void vGetSerialNumber_CMockStopIgnore(void)
{
  Mock.vGetSerialNumber_IgnoreBool = (char)0;
}

void vGetSerialNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetSerialNumber_CALL_INSTANCE));
  CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetSerialNumber_CallInstance = CMock_Guts_MemChain(Mock.vGetSerialNumber_CallInstance, cmock_guts_index);
  Mock.vGetSerialNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vGetSerialNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t* uSerialNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetSerialNumber_CALL_INSTANCE));
  CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetSerialNumber_CallInstance = CMock_Guts_MemChain(Mock.vGetSerialNumber_CallInstance, cmock_guts_index);
  Mock.vGetSerialNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGetSerialNumber(cmock_call_instance, uSerialNumber, 1);
}

void vGetSerialNumber_AddCallback(CMOCK_vGetSerialNumber_CALLBACK Callback)
{
  Mock.vGetSerialNumber_IgnoreBool = (char)0;
  Mock.vGetSerialNumber_CallbackBool = (char)1;
  Mock.vGetSerialNumber_CallbackFunctionPointer = Callback;
}

void vGetSerialNumber_Stub(CMOCK_vGetSerialNumber_CALLBACK Callback)
{
  Mock.vGetSerialNumber_IgnoreBool = (char)0;
  Mock.vGetSerialNumber_CallbackBool = (char)0;
  Mock.vGetSerialNumber_CallbackFunctionPointer = Callback;
}

void vGetSerialNumber_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, uint32_t* uSerialNumber, int uSerialNumber_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetSerialNumber_CALL_INSTANCE));
  CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetSerialNumber_CallInstance = CMock_Guts_MemChain(Mock.vGetSerialNumber_CallInstance, cmock_guts_index);
  Mock.vGetSerialNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGetSerialNumber(cmock_call_instance, uSerialNumber, uSerialNumber_Depth);
}

void vGetSerialNumber_CMockReturnMemThruPtr_uSerialNumber(UNITY_LINE_TYPE cmock_line, uint32_t* uSerialNumber, size_t cmock_size)
{
  CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetSerialNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_uSerialNumber_Used = 1;
  cmock_call_instance->ReturnThruPtr_uSerialNumber_Val = uSerialNumber;
  cmock_call_instance->ReturnThruPtr_uSerialNumber_Size = cmock_size;
}

void vGetSerialNumber_CMockIgnoreArg_uSerialNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetSerialNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uSerialNumber = 1;
}

void vSetSerialNumber(uint32_t uSerialNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetSerialNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetSerialNumber);
  cmock_call_instance = (CMOCK_vSetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetSerialNumber_CallInstance);
  Mock.vSetSerialNumber_CallInstance = CMock_Guts_MemNext(Mock.vSetSerialNumber_CallInstance);
  if (Mock.vSetSerialNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetSerialNumber_CallbackBool &&
      Mock.vSetSerialNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vSetSerialNumber_CallbackFunctionPointer(uSerialNumber, Mock.vSetSerialNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uSerialNumber)
  {
    UNITY_SET_DETAILS(CMockString_vSetSerialNumber,CMockString_uSerialNumber);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_uSerialNumber, uSerialNumber, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetSerialNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vSetSerialNumber_CallbackFunctionPointer(uSerialNumber, Mock.vSetSerialNumber_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetSerialNumber(CMOCK_vSetSerialNumber_CALL_INSTANCE* cmock_call_instance, uint32_t uSerialNumber);
void CMockExpectParameters_vSetSerialNumber(CMOCK_vSetSerialNumber_CALL_INSTANCE* cmock_call_instance, uint32_t uSerialNumber)
{
  cmock_call_instance->Expected_uSerialNumber = uSerialNumber;
  cmock_call_instance->IgnoreArg_uSerialNumber = 0;
}

void vSetSerialNumber_CMockIgnore(void)
{
  Mock.vSetSerialNumber_IgnoreBool = (char)1;
}

void vSetSerialNumber_CMockStopIgnore(void)
{
  Mock.vSetSerialNumber_IgnoreBool = (char)0;
}

void vSetSerialNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetSerialNumber_CALL_INSTANCE));
  CMOCK_vSetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetSerialNumber_CallInstance = CMock_Guts_MemChain(Mock.vSetSerialNumber_CallInstance, cmock_guts_index);
  Mock.vSetSerialNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetSerialNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t uSerialNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetSerialNumber_CALL_INSTANCE));
  CMOCK_vSetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetSerialNumber_CallInstance = CMock_Guts_MemChain(Mock.vSetSerialNumber_CallInstance, cmock_guts_index);
  Mock.vSetSerialNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetSerialNumber(cmock_call_instance, uSerialNumber);
}

void vSetSerialNumber_AddCallback(CMOCK_vSetSerialNumber_CALLBACK Callback)
{
  Mock.vSetSerialNumber_IgnoreBool = (char)0;
  Mock.vSetSerialNumber_CallbackBool = (char)1;
  Mock.vSetSerialNumber_CallbackFunctionPointer = Callback;
}

void vSetSerialNumber_Stub(CMOCK_vSetSerialNumber_CALLBACK Callback)
{
  Mock.vSetSerialNumber_IgnoreBool = (char)0;
  Mock.vSetSerialNumber_CallbackBool = (char)0;
  Mock.vSetSerialNumber_CallbackFunctionPointer = Callback;
}

void vSetSerialNumber_CMockIgnoreArg_uSerialNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetSerialNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetSerialNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetSerialNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uSerialNumber = 1;
}

void vSetSendConfig(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetSendConfig_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetSendConfig);
  cmock_call_instance = (CMOCK_vSetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetSendConfig_CallInstance);
  Mock.vSetSendConfig_CallInstance = CMock_Guts_MemNext(Mock.vSetSendConfig_CallInstance);
  if (Mock.vSetSendConfig_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetSendConfig_CallbackBool &&
      Mock.vSetSendConfig_CallbackFunctionPointer != NULL)
  {
    Mock.vSetSendConfig_CallbackFunctionPointer(Mock.vSetSendConfig_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vSetSendConfig_CallbackFunctionPointer != NULL)
  {
    Mock.vSetSendConfig_CallbackFunctionPointer(Mock.vSetSendConfig_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vSetSendConfig_CMockIgnore(void)
{
  Mock.vSetSendConfig_IgnoreBool = (char)1;
}

void vSetSendConfig_CMockStopIgnore(void)
{
  Mock.vSetSendConfig_IgnoreBool = (char)0;
}

void vSetSendConfig_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetSendConfig_CALL_INSTANCE));
  CMOCK_vSetSendConfig_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetSendConfig_CallInstance = CMock_Guts_MemChain(Mock.vSetSendConfig_CallInstance, cmock_guts_index);
  Mock.vSetSendConfig_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vSetSendConfig_AddCallback(CMOCK_vSetSendConfig_CALLBACK Callback)
{
  Mock.vSetSendConfig_IgnoreBool = (char)0;
  Mock.vSetSendConfig_CallbackBool = (char)1;
  Mock.vSetSendConfig_CallbackFunctionPointer = Callback;
}

void vSetSendConfig_Stub(CMOCK_vSetSendConfig_CALLBACK Callback)
{
  Mock.vSetSendConfig_IgnoreBool = (char)0;
  Mock.vSetSendConfig_CallbackBool = (char)0;
  Mock.vSetSendConfig_CallbackFunctionPointer = Callback;
}

eBool_t bGetSendConfig(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bGetSendConfig_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bGetSendConfig);
  cmock_call_instance = (CMOCK_bGetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bGetSendConfig_CallInstance);
  Mock.bGetSendConfig_CallInstance = CMock_Guts_MemNext(Mock.bGetSendConfig_CallInstance);
  if (Mock.bGetSendConfig_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bGetSendConfig_FinalReturn;
    memcpy((void*)(&Mock.bGetSendConfig_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bGetSendConfig_CallbackBool &&
      Mock.bGetSendConfig_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bGetSendConfig_CallbackFunctionPointer(Mock.bGetSendConfig_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.bGetSendConfig_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bGetSendConfig_CallbackFunctionPointer(Mock.bGetSendConfig_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void bGetSendConfig_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bGetSendConfig_CALL_INSTANCE));
  CMOCK_bGetSendConfig_CALL_INSTANCE* cmock_call_instance = (CMOCK_bGetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bGetSendConfig_CallInstance = CMock_Guts_MemChain(Mock.bGetSendConfig_CallInstance, cmock_guts_index);
  Mock.bGetSendConfig_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bGetSendConfig_IgnoreBool = (char)1;
}

void bGetSendConfig_CMockStopIgnore(void)
{
  if(Mock.bGetSendConfig_IgnoreBool)
    Mock.bGetSendConfig_CallInstance = CMock_Guts_MemNext(Mock.bGetSendConfig_CallInstance);
  Mock.bGetSendConfig_IgnoreBool = (char)0;
}

void bGetSendConfig_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bGetSendConfig_CALL_INSTANCE));
  CMOCK_bGetSendConfig_CALL_INSTANCE* cmock_call_instance = (CMOCK_bGetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bGetSendConfig_CallInstance = CMock_Guts_MemChain(Mock.bGetSendConfig_CallInstance, cmock_guts_index);
  Mock.bGetSendConfig_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bGetSendConfig_AddCallback(CMOCK_bGetSendConfig_CALLBACK Callback)
{
  Mock.bGetSendConfig_IgnoreBool = (char)0;
  Mock.bGetSendConfig_CallbackBool = (char)1;
  Mock.bGetSendConfig_CallbackFunctionPointer = Callback;
}

void bGetSendConfig_Stub(CMOCK_bGetSendConfig_CALLBACK Callback)
{
  Mock.bGetSendConfig_IgnoreBool = (char)0;
  Mock.bGetSendConfig_CallbackBool = (char)0;
  Mock.bGetSendConfig_CallbackFunctionPointer = Callback;
}

void vResetSendConfig(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vResetSendConfig_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vResetSendConfig);
  cmock_call_instance = (CMOCK_vResetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vResetSendConfig_CallInstance);
  Mock.vResetSendConfig_CallInstance = CMock_Guts_MemNext(Mock.vResetSendConfig_CallInstance);
  if (Mock.vResetSendConfig_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vResetSendConfig_CallbackBool &&
      Mock.vResetSendConfig_CallbackFunctionPointer != NULL)
  {
    Mock.vResetSendConfig_CallbackFunctionPointer(Mock.vResetSendConfig_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vResetSendConfig_CallbackFunctionPointer != NULL)
  {
    Mock.vResetSendConfig_CallbackFunctionPointer(Mock.vResetSendConfig_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vResetSendConfig_CMockIgnore(void)
{
  Mock.vResetSendConfig_IgnoreBool = (char)1;
}

void vResetSendConfig_CMockStopIgnore(void)
{
  Mock.vResetSendConfig_IgnoreBool = (char)0;
}

void vResetSendConfig_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vResetSendConfig_CALL_INSTANCE));
  CMOCK_vResetSendConfig_CALL_INSTANCE* cmock_call_instance = (CMOCK_vResetSendConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vResetSendConfig_CallInstance = CMock_Guts_MemChain(Mock.vResetSendConfig_CallInstance, cmock_guts_index);
  Mock.vResetSendConfig_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vResetSendConfig_AddCallback(CMOCK_vResetSendConfig_CALLBACK Callback)
{
  Mock.vResetSendConfig_IgnoreBool = (char)0;
  Mock.vResetSendConfig_CallbackBool = (char)1;
  Mock.vResetSendConfig_CallbackFunctionPointer = Callback;
}

void vResetSendConfig_Stub(CMOCK_vResetSendConfig_CALLBACK Callback)
{
  Mock.vResetSendConfig_IgnoreBool = (char)0;
  Mock.vResetSendConfig_CallbackBool = (char)0;
  Mock.vResetSendConfig_CallbackFunctionPointer = Callback;
}

void vGetCompanyId(uint8_t* ucCompanyId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetCompanyId);
  cmock_call_instance = (CMOCK_vGetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetCompanyId_CallInstance);
  Mock.vGetCompanyId_CallInstance = CMock_Guts_MemNext(Mock.vGetCompanyId_CallInstance);
  if (Mock.vGetCompanyId_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vGetCompanyId_CallbackBool &&
      Mock.vGetCompanyId_CallbackFunctionPointer != NULL)
  {
    Mock.vGetCompanyId_CallbackFunctionPointer(ucCompanyId, Mock.vGetCompanyId_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ucCompanyId)
  {
    UNITY_SET_DETAILS(CMockString_vGetCompanyId,CMockString_ucCompanyId);
    if (cmock_call_instance->Expected_ucCompanyId == NULL)
      { UNITY_TEST_ASSERT_NULL(ucCompanyId, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ucCompanyId, ucCompanyId, cmock_call_instance->Expected_ucCompanyId_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vGetCompanyId_CallbackFunctionPointer != NULL)
  {
    Mock.vGetCompanyId_CallbackFunctionPointer(ucCompanyId, Mock.vGetCompanyId_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_ucCompanyId_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ucCompanyId, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ucCompanyId, (void*)cmock_call_instance->ReturnThruPtr_ucCompanyId_Val,
      cmock_call_instance->ReturnThruPtr_ucCompanyId_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vGetCompanyId(CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance, uint8_t* ucCompanyId, int ucCompanyId_Depth);
void CMockExpectParameters_vGetCompanyId(CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance, uint8_t* ucCompanyId, int ucCompanyId_Depth)
{
  cmock_call_instance->Expected_ucCompanyId = ucCompanyId;
  cmock_call_instance->Expected_ucCompanyId_Depth = ucCompanyId_Depth;
  cmock_call_instance->IgnoreArg_ucCompanyId = 0;
  cmock_call_instance->ReturnThruPtr_ucCompanyId_Used = 0;
}

void vGetCompanyId_CMockIgnore(void)
{
  Mock.vGetCompanyId_IgnoreBool = (char)1;
}

void vGetCompanyId_CMockStopIgnore(void)
{
  Mock.vGetCompanyId_IgnoreBool = (char)0;
}

void vGetCompanyId_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetCompanyId_CALL_INSTANCE));
  CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetCompanyId_CallInstance = CMock_Guts_MemChain(Mock.vGetCompanyId_CallInstance, cmock_guts_index);
  Mock.vGetCompanyId_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vGetCompanyId_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t* ucCompanyId)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetCompanyId_CALL_INSTANCE));
  CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetCompanyId_CallInstance = CMock_Guts_MemChain(Mock.vGetCompanyId_CallInstance, cmock_guts_index);
  Mock.vGetCompanyId_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGetCompanyId(cmock_call_instance, ucCompanyId, 1);
}

void vGetCompanyId_AddCallback(CMOCK_vGetCompanyId_CALLBACK Callback)
{
  Mock.vGetCompanyId_IgnoreBool = (char)0;
  Mock.vGetCompanyId_CallbackBool = (char)1;
  Mock.vGetCompanyId_CallbackFunctionPointer = Callback;
}

void vGetCompanyId_Stub(CMOCK_vGetCompanyId_CALLBACK Callback)
{
  Mock.vGetCompanyId_IgnoreBool = (char)0;
  Mock.vGetCompanyId_CallbackBool = (char)0;
  Mock.vGetCompanyId_CallbackFunctionPointer = Callback;
}

void vGetCompanyId_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, uint8_t* ucCompanyId, int ucCompanyId_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetCompanyId_CALL_INSTANCE));
  CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetCompanyId_CallInstance = CMock_Guts_MemChain(Mock.vGetCompanyId_CallInstance, cmock_guts_index);
  Mock.vGetCompanyId_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGetCompanyId(cmock_call_instance, ucCompanyId, ucCompanyId_Depth);
}

void vGetCompanyId_CMockReturnMemThruPtr_ucCompanyId(UNITY_LINE_TYPE cmock_line, uint8_t* ucCompanyId, size_t cmock_size)
{
  CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetCompanyId_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ucCompanyId_Used = 1;
  cmock_call_instance->ReturnThruPtr_ucCompanyId_Val = ucCompanyId;
  cmock_call_instance->ReturnThruPtr_ucCompanyId_Size = cmock_size;
}

void vGetCompanyId_CMockIgnoreArg_ucCompanyId(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetCompanyId_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ucCompanyId = 1;
}

void vSetCompanyId(uint8_t ucCompanyId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetCompanyId_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetCompanyId);
  cmock_call_instance = (CMOCK_vSetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetCompanyId_CallInstance);
  Mock.vSetCompanyId_CallInstance = CMock_Guts_MemNext(Mock.vSetCompanyId_CallInstance);
  if (Mock.vSetCompanyId_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetCompanyId_CallbackBool &&
      Mock.vSetCompanyId_CallbackFunctionPointer != NULL)
  {
    Mock.vSetCompanyId_CallbackFunctionPointer(ucCompanyId, Mock.vSetCompanyId_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ucCompanyId)
  {
    UNITY_SET_DETAILS(CMockString_vSetCompanyId,CMockString_ucCompanyId);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucCompanyId, ucCompanyId, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetCompanyId_CallbackFunctionPointer != NULL)
  {
    Mock.vSetCompanyId_CallbackFunctionPointer(ucCompanyId, Mock.vSetCompanyId_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetCompanyId(CMOCK_vSetCompanyId_CALL_INSTANCE* cmock_call_instance, uint8_t ucCompanyId);
void CMockExpectParameters_vSetCompanyId(CMOCK_vSetCompanyId_CALL_INSTANCE* cmock_call_instance, uint8_t ucCompanyId)
{
  cmock_call_instance->Expected_ucCompanyId = ucCompanyId;
  cmock_call_instance->IgnoreArg_ucCompanyId = 0;
}

void vSetCompanyId_CMockIgnore(void)
{
  Mock.vSetCompanyId_IgnoreBool = (char)1;
}

void vSetCompanyId_CMockStopIgnore(void)
{
  Mock.vSetCompanyId_IgnoreBool = (char)0;
}

void vSetCompanyId_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetCompanyId_CALL_INSTANCE));
  CMOCK_vSetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetCompanyId_CallInstance = CMock_Guts_MemChain(Mock.vSetCompanyId_CallInstance, cmock_guts_index);
  Mock.vSetCompanyId_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetCompanyId_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t ucCompanyId)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetCompanyId_CALL_INSTANCE));
  CMOCK_vSetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetCompanyId_CallInstance = CMock_Guts_MemChain(Mock.vSetCompanyId_CallInstance, cmock_guts_index);
  Mock.vSetCompanyId_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetCompanyId(cmock_call_instance, ucCompanyId);
}

void vSetCompanyId_AddCallback(CMOCK_vSetCompanyId_CALLBACK Callback)
{
  Mock.vSetCompanyId_IgnoreBool = (char)0;
  Mock.vSetCompanyId_CallbackBool = (char)1;
  Mock.vSetCompanyId_CallbackFunctionPointer = Callback;
}

void vSetCompanyId_Stub(CMOCK_vSetCompanyId_CALLBACK Callback)
{
  Mock.vSetCompanyId_IgnoreBool = (char)0;
  Mock.vSetCompanyId_CallbackBool = (char)0;
  Mock.vSetCompanyId_CallbackFunctionPointer = Callback;
}

void vSetCompanyId_CMockIgnoreArg_ucCompanyId(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetCompanyId_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetCompanyId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetCompanyId_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ucCompanyId = 1;
}

void vLaserDataGetCan401Info(c401StatusDefinition_t* c401Status1Definition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan401Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan401Info_CallInstance);
  Mock.vLaserDataGetCan401Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan401Info_CallInstance);
  if (Mock.vLaserDataGetCan401Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan401Info_CallbackBool &&
      Mock.vLaserDataGetCan401Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan401Info_CallbackFunctionPointer(c401Status1Definition, Mock.vLaserDataGetCan401Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c401Status1Definition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan401Info,CMockString_c401Status1Definition);
    if (cmock_call_instance->Expected_c401Status1Definition == NULL)
      { UNITY_TEST_ASSERT_NULL(c401Status1Definition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c401Status1Definition), (void*)(c401Status1Definition), sizeof(c401StatusDefinition_t), cmock_call_instance->Expected_c401Status1Definition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan401Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan401Info_CallbackFunctionPointer(c401Status1Definition, Mock.vLaserDataGetCan401Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c401Status1Definition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c401Status1Definition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c401Status1Definition, (void*)cmock_call_instance->ReturnThruPtr_c401Status1Definition_Val,
      cmock_call_instance->ReturnThruPtr_c401Status1Definition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan401Info(CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance, c401StatusDefinition_t* c401Status1Definition, int c401Status1Definition_Depth);
void CMockExpectParameters_vLaserDataGetCan401Info(CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance, c401StatusDefinition_t* c401Status1Definition, int c401Status1Definition_Depth)
{
  cmock_call_instance->Expected_c401Status1Definition = c401Status1Definition;
  cmock_call_instance->Expected_c401Status1Definition_Depth = c401Status1Definition_Depth;
  cmock_call_instance->IgnoreArg_c401Status1Definition = 0;
  cmock_call_instance->ReturnThruPtr_c401Status1Definition_Used = 0;
}

void vLaserDataGetCan401Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan401Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan401Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan401Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan401Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan401Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c401StatusDefinition_t* c401Status1Definition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan401Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan401Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan401Info(cmock_call_instance, c401Status1Definition, 1);
}

void vLaserDataGetCan401Info_AddCallback(CMOCK_vLaserDataGetCan401Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan401Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan401Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan401Info_Stub(CMOCK_vLaserDataGetCan401Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan401Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan401Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan401Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c401StatusDefinition_t* c401Status1Definition, int c401Status1Definition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan401Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan401Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan401Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan401Info(cmock_call_instance, c401Status1Definition, c401Status1Definition_Depth);
}

void vLaserDataGetCan401Info_CMockReturnMemThruPtr_c401Status1Definition(UNITY_LINE_TYPE cmock_line, c401StatusDefinition_t* c401Status1Definition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan401Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c401Status1Definition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c401Status1Definition_Val = c401Status1Definition;
  cmock_call_instance->ReturnThruPtr_c401Status1Definition_Size = cmock_size;
}

void vLaserDataGetCan401Info_CMockIgnoreArg_c401Status1Definition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan401Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan401Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c401Status1Definition = 1;
}

c414StatusDefinition_t* pLaserDataGetCan414Info(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pLaserDataGetCan414Info);
  cmock_call_instance = (CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pLaserDataGetCan414Info_CallInstance);
  Mock.pLaserDataGetCan414Info_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan414Info_CallInstance);
  if (Mock.pLaserDataGetCan414Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pLaserDataGetCan414Info_FinalReturn;
    Mock.pLaserDataGetCan414Info_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pLaserDataGetCan414Info_CallbackBool &&
      Mock.pLaserDataGetCan414Info_CallbackFunctionPointer != NULL)
  {
    c414StatusDefinition_t* cmock_cb_ret = Mock.pLaserDataGetCan414Info_CallbackFunctionPointer(Mock.pLaserDataGetCan414Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.pLaserDataGetCan414Info_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pLaserDataGetCan414Info_CallbackFunctionPointer(Mock.pLaserDataGetCan414Info_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pLaserDataGetCan414Info_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c414StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan414Info_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan414Info_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan414Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pLaserDataGetCan414Info_IgnoreBool = (char)1;
}

void pLaserDataGetCan414Info_CMockStopIgnore(void)
{
  if(Mock.pLaserDataGetCan414Info_IgnoreBool)
    Mock.pLaserDataGetCan414Info_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan414Info_CallInstance);
  Mock.pLaserDataGetCan414Info_IgnoreBool = (char)0;
}

void pLaserDataGetCan414Info_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c414StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan414Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan414Info_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan414Info_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan414Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pLaserDataGetCan414Info_AddCallback(CMOCK_pLaserDataGetCan414Info_CALLBACK Callback)
{
  Mock.pLaserDataGetCan414Info_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan414Info_CallbackBool = (char)1;
  Mock.pLaserDataGetCan414Info_CallbackFunctionPointer = Callback;
}

void pLaserDataGetCan414Info_Stub(CMOCK_pLaserDataGetCan414Info_CALLBACK Callback)
{
  Mock.pLaserDataGetCan414Info_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan414Info_CallbackBool = (char)0;
  Mock.pLaserDataGetCan414Info_CallbackFunctionPointer = Callback;
}

c415StatusDefinition_t* pLaserDataGetCan415Info(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pLaserDataGetCan415Info);
  cmock_call_instance = (CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pLaserDataGetCan415Info_CallInstance);
  Mock.pLaserDataGetCan415Info_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan415Info_CallInstance);
  if (Mock.pLaserDataGetCan415Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pLaserDataGetCan415Info_FinalReturn;
    Mock.pLaserDataGetCan415Info_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pLaserDataGetCan415Info_CallbackBool &&
      Mock.pLaserDataGetCan415Info_CallbackFunctionPointer != NULL)
  {
    c415StatusDefinition_t* cmock_cb_ret = Mock.pLaserDataGetCan415Info_CallbackFunctionPointer(Mock.pLaserDataGetCan415Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.pLaserDataGetCan415Info_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pLaserDataGetCan415Info_CallbackFunctionPointer(Mock.pLaserDataGetCan415Info_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pLaserDataGetCan415Info_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c415StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan415Info_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan415Info_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan415Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pLaserDataGetCan415Info_IgnoreBool = (char)1;
}

void pLaserDataGetCan415Info_CMockStopIgnore(void)
{
  if(Mock.pLaserDataGetCan415Info_IgnoreBool)
    Mock.pLaserDataGetCan415Info_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan415Info_CallInstance);
  Mock.pLaserDataGetCan415Info_IgnoreBool = (char)0;
}

void pLaserDataGetCan415Info_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c415StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan415Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan415Info_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan415Info_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan415Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pLaserDataGetCan415Info_AddCallback(CMOCK_pLaserDataGetCan415Info_CALLBACK Callback)
{
  Mock.pLaserDataGetCan415Info_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan415Info_CallbackBool = (char)1;
  Mock.pLaserDataGetCan415Info_CallbackFunctionPointer = Callback;
}

void pLaserDataGetCan415Info_Stub(CMOCK_pLaserDataGetCan415Info_CALLBACK Callback)
{
  Mock.pLaserDataGetCan415Info_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan415Info_CallbackBool = (char)0;
  Mock.pLaserDataGetCan415Info_CallbackFunctionPointer = Callback;
}

c402StatusDefinition_t* vLaserDataGetData402(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData402_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData402);
  cmock_call_instance = (CMOCK_vLaserDataGetData402_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData402_CallInstance);
  Mock.vLaserDataGetData402_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData402_CallInstance);
  if (Mock.vLaserDataGetData402_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData402_FinalReturn;
    Mock.vLaserDataGetData402_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData402_CallbackBool &&
      Mock.vLaserDataGetData402_CallbackFunctionPointer != NULL)
  {
    c402StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData402_CallbackFunctionPointer(Mock.vLaserDataGetData402_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData402_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData402_CallbackFunctionPointer(Mock.vLaserDataGetData402_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData402_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData402_CALL_INSTANCE));
  CMOCK_vLaserDataGetData402_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData402_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData402_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData402_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData402_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData402_IgnoreBool = (char)1;
}

void vLaserDataGetData402_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData402_IgnoreBool)
    Mock.vLaserDataGetData402_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData402_CallInstance);
  Mock.vLaserDataGetData402_IgnoreBool = (char)0;
}

void vLaserDataGetData402_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData402_CALL_INSTANCE));
  CMOCK_vLaserDataGetData402_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData402_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData402_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData402_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData402_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData402_AddCallback(CMOCK_vLaserDataGetData402_CALLBACK Callback)
{
  Mock.vLaserDataGetData402_IgnoreBool = (char)0;
  Mock.vLaserDataGetData402_CallbackBool = (char)1;
  Mock.vLaserDataGetData402_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData402_Stub(CMOCK_vLaserDataGetData402_CALLBACK Callback)
{
  Mock.vLaserDataGetData402_IgnoreBool = (char)0;
  Mock.vLaserDataGetData402_CallbackBool = (char)0;
  Mock.vLaserDataGetData402_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan402Info(c402StatusDefinition_t* c402StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan402Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan402Info_CallInstance);
  Mock.vLaserDataGetCan402Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan402Info_CallInstance);
  if (Mock.vLaserDataGetCan402Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan402Info_CallbackBool &&
      Mock.vLaserDataGetCan402Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan402Info_CallbackFunctionPointer(c402StatusDefinition, Mock.vLaserDataGetCan402Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c402StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan402Info,CMockString_c402StatusDefinition);
    if (cmock_call_instance->Expected_c402StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c402StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c402StatusDefinition), (void*)(c402StatusDefinition), sizeof(c402StatusDefinition_t), cmock_call_instance->Expected_c402StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan402Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan402Info_CallbackFunctionPointer(c402StatusDefinition, Mock.vLaserDataGetCan402Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c402StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c402StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan402Info(CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance, c402StatusDefinition_t* c402StatusDefinition, int c402StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan402Info(CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance, c402StatusDefinition_t* c402StatusDefinition, int c402StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c402StatusDefinition = c402StatusDefinition;
  cmock_call_instance->Expected_c402StatusDefinition_Depth = c402StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c402StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Used = 0;
}

void vLaserDataGetCan402Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan402Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan402Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan402Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan402Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan402Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* c402StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan402Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan402Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan402Info(cmock_call_instance, c402StatusDefinition, 1);
}

void vLaserDataGetCan402Info_AddCallback(CMOCK_vLaserDataGetCan402Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan402Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan402Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan402Info_Stub(CMOCK_vLaserDataGetCan402Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan402Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan402Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan402Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* c402StatusDefinition, int c402StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan402Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan402Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan402Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan402Info(cmock_call_instance, c402StatusDefinition, c402StatusDefinition_Depth);
}

void vLaserDataGetCan402Info_CMockReturnMemThruPtr_c402StatusDefinition(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* c402StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan402Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Val = c402StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c402StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan402Info_CMockIgnoreArg_c402StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan402Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan402Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c402StatusDefinition = 1;
}

c402StatusDefinition_t* pLaserDataGetCan402Pointer(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pLaserDataGetCan402Pointer);
  cmock_call_instance = (CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pLaserDataGetCan402Pointer_CallInstance);
  Mock.pLaserDataGetCan402Pointer_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan402Pointer_CallInstance);
  if (Mock.pLaserDataGetCan402Pointer_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pLaserDataGetCan402Pointer_FinalReturn;
    Mock.pLaserDataGetCan402Pointer_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pLaserDataGetCan402Pointer_CallbackBool &&
      Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer != NULL)
  {
    c402StatusDefinition_t* cmock_cb_ret = Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer(Mock.pLaserDataGetCan402Pointer_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer(Mock.pLaserDataGetCan402Pointer_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pLaserDataGetCan402Pointer_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan402Pointer_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan402Pointer_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan402Pointer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pLaserDataGetCan402Pointer_IgnoreBool = (char)1;
}

void pLaserDataGetCan402Pointer_CMockStopIgnore(void)
{
  if(Mock.pLaserDataGetCan402Pointer_IgnoreBool)
    Mock.pLaserDataGetCan402Pointer_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan402Pointer_CallInstance);
  Mock.pLaserDataGetCan402Pointer_IgnoreBool = (char)0;
}

void pLaserDataGetCan402Pointer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c402StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan402Pointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan402Pointer_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan402Pointer_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan402Pointer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pLaserDataGetCan402Pointer_AddCallback(CMOCK_pLaserDataGetCan402Pointer_CALLBACK Callback)
{
  Mock.pLaserDataGetCan402Pointer_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan402Pointer_CallbackBool = (char)1;
  Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer = Callback;
}

void pLaserDataGetCan402Pointer_Stub(CMOCK_pLaserDataGetCan402Pointer_CALLBACK Callback)
{
  Mock.pLaserDataGetCan402Pointer_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan402Pointer_CallbackBool = (char)0;
  Mock.pLaserDataGetCan402Pointer_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan403Info(c403StatusDefinition_t* c403StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan403Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan403Info_CallInstance);
  Mock.vLaserDataGetCan403Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan403Info_CallInstance);
  if (Mock.vLaserDataGetCan403Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan403Info_CallbackBool &&
      Mock.vLaserDataGetCan403Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan403Info_CallbackFunctionPointer(c403StatusDefinition, Mock.vLaserDataGetCan403Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c403StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan403Info,CMockString_c403StatusDefinition);
    if (cmock_call_instance->Expected_c403StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c403StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c403StatusDefinition), (void*)(c403StatusDefinition), sizeof(c403StatusDefinition_t), cmock_call_instance->Expected_c403StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan403Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan403Info_CallbackFunctionPointer(c403StatusDefinition, Mock.vLaserDataGetCan403Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c403StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c403StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan403Info(CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance, c403StatusDefinition_t* c403StatusDefinition, int c403StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan403Info(CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance, c403StatusDefinition_t* c403StatusDefinition, int c403StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c403StatusDefinition = c403StatusDefinition;
  cmock_call_instance->Expected_c403StatusDefinition_Depth = c403StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c403StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Used = 0;
}

void vLaserDataGetCan403Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan403Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan403Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan403Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan403Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan403Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c403StatusDefinition_t* c403StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan403Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan403Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan403Info(cmock_call_instance, c403StatusDefinition, 1);
}

void vLaserDataGetCan403Info_AddCallback(CMOCK_vLaserDataGetCan403Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan403Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan403Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan403Info_Stub(CMOCK_vLaserDataGetCan403Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan403Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan403Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan403Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c403StatusDefinition_t* c403StatusDefinition, int c403StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan403Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan403Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan403Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan403Info(cmock_call_instance, c403StatusDefinition, c403StatusDefinition_Depth);
}

void vLaserDataGetCan403Info_CMockReturnMemThruPtr_c403StatusDefinition(UNITY_LINE_TYPE cmock_line, c403StatusDefinition_t* c403StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan403Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Val = c403StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c403StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan403Info_CMockIgnoreArg_c403StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan403Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan403Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c403StatusDefinition = 1;
}

void vLaserDataGetCan404Info(c404StatusDefinition_t* c404StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan404Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan404Info_CallInstance);
  Mock.vLaserDataGetCan404Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan404Info_CallInstance);
  if (Mock.vLaserDataGetCan404Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan404Info_CallbackBool &&
      Mock.vLaserDataGetCan404Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan404Info_CallbackFunctionPointer(c404StatusDefinition, Mock.vLaserDataGetCan404Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c404StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan404Info,CMockString_c404StatusDefinition);
    if (cmock_call_instance->Expected_c404StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c404StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c404StatusDefinition), (void*)(c404StatusDefinition), sizeof(c404StatusDefinition_t), cmock_call_instance->Expected_c404StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan404Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan404Info_CallbackFunctionPointer(c404StatusDefinition, Mock.vLaserDataGetCan404Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c404StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c404StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan404Info(CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance, c404StatusDefinition_t* c404StatusDefinition, int c404StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan404Info(CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance, c404StatusDefinition_t* c404StatusDefinition, int c404StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c404StatusDefinition = c404StatusDefinition;
  cmock_call_instance->Expected_c404StatusDefinition_Depth = c404StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c404StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Used = 0;
}

void vLaserDataGetCan404Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan404Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan404Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan404Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan404Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan404Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c404StatusDefinition_t* c404StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan404Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan404Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan404Info(cmock_call_instance, c404StatusDefinition, 1);
}

void vLaserDataGetCan404Info_AddCallback(CMOCK_vLaserDataGetCan404Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan404Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan404Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan404Info_Stub(CMOCK_vLaserDataGetCan404Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan404Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan404Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan404Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c404StatusDefinition_t* c404StatusDefinition, int c404StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan404Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan404Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan404Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan404Info(cmock_call_instance, c404StatusDefinition, c404StatusDefinition_Depth);
}

void vLaserDataGetCan404Info_CMockReturnMemThruPtr_c404StatusDefinition(UNITY_LINE_TYPE cmock_line, c404StatusDefinition_t* c404StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan404Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Val = c404StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c404StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan404Info_CMockIgnoreArg_c404StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan404Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan404Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c404StatusDefinition = 1;
}

void vLaserDataGetCan405Info(c405Definition_t* c405Definition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan405Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan405Info_CallInstance);
  Mock.vLaserDataGetCan405Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan405Info_CallInstance);
  if (Mock.vLaserDataGetCan405Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan405Info_CallbackBool &&
      Mock.vLaserDataGetCan405Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan405Info_CallbackFunctionPointer(c405Definition, Mock.vLaserDataGetCan405Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c405Definition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan405Info,CMockString_c405Definition);
    if (cmock_call_instance->Expected_c405Definition == NULL)
      { UNITY_TEST_ASSERT_NULL(c405Definition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c405Definition), (void*)(c405Definition), sizeof(c405Definition_t), cmock_call_instance->Expected_c405Definition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan405Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan405Info_CallbackFunctionPointer(c405Definition, Mock.vLaserDataGetCan405Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c405Definition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c405Definition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c405Definition, (void*)cmock_call_instance->ReturnThruPtr_c405Definition_Val,
      cmock_call_instance->ReturnThruPtr_c405Definition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan405Info(CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance, c405Definition_t* c405Definition, int c405Definition_Depth);
void CMockExpectParameters_vLaserDataGetCan405Info(CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance, c405Definition_t* c405Definition, int c405Definition_Depth)
{
  cmock_call_instance->Expected_c405Definition = c405Definition;
  cmock_call_instance->Expected_c405Definition_Depth = c405Definition_Depth;
  cmock_call_instance->IgnoreArg_c405Definition = 0;
  cmock_call_instance->ReturnThruPtr_c405Definition_Used = 0;
}

void vLaserDataGetCan405Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan405Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan405Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan405Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan405Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan405Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c405Definition_t* c405Definition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan405Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan405Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan405Info(cmock_call_instance, c405Definition, 1);
}

void vLaserDataGetCan405Info_AddCallback(CMOCK_vLaserDataGetCan405Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan405Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan405Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan405Info_Stub(CMOCK_vLaserDataGetCan405Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan405Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan405Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan405Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c405Definition_t* c405Definition, int c405Definition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan405Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan405Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan405Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan405Info(cmock_call_instance, c405Definition, c405Definition_Depth);
}

void vLaserDataGetCan405Info_CMockReturnMemThruPtr_c405Definition(UNITY_LINE_TYPE cmock_line, c405Definition_t* c405Definition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan405Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c405Definition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c405Definition_Val = c405Definition;
  cmock_call_instance->ReturnThruPtr_c405Definition_Size = cmock_size;
}

void vLaserDataGetCan405Info_CMockIgnoreArg_c405Definition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan405Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan405Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c405Definition = 1;
}

c406PacketControlDefinition_t* vLaserDataGetData406(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData406_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData406);
  cmock_call_instance = (CMOCK_vLaserDataGetData406_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData406_CallInstance);
  Mock.vLaserDataGetData406_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData406_CallInstance);
  if (Mock.vLaserDataGetData406_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData406_FinalReturn;
    Mock.vLaserDataGetData406_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData406_CallbackBool &&
      Mock.vLaserDataGetData406_CallbackFunctionPointer != NULL)
  {
    c406PacketControlDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData406_CallbackFunctionPointer(Mock.vLaserDataGetData406_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData406_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData406_CallbackFunctionPointer(Mock.vLaserDataGetData406_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData406_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData406_CALL_INSTANCE));
  CMOCK_vLaserDataGetData406_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData406_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData406_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData406_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData406_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData406_IgnoreBool = (char)1;
}

void vLaserDataGetData406_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData406_IgnoreBool)
    Mock.vLaserDataGetData406_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData406_CallInstance);
  Mock.vLaserDataGetData406_IgnoreBool = (char)0;
}

void vLaserDataGetData406_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData406_CALL_INSTANCE));
  CMOCK_vLaserDataGetData406_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData406_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData406_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData406_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData406_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData406_AddCallback(CMOCK_vLaserDataGetData406_CALLBACK Callback)
{
  Mock.vLaserDataGetData406_IgnoreBool = (char)0;
  Mock.vLaserDataGetData406_CallbackBool = (char)1;
  Mock.vLaserDataGetData406_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData406_Stub(CMOCK_vLaserDataGetData406_CALLBACK Callback)
{
  Mock.vLaserDataGetData406_IgnoreBool = (char)0;
  Mock.vLaserDataGetData406_CallbackBool = (char)0;
  Mock.vLaserDataGetData406_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan406Info(c406PacketControlDefinition_t* c406PacketControlDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan406Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan406Info_CallInstance);
  Mock.vLaserDataGetCan406Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan406Info_CallInstance);
  if (Mock.vLaserDataGetCan406Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan406Info_CallbackBool &&
      Mock.vLaserDataGetCan406Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan406Info_CallbackFunctionPointer(c406PacketControlDefinition, Mock.vLaserDataGetCan406Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c406PacketControlDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan406Info,CMockString_c406PacketControlDefinition);
    if (cmock_call_instance->Expected_c406PacketControlDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c406PacketControlDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c406PacketControlDefinition), (void*)(c406PacketControlDefinition), sizeof(c406PacketControlDefinition_t), cmock_call_instance->Expected_c406PacketControlDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan406Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan406Info_CallbackFunctionPointer(c406PacketControlDefinition, Mock.vLaserDataGetCan406Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c406PacketControlDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c406PacketControlDefinition, (void*)cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan406Info(CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance, c406PacketControlDefinition_t* c406PacketControlDefinition, int c406PacketControlDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan406Info(CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance, c406PacketControlDefinition_t* c406PacketControlDefinition, int c406PacketControlDefinition_Depth)
{
  cmock_call_instance->Expected_c406PacketControlDefinition = c406PacketControlDefinition;
  cmock_call_instance->Expected_c406PacketControlDefinition_Depth = c406PacketControlDefinition_Depth;
  cmock_call_instance->IgnoreArg_c406PacketControlDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Used = 0;
}

void vLaserDataGetCan406Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan406Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan406Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan406Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan406Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan406Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* c406PacketControlDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan406Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan406Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan406Info(cmock_call_instance, c406PacketControlDefinition, 1);
}

void vLaserDataGetCan406Info_AddCallback(CMOCK_vLaserDataGetCan406Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan406Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan406Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan406Info_Stub(CMOCK_vLaserDataGetCan406Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan406Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan406Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan406Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* c406PacketControlDefinition, int c406PacketControlDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan406Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan406Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan406Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan406Info(cmock_call_instance, c406PacketControlDefinition, c406PacketControlDefinition_Depth);
}

void vLaserDataGetCan406Info_CMockReturnMemThruPtr_c406PacketControlDefinition(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* c406PacketControlDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan406Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Val = c406PacketControlDefinition;
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Size = cmock_size;
}

void vLaserDataGetCan406Info_CMockIgnoreArg_c406PacketControlDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan406Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c406PacketControlDefinition = 1;
}

void vLaserDataSetCan406Info(c406PacketControlDefinition_t* c406PacketControlDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataSetCan406Info);
  cmock_call_instance = (CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataSetCan406Info_CallInstance);
  Mock.vLaserDataSetCan406Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataSetCan406Info_CallInstance);
  if (Mock.vLaserDataSetCan406Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataSetCan406Info_CallbackBool &&
      Mock.vLaserDataSetCan406Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataSetCan406Info_CallbackFunctionPointer(c406PacketControlDefinition, Mock.vLaserDataSetCan406Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c406PacketControlDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataSetCan406Info,CMockString_c406PacketControlDefinition);
    if (cmock_call_instance->Expected_c406PacketControlDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c406PacketControlDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c406PacketControlDefinition), (void*)(c406PacketControlDefinition), sizeof(c406PacketControlDefinition_t), cmock_call_instance->Expected_c406PacketControlDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataSetCan406Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataSetCan406Info_CallbackFunctionPointer(c406PacketControlDefinition, Mock.vLaserDataSetCan406Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c406PacketControlDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c406PacketControlDefinition, (void*)cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataSetCan406Info(CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance, c406PacketControlDefinition_t* c406PacketControlDefinition, int c406PacketControlDefinition_Depth);
void CMockExpectParameters_vLaserDataSetCan406Info(CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance, c406PacketControlDefinition_t* c406PacketControlDefinition, int c406PacketControlDefinition_Depth)
{
  cmock_call_instance->Expected_c406PacketControlDefinition = c406PacketControlDefinition;
  cmock_call_instance->Expected_c406PacketControlDefinition_Depth = c406PacketControlDefinition_Depth;
  cmock_call_instance->IgnoreArg_c406PacketControlDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Used = 0;
}

void vLaserDataSetCan406Info_CMockIgnore(void)
{
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)1;
}

void vLaserDataSetCan406Info_CMockStopIgnore(void)
{
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)0;
}

void vLaserDataSetCan406Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE));
  CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataSetCan406Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataSetCan406Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataSetCan406Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* c406PacketControlDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE));
  CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataSetCan406Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataSetCan406Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataSetCan406Info(cmock_call_instance, c406PacketControlDefinition, 1);
}

void vLaserDataSetCan406Info_AddCallback(CMOCK_vLaserDataSetCan406Info_CALLBACK Callback)
{
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)0;
  Mock.vLaserDataSetCan406Info_CallbackBool = (char)1;
  Mock.vLaserDataSetCan406Info_CallbackFunctionPointer = Callback;
}

void vLaserDataSetCan406Info_Stub(CMOCK_vLaserDataSetCan406Info_CALLBACK Callback)
{
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)0;
  Mock.vLaserDataSetCan406Info_CallbackBool = (char)0;
  Mock.vLaserDataSetCan406Info_CallbackFunctionPointer = Callback;
}

void vLaserDataSetCan406Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* c406PacketControlDefinition, int c406PacketControlDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE));
  CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataSetCan406Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataSetCan406Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataSetCan406Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataSetCan406Info(cmock_call_instance, c406PacketControlDefinition, c406PacketControlDefinition_Depth);
}

void vLaserDataSetCan406Info_CMockReturnMemThruPtr_c406PacketControlDefinition(UNITY_LINE_TYPE cmock_line, c406PacketControlDefinition_t* c406PacketControlDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataSetCan406Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Val = c406PacketControlDefinition;
  cmock_call_instance->ReturnThruPtr_c406PacketControlDefinition_Size = cmock_size;
}

void vLaserDataSetCan406Info_CMockIgnoreArg_c406PacketControlDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan406Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataSetCan406Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c406PacketControlDefinition = 1;
}

c407PacketControlDefinition_t* vLaserDataGetData407(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData407_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData407);
  cmock_call_instance = (CMOCK_vLaserDataGetData407_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData407_CallInstance);
  Mock.vLaserDataGetData407_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData407_CallInstance);
  if (Mock.vLaserDataGetData407_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData407_FinalReturn;
    Mock.vLaserDataGetData407_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData407_CallbackBool &&
      Mock.vLaserDataGetData407_CallbackFunctionPointer != NULL)
  {
    c407PacketControlDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData407_CallbackFunctionPointer(Mock.vLaserDataGetData407_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData407_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData407_CallbackFunctionPointer(Mock.vLaserDataGetData407_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData407_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData407_CALL_INSTANCE));
  CMOCK_vLaserDataGetData407_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData407_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData407_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData407_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData407_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData407_IgnoreBool = (char)1;
}

void vLaserDataGetData407_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData407_IgnoreBool)
    Mock.vLaserDataGetData407_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData407_CallInstance);
  Mock.vLaserDataGetData407_IgnoreBool = (char)0;
}

void vLaserDataGetData407_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData407_CALL_INSTANCE));
  CMOCK_vLaserDataGetData407_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData407_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData407_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData407_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData407_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData407_AddCallback(CMOCK_vLaserDataGetData407_CALLBACK Callback)
{
  Mock.vLaserDataGetData407_IgnoreBool = (char)0;
  Mock.vLaserDataGetData407_CallbackBool = (char)1;
  Mock.vLaserDataGetData407_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData407_Stub(CMOCK_vLaserDataGetData407_CALLBACK Callback)
{
  Mock.vLaserDataGetData407_IgnoreBool = (char)0;
  Mock.vLaserDataGetData407_CallbackBool = (char)0;
  Mock.vLaserDataGetData407_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan407Info(c407PacketControlDefinition_t* c407PacketControlDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan407Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan407Info_CallInstance);
  Mock.vLaserDataGetCan407Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan407Info_CallInstance);
  if (Mock.vLaserDataGetCan407Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan407Info_CallbackBool &&
      Mock.vLaserDataGetCan407Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan407Info_CallbackFunctionPointer(c407PacketControlDefinition, Mock.vLaserDataGetCan407Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c407PacketControlDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan407Info,CMockString_c407PacketControlDefinition);
    if (cmock_call_instance->Expected_c407PacketControlDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c407PacketControlDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c407PacketControlDefinition), (void*)(c407PacketControlDefinition), sizeof(c407PacketControlDefinition_t), cmock_call_instance->Expected_c407PacketControlDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan407Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan407Info_CallbackFunctionPointer(c407PacketControlDefinition, Mock.vLaserDataGetCan407Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c407PacketControlDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c407PacketControlDefinition, (void*)cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan407Info(CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance, c407PacketControlDefinition_t* c407PacketControlDefinition, int c407PacketControlDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan407Info(CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance, c407PacketControlDefinition_t* c407PacketControlDefinition, int c407PacketControlDefinition_Depth)
{
  cmock_call_instance->Expected_c407PacketControlDefinition = c407PacketControlDefinition;
  cmock_call_instance->Expected_c407PacketControlDefinition_Depth = c407PacketControlDefinition_Depth;
  cmock_call_instance->IgnoreArg_c407PacketControlDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Used = 0;
}

void vLaserDataGetCan407Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan407Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan407Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan407Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan407Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan407Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* c407PacketControlDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan407Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan407Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan407Info(cmock_call_instance, c407PacketControlDefinition, 1);
}

void vLaserDataGetCan407Info_AddCallback(CMOCK_vLaserDataGetCan407Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan407Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan407Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan407Info_Stub(CMOCK_vLaserDataGetCan407Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan407Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan407Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan407Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* c407PacketControlDefinition, int c407PacketControlDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan407Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan407Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan407Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan407Info(cmock_call_instance, c407PacketControlDefinition, c407PacketControlDefinition_Depth);
}

void vLaserDataGetCan407Info_CMockReturnMemThruPtr_c407PacketControlDefinition(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* c407PacketControlDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan407Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Val = c407PacketControlDefinition;
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Size = cmock_size;
}

void vLaserDataGetCan407Info_CMockIgnoreArg_c407PacketControlDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan407Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c407PacketControlDefinition = 1;
}

void vLaserDataSetCan407Info(c407PacketControlDefinition_t* c407PacketControlDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataSetCan407Info);
  cmock_call_instance = (CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataSetCan407Info_CallInstance);
  Mock.vLaserDataSetCan407Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataSetCan407Info_CallInstance);
  if (Mock.vLaserDataSetCan407Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataSetCan407Info_CallbackBool &&
      Mock.vLaserDataSetCan407Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataSetCan407Info_CallbackFunctionPointer(c407PacketControlDefinition, Mock.vLaserDataSetCan407Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c407PacketControlDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataSetCan407Info,CMockString_c407PacketControlDefinition);
    if (cmock_call_instance->Expected_c407PacketControlDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c407PacketControlDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c407PacketControlDefinition), (void*)(c407PacketControlDefinition), sizeof(c407PacketControlDefinition_t), cmock_call_instance->Expected_c407PacketControlDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataSetCan407Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataSetCan407Info_CallbackFunctionPointer(c407PacketControlDefinition, Mock.vLaserDataSetCan407Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c407PacketControlDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c407PacketControlDefinition, (void*)cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataSetCan407Info(CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance, c407PacketControlDefinition_t* c407PacketControlDefinition, int c407PacketControlDefinition_Depth);
void CMockExpectParameters_vLaserDataSetCan407Info(CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance, c407PacketControlDefinition_t* c407PacketControlDefinition, int c407PacketControlDefinition_Depth)
{
  cmock_call_instance->Expected_c407PacketControlDefinition = c407PacketControlDefinition;
  cmock_call_instance->Expected_c407PacketControlDefinition_Depth = c407PacketControlDefinition_Depth;
  cmock_call_instance->IgnoreArg_c407PacketControlDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Used = 0;
}

void vLaserDataSetCan407Info_CMockIgnore(void)
{
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)1;
}

void vLaserDataSetCan407Info_CMockStopIgnore(void)
{
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)0;
}

void vLaserDataSetCan407Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE));
  CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataSetCan407Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataSetCan407Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataSetCan407Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* c407PacketControlDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE));
  CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataSetCan407Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataSetCan407Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataSetCan407Info(cmock_call_instance, c407PacketControlDefinition, 1);
}

void vLaserDataSetCan407Info_AddCallback(CMOCK_vLaserDataSetCan407Info_CALLBACK Callback)
{
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)0;
  Mock.vLaserDataSetCan407Info_CallbackBool = (char)1;
  Mock.vLaserDataSetCan407Info_CallbackFunctionPointer = Callback;
}

void vLaserDataSetCan407Info_Stub(CMOCK_vLaserDataSetCan407Info_CALLBACK Callback)
{
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)0;
  Mock.vLaserDataSetCan407Info_CallbackBool = (char)0;
  Mock.vLaserDataSetCan407Info_CallbackFunctionPointer = Callback;
}

void vLaserDataSetCan407Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* c407PacketControlDefinition, int c407PacketControlDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE));
  CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataSetCan407Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataSetCan407Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataSetCan407Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataSetCan407Info(cmock_call_instance, c407PacketControlDefinition, c407PacketControlDefinition_Depth);
}

void vLaserDataSetCan407Info_CMockReturnMemThruPtr_c407PacketControlDefinition(UNITY_LINE_TYPE cmock_line, c407PacketControlDefinition_t* c407PacketControlDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataSetCan407Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Val = c407PacketControlDefinition;
  cmock_call_instance->ReturnThruPtr_c407PacketControlDefinition_Size = cmock_size;
}

void vLaserDataSetCan407Info_CMockIgnoreArg_c407PacketControlDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataSetCan407Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataSetCan407Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c407PacketControlDefinition = 1;
}

c408StatusDefinition_t* vLaserDataGetData408(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData408_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData408);
  cmock_call_instance = (CMOCK_vLaserDataGetData408_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData408_CallInstance);
  Mock.vLaserDataGetData408_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData408_CallInstance);
  if (Mock.vLaserDataGetData408_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData408_FinalReturn;
    Mock.vLaserDataGetData408_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData408_CallbackBool &&
      Mock.vLaserDataGetData408_CallbackFunctionPointer != NULL)
  {
    c408StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData408_CallbackFunctionPointer(Mock.vLaserDataGetData408_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData408_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData408_CallbackFunctionPointer(Mock.vLaserDataGetData408_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData408_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c408StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData408_CALL_INSTANCE));
  CMOCK_vLaserDataGetData408_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData408_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData408_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData408_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData408_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData408_IgnoreBool = (char)1;
}

void vLaserDataGetData408_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData408_IgnoreBool)
    Mock.vLaserDataGetData408_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData408_CallInstance);
  Mock.vLaserDataGetData408_IgnoreBool = (char)0;
}

void vLaserDataGetData408_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c408StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData408_CALL_INSTANCE));
  CMOCK_vLaserDataGetData408_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData408_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData408_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData408_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData408_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData408_AddCallback(CMOCK_vLaserDataGetData408_CALLBACK Callback)
{
  Mock.vLaserDataGetData408_IgnoreBool = (char)0;
  Mock.vLaserDataGetData408_CallbackBool = (char)1;
  Mock.vLaserDataGetData408_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData408_Stub(CMOCK_vLaserDataGetData408_CALLBACK Callback)
{
  Mock.vLaserDataGetData408_IgnoreBool = (char)0;
  Mock.vLaserDataGetData408_CallbackBool = (char)0;
  Mock.vLaserDataGetData408_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan408Info(c408StatusDefinition_t* c408StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan408Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan408Info_CallInstance);
  Mock.vLaserDataGetCan408Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan408Info_CallInstance);
  if (Mock.vLaserDataGetCan408Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan408Info_CallbackBool &&
      Mock.vLaserDataGetCan408Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan408Info_CallbackFunctionPointer(c408StatusDefinition, Mock.vLaserDataGetCan408Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c408StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan408Info,CMockString_c408StatusDefinition);
    if (cmock_call_instance->Expected_c408StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c408StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c408StatusDefinition), (void*)(c408StatusDefinition), sizeof(c408StatusDefinition_t), cmock_call_instance->Expected_c408StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan408Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan408Info_CallbackFunctionPointer(c408StatusDefinition, Mock.vLaserDataGetCan408Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c408StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c408StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan408Info(CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance, c408StatusDefinition_t* c408StatusDefinition, int c408StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan408Info(CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance, c408StatusDefinition_t* c408StatusDefinition, int c408StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c408StatusDefinition = c408StatusDefinition;
  cmock_call_instance->Expected_c408StatusDefinition_Depth = c408StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c408StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Used = 0;
}

void vLaserDataGetCan408Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan408Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan408Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan408Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan408Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan408Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c408StatusDefinition_t* c408StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan408Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan408Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan408Info(cmock_call_instance, c408StatusDefinition, 1);
}

void vLaserDataGetCan408Info_AddCallback(CMOCK_vLaserDataGetCan408Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan408Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan408Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan408Info_Stub(CMOCK_vLaserDataGetCan408Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan408Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan408Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan408Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c408StatusDefinition_t* c408StatusDefinition, int c408StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan408Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan408Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan408Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan408Info(cmock_call_instance, c408StatusDefinition, c408StatusDefinition_Depth);
}

void vLaserDataGetCan408Info_CMockReturnMemThruPtr_c408StatusDefinition(UNITY_LINE_TYPE cmock_line, c408StatusDefinition_t* c408StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan408Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Val = c408StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c408StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan408Info_CMockIgnoreArg_c408StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan408Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan408Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c408StatusDefinition = 1;
}

c403StatusDefinition_t* vLaserDataGetData403(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData403_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData403);
  cmock_call_instance = (CMOCK_vLaserDataGetData403_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData403_CallInstance);
  Mock.vLaserDataGetData403_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData403_CallInstance);
  if (Mock.vLaserDataGetData403_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData403_FinalReturn;
    Mock.vLaserDataGetData403_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData403_CallbackBool &&
      Mock.vLaserDataGetData403_CallbackFunctionPointer != NULL)
  {
    c403StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData403_CallbackFunctionPointer(Mock.vLaserDataGetData403_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData403_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData403_CallbackFunctionPointer(Mock.vLaserDataGetData403_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData403_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c403StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData403_CALL_INSTANCE));
  CMOCK_vLaserDataGetData403_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData403_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData403_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData403_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData403_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData403_IgnoreBool = (char)1;
}

void vLaserDataGetData403_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData403_IgnoreBool)
    Mock.vLaserDataGetData403_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData403_CallInstance);
  Mock.vLaserDataGetData403_IgnoreBool = (char)0;
}

void vLaserDataGetData403_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c403StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData403_CALL_INSTANCE));
  CMOCK_vLaserDataGetData403_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData403_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData403_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData403_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData403_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData403_AddCallback(CMOCK_vLaserDataGetData403_CALLBACK Callback)
{
  Mock.vLaserDataGetData403_IgnoreBool = (char)0;
  Mock.vLaserDataGetData403_CallbackBool = (char)1;
  Mock.vLaserDataGetData403_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData403_Stub(CMOCK_vLaserDataGetData403_CALLBACK Callback)
{
  Mock.vLaserDataGetData403_IgnoreBool = (char)0;
  Mock.vLaserDataGetData403_CallbackBool = (char)0;
  Mock.vLaserDataGetData403_CallbackFunctionPointer = Callback;
}

c404StatusDefinition_t* vLaserDataGetData404(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData404_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData404);
  cmock_call_instance = (CMOCK_vLaserDataGetData404_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData404_CallInstance);
  Mock.vLaserDataGetData404_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData404_CallInstance);
  if (Mock.vLaserDataGetData404_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData404_FinalReturn;
    Mock.vLaserDataGetData404_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData404_CallbackBool &&
      Mock.vLaserDataGetData404_CallbackFunctionPointer != NULL)
  {
    c404StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData404_CallbackFunctionPointer(Mock.vLaserDataGetData404_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData404_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData404_CallbackFunctionPointer(Mock.vLaserDataGetData404_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData404_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c404StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData404_CALL_INSTANCE));
  CMOCK_vLaserDataGetData404_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData404_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData404_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData404_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData404_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData404_IgnoreBool = (char)1;
}

void vLaserDataGetData404_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData404_IgnoreBool)
    Mock.vLaserDataGetData404_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData404_CallInstance);
  Mock.vLaserDataGetData404_IgnoreBool = (char)0;
}

void vLaserDataGetData404_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c404StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData404_CALL_INSTANCE));
  CMOCK_vLaserDataGetData404_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData404_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData404_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData404_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData404_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData404_AddCallback(CMOCK_vLaserDataGetData404_CALLBACK Callback)
{
  Mock.vLaserDataGetData404_IgnoreBool = (char)0;
  Mock.vLaserDataGetData404_CallbackBool = (char)1;
  Mock.vLaserDataGetData404_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData404_Stub(CMOCK_vLaserDataGetData404_CALLBACK Callback)
{
  Mock.vLaserDataGetData404_IgnoreBool = (char)0;
  Mock.vLaserDataGetData404_CallbackBool = (char)0;
  Mock.vLaserDataGetData404_CallbackFunctionPointer = Callback;
}

c409StatusDefinition_t* vLaserDataGetData409(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData409_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData409);
  cmock_call_instance = (CMOCK_vLaserDataGetData409_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData409_CallInstance);
  Mock.vLaserDataGetData409_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData409_CallInstance);
  if (Mock.vLaserDataGetData409_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData409_FinalReturn;
    Mock.vLaserDataGetData409_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData409_CallbackBool &&
      Mock.vLaserDataGetData409_CallbackFunctionPointer != NULL)
  {
    c409StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData409_CallbackFunctionPointer(Mock.vLaserDataGetData409_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData409_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData409_CallbackFunctionPointer(Mock.vLaserDataGetData409_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData409_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData409_CALL_INSTANCE));
  CMOCK_vLaserDataGetData409_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData409_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData409_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData409_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData409_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData409_IgnoreBool = (char)1;
}

void vLaserDataGetData409_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData409_IgnoreBool)
    Mock.vLaserDataGetData409_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData409_CallInstance);
  Mock.vLaserDataGetData409_IgnoreBool = (char)0;
}

void vLaserDataGetData409_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData409_CALL_INSTANCE));
  CMOCK_vLaserDataGetData409_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData409_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData409_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData409_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData409_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData409_AddCallback(CMOCK_vLaserDataGetData409_CALLBACK Callback)
{
  Mock.vLaserDataGetData409_IgnoreBool = (char)0;
  Mock.vLaserDataGetData409_CallbackBool = (char)1;
  Mock.vLaserDataGetData409_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData409_Stub(CMOCK_vLaserDataGetData409_CALLBACK Callback)
{
  Mock.vLaserDataGetData409_IgnoreBool = (char)0;
  Mock.vLaserDataGetData409_CallbackBool = (char)0;
  Mock.vLaserDataGetData409_CallbackFunctionPointer = Callback;
}

c410StatusDefinition_t* vLaserDataGetData410(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData410_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData410);
  cmock_call_instance = (CMOCK_vLaserDataGetData410_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData410_CallInstance);
  Mock.vLaserDataGetData410_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData410_CallInstance);
  if (Mock.vLaserDataGetData410_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData410_FinalReturn;
    Mock.vLaserDataGetData410_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData410_CallbackBool &&
      Mock.vLaserDataGetData410_CallbackFunctionPointer != NULL)
  {
    c410StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData410_CallbackFunctionPointer(Mock.vLaserDataGetData410_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData410_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData410_CallbackFunctionPointer(Mock.vLaserDataGetData410_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData410_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c410StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData410_CALL_INSTANCE));
  CMOCK_vLaserDataGetData410_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData410_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData410_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData410_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData410_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData410_IgnoreBool = (char)1;
}

void vLaserDataGetData410_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData410_IgnoreBool)
    Mock.vLaserDataGetData410_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData410_CallInstance);
  Mock.vLaserDataGetData410_IgnoreBool = (char)0;
}

void vLaserDataGetData410_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c410StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData410_CALL_INSTANCE));
  CMOCK_vLaserDataGetData410_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData410_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData410_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData410_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData410_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData410_AddCallback(CMOCK_vLaserDataGetData410_CALLBACK Callback)
{
  Mock.vLaserDataGetData410_IgnoreBool = (char)0;
  Mock.vLaserDataGetData410_CallbackBool = (char)1;
  Mock.vLaserDataGetData410_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData410_Stub(CMOCK_vLaserDataGetData410_CALLBACK Callback)
{
  Mock.vLaserDataGetData410_IgnoreBool = (char)0;
  Mock.vLaserDataGetData410_CallbackBool = (char)0;
  Mock.vLaserDataGetData410_CallbackFunctionPointer = Callback;
}

c412StatusDefinition_t* vLaserDataGetData412(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData412_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData412);
  cmock_call_instance = (CMOCK_vLaserDataGetData412_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData412_CallInstance);
  Mock.vLaserDataGetData412_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData412_CallInstance);
  if (Mock.vLaserDataGetData412_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData412_FinalReturn;
    Mock.vLaserDataGetData412_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData412_CallbackBool &&
      Mock.vLaserDataGetData412_CallbackFunctionPointer != NULL)
  {
    c412StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData412_CallbackFunctionPointer(Mock.vLaserDataGetData412_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData412_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData412_CallbackFunctionPointer(Mock.vLaserDataGetData412_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData412_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c412StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData412_CALL_INSTANCE));
  CMOCK_vLaserDataGetData412_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData412_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData412_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData412_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData412_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData412_IgnoreBool = (char)1;
}

void vLaserDataGetData412_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData412_IgnoreBool)
    Mock.vLaserDataGetData412_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData412_CallInstance);
  Mock.vLaserDataGetData412_IgnoreBool = (char)0;
}

void vLaserDataGetData412_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c412StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData412_CALL_INSTANCE));
  CMOCK_vLaserDataGetData412_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData412_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData412_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData412_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData412_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData412_AddCallback(CMOCK_vLaserDataGetData412_CALLBACK Callback)
{
  Mock.vLaserDataGetData412_IgnoreBool = (char)0;
  Mock.vLaserDataGetData412_CallbackBool = (char)1;
  Mock.vLaserDataGetData412_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData412_Stub(CMOCK_vLaserDataGetData412_CALLBACK Callback)
{
  Mock.vLaserDataGetData412_IgnoreBool = (char)0;
  Mock.vLaserDataGetData412_CallbackBool = (char)0;
  Mock.vLaserDataGetData412_CallbackFunctionPointer = Callback;
}

c413StatusDefinition_t* vLaserDataGetData413(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetData413_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetData413);
  cmock_call_instance = (CMOCK_vLaserDataGetData413_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetData413_CallInstance);
  Mock.vLaserDataGetData413_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData413_CallInstance);
  if (Mock.vLaserDataGetData413_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetData413_FinalReturn;
    Mock.vLaserDataGetData413_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetData413_CallbackBool &&
      Mock.vLaserDataGetData413_CallbackFunctionPointer != NULL)
  {
    c413StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetData413_CallbackFunctionPointer(Mock.vLaserDataGetData413_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetData413_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetData413_CallbackFunctionPointer(Mock.vLaserDataGetData413_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetData413_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c413StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData413_CALL_INSTANCE));
  CMOCK_vLaserDataGetData413_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData413_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData413_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData413_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData413_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetData413_IgnoreBool = (char)1;
}

void vLaserDataGetData413_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetData413_IgnoreBool)
    Mock.vLaserDataGetData413_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetData413_CallInstance);
  Mock.vLaserDataGetData413_IgnoreBool = (char)0;
}

void vLaserDataGetData413_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c413StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetData413_CALL_INSTANCE));
  CMOCK_vLaserDataGetData413_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetData413_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetData413_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetData413_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetData413_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetData413_AddCallback(CMOCK_vLaserDataGetData413_CALLBACK Callback)
{
  Mock.vLaserDataGetData413_IgnoreBool = (char)0;
  Mock.vLaserDataGetData413_CallbackBool = (char)1;
  Mock.vLaserDataGetData413_CallbackFunctionPointer = Callback;
}

void vLaserDataGetData413_Stub(CMOCK_vLaserDataGetData413_CALLBACK Callback)
{
  Mock.vLaserDataGetData413_IgnoreBool = (char)0;
  Mock.vLaserDataGetData413_CallbackBool = (char)0;
  Mock.vLaserDataGetData413_CallbackFunctionPointer = Callback;
}

eBool_t bValidatePassword(c412StatusDefinition_t* c412StatusDefinition, c413StatusDefinition_t* c413StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bValidatePassword);
  cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bValidatePassword_CallInstance);
  Mock.bValidatePassword_CallInstance = CMock_Guts_MemNext(Mock.bValidatePassword_CallInstance);
  if (Mock.bValidatePassword_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bValidatePassword_FinalReturn;
    memcpy((void*)(&Mock.bValidatePassword_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bValidatePassword_CallbackBool &&
      Mock.bValidatePassword_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bValidatePassword_CallbackFunctionPointer(c412StatusDefinition, c413StatusDefinition, Mock.bValidatePassword_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c412StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_bValidatePassword,CMockString_c412StatusDefinition);
    if (cmock_call_instance->Expected_c412StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c412StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c412StatusDefinition), (void*)(c412StatusDefinition), sizeof(c412StatusDefinition_t), cmock_call_instance->Expected_c412StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_c413StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_bValidatePassword,CMockString_c413StatusDefinition);
    if (cmock_call_instance->Expected_c413StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c413StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c413StatusDefinition), (void*)(c413StatusDefinition), sizeof(c413StatusDefinition_t), cmock_call_instance->Expected_c413StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.bValidatePassword_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bValidatePassword_CallbackFunctionPointer(c412StatusDefinition, c413StatusDefinition, Mock.bValidatePassword_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c412StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c412StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c413StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c413StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_bValidatePassword(CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance, c412StatusDefinition_t* c412StatusDefinition, int c412StatusDefinition_Depth, c413StatusDefinition_t* c413StatusDefinition, int c413StatusDefinition_Depth);
void CMockExpectParameters_bValidatePassword(CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance, c412StatusDefinition_t* c412StatusDefinition, int c412StatusDefinition_Depth, c413StatusDefinition_t* c413StatusDefinition, int c413StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c412StatusDefinition = c412StatusDefinition;
  cmock_call_instance->Expected_c412StatusDefinition_Depth = c412StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c412StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Used = 0;
  cmock_call_instance->Expected_c413StatusDefinition = c413StatusDefinition;
  cmock_call_instance->Expected_c413StatusDefinition_Depth = c413StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c413StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Used = 0;
}

void bValidatePassword_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bValidatePassword_CALL_INSTANCE));
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bValidatePassword_CallInstance = CMock_Guts_MemChain(Mock.bValidatePassword_CallInstance, cmock_guts_index);
  Mock.bValidatePassword_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bValidatePassword_IgnoreBool = (char)1;
}

void bValidatePassword_CMockStopIgnore(void)
{
  if(Mock.bValidatePassword_IgnoreBool)
    Mock.bValidatePassword_CallInstance = CMock_Guts_MemNext(Mock.bValidatePassword_CallInstance);
  Mock.bValidatePassword_IgnoreBool = (char)0;
}

void bValidatePassword_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bValidatePassword_CALL_INSTANCE));
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bValidatePassword_CallInstance = CMock_Guts_MemChain(Mock.bValidatePassword_CallInstance, cmock_guts_index);
  Mock.bValidatePassword_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void bValidatePassword_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c412StatusDefinition_t* c412StatusDefinition, c413StatusDefinition_t* c413StatusDefinition, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bValidatePassword_CALL_INSTANCE));
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bValidatePassword_CallInstance = CMock_Guts_MemChain(Mock.bValidatePassword_CallInstance, cmock_guts_index);
  Mock.bValidatePassword_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_bValidatePassword(cmock_call_instance, c412StatusDefinition, 1, c413StatusDefinition, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bValidatePassword_AddCallback(CMOCK_bValidatePassword_CALLBACK Callback)
{
  Mock.bValidatePassword_IgnoreBool = (char)0;
  Mock.bValidatePassword_CallbackBool = (char)1;
  Mock.bValidatePassword_CallbackFunctionPointer = Callback;
}

void bValidatePassword_Stub(CMOCK_bValidatePassword_CALLBACK Callback)
{
  Mock.bValidatePassword_IgnoreBool = (char)0;
  Mock.bValidatePassword_CallbackBool = (char)0;
  Mock.bValidatePassword_CallbackFunctionPointer = Callback;
}

void bValidatePassword_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, c412StatusDefinition_t* c412StatusDefinition, int c412StatusDefinition_Depth, c413StatusDefinition_t* c413StatusDefinition, int c413StatusDefinition_Depth, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bValidatePassword_CALL_INSTANCE));
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bValidatePassword_CallInstance = CMock_Guts_MemChain(Mock.bValidatePassword_CallInstance, cmock_guts_index);
  Mock.bValidatePassword_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_bValidatePassword(cmock_call_instance, c412StatusDefinition, c412StatusDefinition_Depth, c413StatusDefinition, c413StatusDefinition_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void bValidatePassword_CMockReturnMemThruPtr_c412StatusDefinition(UNITY_LINE_TYPE cmock_line, c412StatusDefinition_t* c412StatusDefinition, size_t cmock_size)
{
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.bValidatePassword_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Val = c412StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c412StatusDefinition_Size = cmock_size;
}

void bValidatePassword_CMockReturnMemThruPtr_c413StatusDefinition(UNITY_LINE_TYPE cmock_line, c413StatusDefinition_t* c413StatusDefinition, size_t cmock_size)
{
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.bValidatePassword_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Val = c413StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c413StatusDefinition_Size = cmock_size;
}

void bValidatePassword_CMockIgnoreArg_c412StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.bValidatePassword_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c412StatusDefinition = 1;
}

void bValidatePassword_CMockIgnoreArg_c413StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_bValidatePassword_CALL_INSTANCE* cmock_call_instance = (CMOCK_bValidatePassword_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.bValidatePassword_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c413StatusDefinition = 1;
}

void vLaserDataGetCan409Info(c409StatusDefinition_t* c409StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan409Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan409Info_CallInstance);
  Mock.vLaserDataGetCan409Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan409Info_CallInstance);
  if (Mock.vLaserDataGetCan409Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan409Info_CallbackBool &&
      Mock.vLaserDataGetCan409Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan409Info_CallbackFunctionPointer(c409StatusDefinition, Mock.vLaserDataGetCan409Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c409StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan409Info,CMockString_c409StatusDefinition);
    if (cmock_call_instance->Expected_c409StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c409StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c409StatusDefinition), (void*)(c409StatusDefinition), sizeof(c409StatusDefinition_t), cmock_call_instance->Expected_c409StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan409Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan409Info_CallbackFunctionPointer(c409StatusDefinition, Mock.vLaserDataGetCan409Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c409StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c409StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan409Info(CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance, c409StatusDefinition_t* c409StatusDefinition, int c409StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan409Info(CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance, c409StatusDefinition_t* c409StatusDefinition, int c409StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c409StatusDefinition = c409StatusDefinition;
  cmock_call_instance->Expected_c409StatusDefinition_Depth = c409StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c409StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Used = 0;
}

void vLaserDataGetCan409Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan409Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan409Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan409Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan409Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan409Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* c409StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan409Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan409Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan409Info(cmock_call_instance, c409StatusDefinition, 1);
}

void vLaserDataGetCan409Info_AddCallback(CMOCK_vLaserDataGetCan409Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan409Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan409Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan409Info_Stub(CMOCK_vLaserDataGetCan409Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan409Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan409Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan409Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* c409StatusDefinition, int c409StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan409Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan409Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan409Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan409Info(cmock_call_instance, c409StatusDefinition, c409StatusDefinition_Depth);
}

void vLaserDataGetCan409Info_CMockReturnMemThruPtr_c409StatusDefinition(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* c409StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan409Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Val = c409StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c409StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan409Info_CMockIgnoreArg_c409StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan409Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c409StatusDefinition = 1;
}

c409StatusDefinition_t* vLaserDataGetCan409Pointer(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan409Pointer);
  cmock_call_instance = (CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan409Pointer_CallInstance);
  Mock.vLaserDataGetCan409Pointer_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan409Pointer_CallInstance);
  if (Mock.vLaserDataGetCan409Pointer_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetCan409Pointer_FinalReturn;
    Mock.vLaserDataGetCan409Pointer_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetCan409Pointer_CallbackBool &&
      Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer != NULL)
  {
    c409StatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer(Mock.vLaserDataGetCan409Pointer_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer(Mock.vLaserDataGetCan409Pointer_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetCan409Pointer_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan409Pointer_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan409Pointer_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan409Pointer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetCan409Pointer_IgnoreBool = (char)1;
}

void vLaserDataGetCan409Pointer_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetCan409Pointer_IgnoreBool)
    Mock.vLaserDataGetCan409Pointer_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan409Pointer_CallInstance);
  Mock.vLaserDataGetCan409Pointer_IgnoreBool = (char)0;
}

void vLaserDataGetCan409Pointer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c409StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan409Pointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan409Pointer_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan409Pointer_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan409Pointer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetCan409Pointer_AddCallback(CMOCK_vLaserDataGetCan409Pointer_CALLBACK Callback)
{
  Mock.vLaserDataGetCan409Pointer_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan409Pointer_CallbackBool = (char)1;
  Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan409Pointer_Stub(CMOCK_vLaserDataGetCan409Pointer_CALLBACK Callback)
{
  Mock.vLaserDataGetCan409Pointer_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan409Pointer_CallbackBool = (char)0;
  Mock.vLaserDataGetCan409Pointer_CallbackFunctionPointer = Callback;
}

c40AStatusDefinition_t* vLaserDataGetCan40AInfo(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan40AInfo);
  cmock_call_instance = (CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan40AInfo_CallInstance);
  Mock.vLaserDataGetCan40AInfo_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan40AInfo_CallInstance);
  if (Mock.vLaserDataGetCan40AInfo_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vLaserDataGetCan40AInfo_FinalReturn;
    Mock.vLaserDataGetCan40AInfo_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vLaserDataGetCan40AInfo_CallbackBool &&
      Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer != NULL)
  {
    c40AStatusDefinition_t* cmock_cb_ret = Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer(Mock.vLaserDataGetCan40AInfo_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer(Mock.vLaserDataGetCan40AInfo_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vLaserDataGetCan40AInfo_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c40AStatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan40AInfo_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan40AInfo_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan40AInfo_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vLaserDataGetCan40AInfo_IgnoreBool = (char)1;
}

void vLaserDataGetCan40AInfo_CMockStopIgnore(void)
{
  if(Mock.vLaserDataGetCan40AInfo_IgnoreBool)
    Mock.vLaserDataGetCan40AInfo_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan40AInfo_CallInstance);
  Mock.vLaserDataGetCan40AInfo_IgnoreBool = (char)0;
}

void vLaserDataGetCan40AInfo_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c40AStatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan40AInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan40AInfo_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan40AInfo_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan40AInfo_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vLaserDataGetCan40AInfo_AddCallback(CMOCK_vLaserDataGetCan40AInfo_CALLBACK Callback)
{
  Mock.vLaserDataGetCan40AInfo_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan40AInfo_CallbackBool = (char)1;
  Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan40AInfo_Stub(CMOCK_vLaserDataGetCan40AInfo_CALLBACK Callback)
{
  Mock.vLaserDataGetCan40AInfo_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan40AInfo_CallbackBool = (char)0;
  Mock.vLaserDataGetCan40AInfo_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan423Info(c423StatusDefinition_t* c423StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan423Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan423Info_CallInstance);
  Mock.vLaserDataGetCan423Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan423Info_CallInstance);
  if (Mock.vLaserDataGetCan423Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan423Info_CallbackBool &&
      Mock.vLaserDataGetCan423Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan423Info_CallbackFunctionPointer(c423StatusDefinition, Mock.vLaserDataGetCan423Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c423StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan423Info,CMockString_c423StatusDefinition);
    if (cmock_call_instance->Expected_c423StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c423StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c423StatusDefinition), (void*)(c423StatusDefinition), sizeof(c423StatusDefinition_t), cmock_call_instance->Expected_c423StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan423Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan423Info_CallbackFunctionPointer(c423StatusDefinition, Mock.vLaserDataGetCan423Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c423StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c423StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan423Info(CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance, c423StatusDefinition_t* c423StatusDefinition, int c423StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan423Info(CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance, c423StatusDefinition_t* c423StatusDefinition, int c423StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c423StatusDefinition = c423StatusDefinition;
  cmock_call_instance->Expected_c423StatusDefinition_Depth = c423StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c423StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Used = 0;
}

void vLaserDataGetCan423Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan423Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan423Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan423Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan423Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan423Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c423StatusDefinition_t* c423StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan423Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan423Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan423Info(cmock_call_instance, c423StatusDefinition, 1);
}

void vLaserDataGetCan423Info_AddCallback(CMOCK_vLaserDataGetCan423Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan423Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan423Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan423Info_Stub(CMOCK_vLaserDataGetCan423Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan423Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan423Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan423Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c423StatusDefinition_t* c423StatusDefinition, int c423StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan423Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan423Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan423Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan423Info(cmock_call_instance, c423StatusDefinition, c423StatusDefinition_Depth);
}

void vLaserDataGetCan423Info_CMockReturnMemThruPtr_c423StatusDefinition(UNITY_LINE_TYPE cmock_line, c423StatusDefinition_t* c423StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan423Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Val = c423StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c423StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan423Info_CMockIgnoreArg_c423StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan423Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan423Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c423StatusDefinition = 1;
}

c428StatusDefinition_t* pLaserDataGetCan428Info(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pLaserDataGetCan428Info);
  cmock_call_instance = (CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pLaserDataGetCan428Info_CallInstance);
  Mock.pLaserDataGetCan428Info_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan428Info_CallInstance);
  if (Mock.pLaserDataGetCan428Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pLaserDataGetCan428Info_FinalReturn;
    Mock.pLaserDataGetCan428Info_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pLaserDataGetCan428Info_CallbackBool &&
      Mock.pLaserDataGetCan428Info_CallbackFunctionPointer != NULL)
  {
    c428StatusDefinition_t* cmock_cb_ret = Mock.pLaserDataGetCan428Info_CallbackFunctionPointer(Mock.pLaserDataGetCan428Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.pLaserDataGetCan428Info_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pLaserDataGetCan428Info_CallbackFunctionPointer(Mock.pLaserDataGetCan428Info_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pLaserDataGetCan428Info_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, c428StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan428Info_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan428Info_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan428Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pLaserDataGetCan428Info_IgnoreBool = (char)1;
}

void pLaserDataGetCan428Info_CMockStopIgnore(void)
{
  if(Mock.pLaserDataGetCan428Info_IgnoreBool)
    Mock.pLaserDataGetCan428Info_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetCan428Info_CallInstance);
  Mock.pLaserDataGetCan428Info_IgnoreBool = (char)0;
}

void pLaserDataGetCan428Info_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, c428StatusDefinition_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE));
  CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetCan428Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetCan428Info_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetCan428Info_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetCan428Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pLaserDataGetCan428Info_AddCallback(CMOCK_pLaserDataGetCan428Info_CALLBACK Callback)
{
  Mock.pLaserDataGetCan428Info_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan428Info_CallbackBool = (char)1;
  Mock.pLaserDataGetCan428Info_CallbackFunctionPointer = Callback;
}

void pLaserDataGetCan428Info_Stub(CMOCK_pLaserDataGetCan428Info_CALLBACK Callback)
{
  Mock.pLaserDataGetCan428Info_IgnoreBool = (char)0;
  Mock.pLaserDataGetCan428Info_CallbackBool = (char)0;
  Mock.pLaserDataGetCan428Info_CallbackFunctionPointer = Callback;
}

xExternalAnalogThermistorsInputs_t* pLaserDataGetThermistorData(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pLaserDataGetThermistorData);
  cmock_call_instance = (CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pLaserDataGetThermistorData_CallInstance);
  Mock.pLaserDataGetThermistorData_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetThermistorData_CallInstance);
  if (Mock.pLaserDataGetThermistorData_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pLaserDataGetThermistorData_FinalReturn;
    Mock.pLaserDataGetThermistorData_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pLaserDataGetThermistorData_CallbackBool &&
      Mock.pLaserDataGetThermistorData_CallbackFunctionPointer != NULL)
  {
    xExternalAnalogThermistorsInputs_t* cmock_cb_ret = Mock.pLaserDataGetThermistorData_CallbackFunctionPointer(Mock.pLaserDataGetThermistorData_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.pLaserDataGetThermistorData_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pLaserDataGetThermistorData_CallbackFunctionPointer(Mock.pLaserDataGetThermistorData_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pLaserDataGetThermistorData_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xExternalAnalogThermistorsInputs_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE));
  CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetThermistorData_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetThermistorData_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetThermistorData_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pLaserDataGetThermistorData_IgnoreBool = (char)1;
}

void pLaserDataGetThermistorData_CMockStopIgnore(void)
{
  if(Mock.pLaserDataGetThermistorData_IgnoreBool)
    Mock.pLaserDataGetThermistorData_CallInstance = CMock_Guts_MemNext(Mock.pLaserDataGetThermistorData_CallInstance);
  Mock.pLaserDataGetThermistorData_IgnoreBool = (char)0;
}

void pLaserDataGetThermistorData_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xExternalAnalogThermistorsInputs_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE));
  CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE* cmock_call_instance = (CMOCK_pLaserDataGetThermistorData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pLaserDataGetThermistorData_CallInstance = CMock_Guts_MemChain(Mock.pLaserDataGetThermistorData_CallInstance, cmock_guts_index);
  Mock.pLaserDataGetThermistorData_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pLaserDataGetThermistorData_AddCallback(CMOCK_pLaserDataGetThermistorData_CALLBACK Callback)
{
  Mock.pLaserDataGetThermistorData_IgnoreBool = (char)0;
  Mock.pLaserDataGetThermistorData_CallbackBool = (char)1;
  Mock.pLaserDataGetThermistorData_CallbackFunctionPointer = Callback;
}

void pLaserDataGetThermistorData_Stub(CMOCK_pLaserDataGetThermistorData_CALLBACK Callback)
{
  Mock.pLaserDataGetThermistorData_IgnoreBool = (char)0;
  Mock.pLaserDataGetThermistorData_CallbackBool = (char)0;
  Mock.pLaserDataGetThermistorData_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan411Info(c411StatusDefinition_t* c411StatusDefinition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserDataGetCan411Info);
  cmock_call_instance = (CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserDataGetCan411Info_CallInstance);
  Mock.vLaserDataGetCan411Info_CallInstance = CMock_Guts_MemNext(Mock.vLaserDataGetCan411Info_CallInstance);
  if (Mock.vLaserDataGetCan411Info_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserDataGetCan411Info_CallbackBool &&
      Mock.vLaserDataGetCan411Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan411Info_CallbackFunctionPointer(c411StatusDefinition, Mock.vLaserDataGetCan411Info_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_c411StatusDefinition)
  {
    UNITY_SET_DETAILS(CMockString_vLaserDataGetCan411Info,CMockString_c411StatusDefinition);
    if (cmock_call_instance->Expected_c411StatusDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(c411StatusDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_c411StatusDefinition), (void*)(c411StatusDefinition), sizeof(c411StatusDefinition_t), cmock_call_instance->Expected_c411StatusDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vLaserDataGetCan411Info_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserDataGetCan411Info_CallbackFunctionPointer(c411StatusDefinition, Mock.vLaserDataGetCan411Info_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(c411StatusDefinition, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)c411StatusDefinition, (void*)cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Val,
      cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserDataGetCan411Info(CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance, c411StatusDefinition_t* c411StatusDefinition, int c411StatusDefinition_Depth);
void CMockExpectParameters_vLaserDataGetCan411Info(CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance, c411StatusDefinition_t* c411StatusDefinition, int c411StatusDefinition_Depth)
{
  cmock_call_instance->Expected_c411StatusDefinition = c411StatusDefinition;
  cmock_call_instance->Expected_c411StatusDefinition_Depth = c411StatusDefinition_Depth;
  cmock_call_instance->IgnoreArg_c411StatusDefinition = 0;
  cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Used = 0;
}

void vLaserDataGetCan411Info_CMockIgnore(void)
{
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)1;
}

void vLaserDataGetCan411Info_CMockStopIgnore(void)
{
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)0;
}

void vLaserDataGetCan411Info_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan411Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan411Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserDataGetCan411Info_CMockExpect(UNITY_LINE_TYPE cmock_line, c411StatusDefinition_t* c411StatusDefinition)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan411Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan411Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan411Info(cmock_call_instance, c411StatusDefinition, 1);
}

void vLaserDataGetCan411Info_AddCallback(CMOCK_vLaserDataGetCan411Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan411Info_CallbackBool = (char)1;
  Mock.vLaserDataGetCan411Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan411Info_Stub(CMOCK_vLaserDataGetCan411Info_CALLBACK Callback)
{
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)0;
  Mock.vLaserDataGetCan411Info_CallbackBool = (char)0;
  Mock.vLaserDataGetCan411Info_CallbackFunctionPointer = Callback;
}

void vLaserDataGetCan411Info_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, c411StatusDefinition_t* c411StatusDefinition, int c411StatusDefinition_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE));
  CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserDataGetCan411Info_CallInstance = CMock_Guts_MemChain(Mock.vLaserDataGetCan411Info_CallInstance, cmock_guts_index);
  Mock.vLaserDataGetCan411Info_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserDataGetCan411Info(cmock_call_instance, c411StatusDefinition, c411StatusDefinition_Depth);
}

void vLaserDataGetCan411Info_CMockReturnMemThruPtr_c411StatusDefinition(UNITY_LINE_TYPE cmock_line, c411StatusDefinition_t* c411StatusDefinition, size_t cmock_size)
{
  CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan411Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Used = 1;
  cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Val = c411StatusDefinition;
  cmock_call_instance->ReturnThruPtr_c411StatusDefinition_Size = cmock_size;
}

void vLaserDataGetCan411Info_CMockIgnoreArg_c411StatusDefinition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserDataGetCan411Info_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserDataGetCan411Info_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_c411StatusDefinition = 1;
}

void vUpdateCommonNvmMemory(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateCommonNvmMemory);
  cmock_call_instance = (CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateCommonNvmMemory_CallInstance);
  Mock.vUpdateCommonNvmMemory_CallInstance = CMock_Guts_MemNext(Mock.vUpdateCommonNvmMemory_CallInstance);
  if (Mock.vUpdateCommonNvmMemory_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateCommonNvmMemory_CallbackBool &&
      Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer(Mock.vUpdateCommonNvmMemory_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer(Mock.vUpdateCommonNvmMemory_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vUpdateCommonNvmMemory_CMockIgnore(void)
{
  Mock.vUpdateCommonNvmMemory_IgnoreBool = (char)1;
}

void vUpdateCommonNvmMemory_CMockStopIgnore(void)
{
  Mock.vUpdateCommonNvmMemory_IgnoreBool = (char)0;
}

void vUpdateCommonNvmMemory_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE));
  CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateCommonNvmMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateCommonNvmMemory_CallInstance = CMock_Guts_MemChain(Mock.vUpdateCommonNvmMemory_CallInstance, cmock_guts_index);
  Mock.vUpdateCommonNvmMemory_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vUpdateCommonNvmMemory_AddCallback(CMOCK_vUpdateCommonNvmMemory_CALLBACK Callback)
{
  Mock.vUpdateCommonNvmMemory_IgnoreBool = (char)0;
  Mock.vUpdateCommonNvmMemory_CallbackBool = (char)1;
  Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer = Callback;
}

void vUpdateCommonNvmMemory_Stub(CMOCK_vUpdateCommonNvmMemory_CALLBACK Callback)
{
  Mock.vUpdateCommonNvmMemory_IgnoreBool = (char)0;
  Mock.vUpdateCommonNvmMemory_CallbackBool = (char)0;
  Mock.vUpdateCommonNvmMemory_CallbackFunctionPointer = Callback;
}

void vUpdateLnaNvmMemory(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateLnaNvmMemory);
  cmock_call_instance = (CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateLnaNvmMemory_CallInstance);
  Mock.vUpdateLnaNvmMemory_CallInstance = CMock_Guts_MemNext(Mock.vUpdateLnaNvmMemory_CallInstance);
  if (Mock.vUpdateLnaNvmMemory_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateLnaNvmMemory_CallbackBool &&
      Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer(Mock.vUpdateLnaNvmMemory_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer(Mock.vUpdateLnaNvmMemory_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vUpdateLnaNvmMemory_CMockIgnore(void)
{
  Mock.vUpdateLnaNvmMemory_IgnoreBool = (char)1;
}

void vUpdateLnaNvmMemory_CMockStopIgnore(void)
{
  Mock.vUpdateLnaNvmMemory_IgnoreBool = (char)0;
}

void vUpdateLnaNvmMemory_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE));
  CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateLnaNvmMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateLnaNvmMemory_CallInstance = CMock_Guts_MemChain(Mock.vUpdateLnaNvmMemory_CallInstance, cmock_guts_index);
  Mock.vUpdateLnaNvmMemory_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vUpdateLnaNvmMemory_AddCallback(CMOCK_vUpdateLnaNvmMemory_CALLBACK Callback)
{
  Mock.vUpdateLnaNvmMemory_IgnoreBool = (char)0;
  Mock.vUpdateLnaNvmMemory_CallbackBool = (char)1;
  Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer = Callback;
}

void vUpdateLnaNvmMemory_Stub(CMOCK_vUpdateLnaNvmMemory_CALLBACK Callback)
{
  Mock.vUpdateLnaNvmMemory_IgnoreBool = (char)0;
  Mock.vUpdateLnaNvmMemory_CallbackBool = (char)0;
  Mock.vUpdateLnaNvmMemory_CallbackFunctionPointer = Callback;
}

void vUpdateBoostNvmMemory(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateBoostNvmMemory);
  cmock_call_instance = (CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateBoostNvmMemory_CallInstance);
  Mock.vUpdateBoostNvmMemory_CallInstance = CMock_Guts_MemNext(Mock.vUpdateBoostNvmMemory_CallInstance);
  if (Mock.vUpdateBoostNvmMemory_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateBoostNvmMemory_CallbackBool &&
      Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer(Mock.vUpdateBoostNvmMemory_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer(Mock.vUpdateBoostNvmMemory_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vUpdateBoostNvmMemory_CMockIgnore(void)
{
  Mock.vUpdateBoostNvmMemory_IgnoreBool = (char)1;
}

void vUpdateBoostNvmMemory_CMockStopIgnore(void)
{
  Mock.vUpdateBoostNvmMemory_IgnoreBool = (char)0;
}

void vUpdateBoostNvmMemory_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE));
  CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateBoostNvmMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateBoostNvmMemory_CallInstance = CMock_Guts_MemChain(Mock.vUpdateBoostNvmMemory_CallInstance, cmock_guts_index);
  Mock.vUpdateBoostNvmMemory_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vUpdateBoostNvmMemory_AddCallback(CMOCK_vUpdateBoostNvmMemory_CALLBACK Callback)
{
  Mock.vUpdateBoostNvmMemory_IgnoreBool = (char)0;
  Mock.vUpdateBoostNvmMemory_CallbackBool = (char)1;
  Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer = Callback;
}

void vUpdateBoostNvmMemory_Stub(CMOCK_vUpdateBoostNvmMemory_CALLBACK Callback)
{
  Mock.vUpdateBoostNvmMemory_IgnoreBool = (char)0;
  Mock.vUpdateBoostNvmMemory_CallbackBool = (char)0;
  Mock.vUpdateBoostNvmMemory_CallbackFunctionPointer = Callback;
}

void vUpdateConfigInfo(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateConfigInfo_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateConfigInfo);
  cmock_call_instance = (CMOCK_vUpdateConfigInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateConfigInfo_CallInstance);
  Mock.vUpdateConfigInfo_CallInstance = CMock_Guts_MemNext(Mock.vUpdateConfigInfo_CallInstance);
  if (Mock.vUpdateConfigInfo_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateConfigInfo_CallbackBool &&
      Mock.vUpdateConfigInfo_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateConfigInfo_CallbackFunctionPointer(Mock.vUpdateConfigInfo_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vUpdateConfigInfo_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateConfigInfo_CallbackFunctionPointer(Mock.vUpdateConfigInfo_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vUpdateConfigInfo_CMockIgnore(void)
{
  Mock.vUpdateConfigInfo_IgnoreBool = (char)1;
}

void vUpdateConfigInfo_CMockStopIgnore(void)
{
  Mock.vUpdateConfigInfo_IgnoreBool = (char)0;
}

void vUpdateConfigInfo_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateConfigInfo_CALL_INSTANCE));
  CMOCK_vUpdateConfigInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateConfigInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateConfigInfo_CallInstance = CMock_Guts_MemChain(Mock.vUpdateConfigInfo_CallInstance, cmock_guts_index);
  Mock.vUpdateConfigInfo_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vUpdateConfigInfo_AddCallback(CMOCK_vUpdateConfigInfo_CALLBACK Callback)
{
  Mock.vUpdateConfigInfo_IgnoreBool = (char)0;
  Mock.vUpdateConfigInfo_CallbackBool = (char)1;
  Mock.vUpdateConfigInfo_CallbackFunctionPointer = Callback;
}

void vUpdateConfigInfo_Stub(CMOCK_vUpdateConfigInfo_CALLBACK Callback)
{
  Mock.vUpdateConfigInfo_IgnoreBool = (char)0;
  Mock.vUpdateConfigInfo_CallbackBool = (char)0;
  Mock.vUpdateConfigInfo_CallbackFunctionPointer = Callback;
}

eBool_t bInitCommonMemoryImageFromNvm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bInitCommonMemoryImageFromNvm);
  cmock_call_instance = (CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bInitCommonMemoryImageFromNvm_CallInstance);
  Mock.bInitCommonMemoryImageFromNvm_CallInstance = CMock_Guts_MemNext(Mock.bInitCommonMemoryImageFromNvm_CallInstance);
  if (Mock.bInitCommonMemoryImageFromNvm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bInitCommonMemoryImageFromNvm_FinalReturn;
    memcpy((void*)(&Mock.bInitCommonMemoryImageFromNvm_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bInitCommonMemoryImageFromNvm_CallbackBool &&
      Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer(Mock.bInitCommonMemoryImageFromNvm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer(Mock.bInitCommonMemoryImageFromNvm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void bInitCommonMemoryImageFromNvm_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE));
  CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bInitCommonMemoryImageFromNvm_CallInstance = CMock_Guts_MemChain(Mock.bInitCommonMemoryImageFromNvm_CallInstance, cmock_guts_index);
  Mock.bInitCommonMemoryImageFromNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bInitCommonMemoryImageFromNvm_IgnoreBool = (char)1;
}

void bInitCommonMemoryImageFromNvm_CMockStopIgnore(void)
{
  if(Mock.bInitCommonMemoryImageFromNvm_IgnoreBool)
    Mock.bInitCommonMemoryImageFromNvm_CallInstance = CMock_Guts_MemNext(Mock.bInitCommonMemoryImageFromNvm_CallInstance);
  Mock.bInitCommonMemoryImageFromNvm_IgnoreBool = (char)0;
}

void bInitCommonMemoryImageFromNvm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE));
  CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_bInitCommonMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bInitCommonMemoryImageFromNvm_CallInstance = CMock_Guts_MemChain(Mock.bInitCommonMemoryImageFromNvm_CallInstance, cmock_guts_index);
  Mock.bInitCommonMemoryImageFromNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bInitCommonMemoryImageFromNvm_AddCallback(CMOCK_bInitCommonMemoryImageFromNvm_CALLBACK Callback)
{
  Mock.bInitCommonMemoryImageFromNvm_IgnoreBool = (char)0;
  Mock.bInitCommonMemoryImageFromNvm_CallbackBool = (char)1;
  Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer = Callback;
}

void bInitCommonMemoryImageFromNvm_Stub(CMOCK_bInitCommonMemoryImageFromNvm_CALLBACK Callback)
{
  Mock.bInitCommonMemoryImageFromNvm_IgnoreBool = (char)0;
  Mock.bInitCommonMemoryImageFromNvm_CallbackBool = (char)0;
  Mock.bInitCommonMemoryImageFromNvm_CallbackFunctionPointer = Callback;
}

eBool_t bInitLnaMemoryImageFromNvm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bInitLnaMemoryImageFromNvm);
  cmock_call_instance = (CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bInitLnaMemoryImageFromNvm_CallInstance);
  Mock.bInitLnaMemoryImageFromNvm_CallInstance = CMock_Guts_MemNext(Mock.bInitLnaMemoryImageFromNvm_CallInstance);
  if (Mock.bInitLnaMemoryImageFromNvm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bInitLnaMemoryImageFromNvm_FinalReturn;
    memcpy((void*)(&Mock.bInitLnaMemoryImageFromNvm_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bInitLnaMemoryImageFromNvm_CallbackBool &&
      Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer(Mock.bInitLnaMemoryImageFromNvm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer(Mock.bInitLnaMemoryImageFromNvm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void bInitLnaMemoryImageFromNvm_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE));
  CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bInitLnaMemoryImageFromNvm_CallInstance = CMock_Guts_MemChain(Mock.bInitLnaMemoryImageFromNvm_CallInstance, cmock_guts_index);
  Mock.bInitLnaMemoryImageFromNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bInitLnaMemoryImageFromNvm_IgnoreBool = (char)1;
}

void bInitLnaMemoryImageFromNvm_CMockStopIgnore(void)
{
  if(Mock.bInitLnaMemoryImageFromNvm_IgnoreBool)
    Mock.bInitLnaMemoryImageFromNvm_CallInstance = CMock_Guts_MemNext(Mock.bInitLnaMemoryImageFromNvm_CallInstance);
  Mock.bInitLnaMemoryImageFromNvm_IgnoreBool = (char)0;
}

void bInitLnaMemoryImageFromNvm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE));
  CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_bInitLnaMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bInitLnaMemoryImageFromNvm_CallInstance = CMock_Guts_MemChain(Mock.bInitLnaMemoryImageFromNvm_CallInstance, cmock_guts_index);
  Mock.bInitLnaMemoryImageFromNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bInitLnaMemoryImageFromNvm_AddCallback(CMOCK_bInitLnaMemoryImageFromNvm_CALLBACK Callback)
{
  Mock.bInitLnaMemoryImageFromNvm_IgnoreBool = (char)0;
  Mock.bInitLnaMemoryImageFromNvm_CallbackBool = (char)1;
  Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer = Callback;
}

void bInitLnaMemoryImageFromNvm_Stub(CMOCK_bInitLnaMemoryImageFromNvm_CALLBACK Callback)
{
  Mock.bInitLnaMemoryImageFromNvm_IgnoreBool = (char)0;
  Mock.bInitLnaMemoryImageFromNvm_CallbackBool = (char)0;
  Mock.bInitLnaMemoryImageFromNvm_CallbackFunctionPointer = Callback;
}

eBool_t bInitBoostMemoryImageFromNvm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bInitBoostMemoryImageFromNvm);
  cmock_call_instance = (CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bInitBoostMemoryImageFromNvm_CallInstance);
  Mock.bInitBoostMemoryImageFromNvm_CallInstance = CMock_Guts_MemNext(Mock.bInitBoostMemoryImageFromNvm_CallInstance);
  if (Mock.bInitBoostMemoryImageFromNvm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bInitBoostMemoryImageFromNvm_FinalReturn;
    memcpy((void*)(&Mock.bInitBoostMemoryImageFromNvm_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bInitBoostMemoryImageFromNvm_CallbackBool &&
      Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer(Mock.bInitBoostMemoryImageFromNvm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer(Mock.bInitBoostMemoryImageFromNvm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void bInitBoostMemoryImageFromNvm_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE));
  CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bInitBoostMemoryImageFromNvm_CallInstance = CMock_Guts_MemChain(Mock.bInitBoostMemoryImageFromNvm_CallInstance, cmock_guts_index);
  Mock.bInitBoostMemoryImageFromNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bInitBoostMemoryImageFromNvm_IgnoreBool = (char)1;
}

void bInitBoostMemoryImageFromNvm_CMockStopIgnore(void)
{
  if(Mock.bInitBoostMemoryImageFromNvm_IgnoreBool)
    Mock.bInitBoostMemoryImageFromNvm_CallInstance = CMock_Guts_MemNext(Mock.bInitBoostMemoryImageFromNvm_CallInstance);
  Mock.bInitBoostMemoryImageFromNvm_IgnoreBool = (char)0;
}

void bInitBoostMemoryImageFromNvm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE));
  CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_bInitBoostMemoryImageFromNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bInitBoostMemoryImageFromNvm_CallInstance = CMock_Guts_MemChain(Mock.bInitBoostMemoryImageFromNvm_CallInstance, cmock_guts_index);
  Mock.bInitBoostMemoryImageFromNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bInitBoostMemoryImageFromNvm_AddCallback(CMOCK_bInitBoostMemoryImageFromNvm_CALLBACK Callback)
{
  Mock.bInitBoostMemoryImageFromNvm_IgnoreBool = (char)0;
  Mock.bInitBoostMemoryImageFromNvm_CallbackBool = (char)1;
  Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer = Callback;
}

void bInitBoostMemoryImageFromNvm_Stub(CMOCK_bInitBoostMemoryImageFromNvm_CALLBACK Callback)
{
  Mock.bInitBoostMemoryImageFromNvm_IgnoreBool = (char)0;
  Mock.bInitBoostMemoryImageFromNvm_CallbackBool = (char)0;
  Mock.bInitBoostMemoryImageFromNvm_CallbackFunctionPointer = Callback;
}

xPidValues_t* getLnaPidValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_getLnaPidValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_getLnaPidValues);
  cmock_call_instance = (CMOCK_getLnaPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.getLnaPidValues_CallInstance);
  Mock.getLnaPidValues_CallInstance = CMock_Guts_MemNext(Mock.getLnaPidValues_CallInstance);
  if (Mock.getLnaPidValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.getLnaPidValues_FinalReturn;
    Mock.getLnaPidValues_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.getLnaPidValues_CallbackBool &&
      Mock.getLnaPidValues_CallbackFunctionPointer != NULL)
  {
    xPidValues_t* cmock_cb_ret = Mock.getLnaPidValues_CallbackFunctionPointer(Mock.getLnaPidValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.getLnaPidValues_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.getLnaPidValues_CallbackFunctionPointer(Mock.getLnaPidValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void getLnaPidValues_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xPidValues_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getLnaPidValues_CALL_INSTANCE));
  CMOCK_getLnaPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_getLnaPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getLnaPidValues_CallInstance = CMock_Guts_MemChain(Mock.getLnaPidValues_CallInstance, cmock_guts_index);
  Mock.getLnaPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.getLnaPidValues_IgnoreBool = (char)1;
}

void getLnaPidValues_CMockStopIgnore(void)
{
  if(Mock.getLnaPidValues_IgnoreBool)
    Mock.getLnaPidValues_CallInstance = CMock_Guts_MemNext(Mock.getLnaPidValues_CallInstance);
  Mock.getLnaPidValues_IgnoreBool = (char)0;
}

void getLnaPidValues_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xPidValues_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getLnaPidValues_CALL_INSTANCE));
  CMOCK_getLnaPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_getLnaPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getLnaPidValues_CallInstance = CMock_Guts_MemChain(Mock.getLnaPidValues_CallInstance, cmock_guts_index);
  Mock.getLnaPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void getLnaPidValues_AddCallback(CMOCK_getLnaPidValues_CALLBACK Callback)
{
  Mock.getLnaPidValues_IgnoreBool = (char)0;
  Mock.getLnaPidValues_CallbackBool = (char)1;
  Mock.getLnaPidValues_CallbackFunctionPointer = Callback;
}

void getLnaPidValues_Stub(CMOCK_getLnaPidValues_CALLBACK Callback)
{
  Mock.getLnaPidValues_IgnoreBool = (char)0;
  Mock.getLnaPidValues_CallbackBool = (char)0;
  Mock.getLnaPidValues_CallbackFunctionPointer = Callback;
}

void setLnaPidProportionalValue(float fPvalue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setLnaPidProportionalValue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setLnaPidProportionalValue);
  cmock_call_instance = (CMOCK_setLnaPidProportionalValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setLnaPidProportionalValue_CallInstance);
  Mock.setLnaPidProportionalValue_CallInstance = CMock_Guts_MemNext(Mock.setLnaPidProportionalValue_CallInstance);
  if (Mock.setLnaPidProportionalValue_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.setLnaPidProportionalValue_CallbackBool &&
      Mock.setLnaPidProportionalValue_CallbackFunctionPointer != NULL)
  {
    Mock.setLnaPidProportionalValue_CallbackFunctionPointer(fPvalue, Mock.setLnaPidProportionalValue_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fPvalue)
  {
    UNITY_SET_DETAILS(CMockString_setLnaPidProportionalValue,CMockString_fPvalue);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fPvalue, fPvalue, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.setLnaPidProportionalValue_CallbackFunctionPointer != NULL)
  {
    Mock.setLnaPidProportionalValue_CallbackFunctionPointer(fPvalue, Mock.setLnaPidProportionalValue_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_setLnaPidProportionalValue(CMOCK_setLnaPidProportionalValue_CALL_INSTANCE* cmock_call_instance, float fPvalue);
void CMockExpectParameters_setLnaPidProportionalValue(CMOCK_setLnaPidProportionalValue_CALL_INSTANCE* cmock_call_instance, float fPvalue)
{
  cmock_call_instance->Expected_fPvalue = fPvalue;
  cmock_call_instance->IgnoreArg_fPvalue = 0;
}

void setLnaPidProportionalValue_CMockIgnore(void)
{
  Mock.setLnaPidProportionalValue_IgnoreBool = (char)1;
}

void setLnaPidProportionalValue_CMockStopIgnore(void)
{
  Mock.setLnaPidProportionalValue_IgnoreBool = (char)0;
}

void setLnaPidProportionalValue_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setLnaPidProportionalValue_CALL_INSTANCE));
  CMOCK_setLnaPidProportionalValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidProportionalValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setLnaPidProportionalValue_CallInstance = CMock_Guts_MemChain(Mock.setLnaPidProportionalValue_CallInstance, cmock_guts_index);
  Mock.setLnaPidProportionalValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void setLnaPidProportionalValue_CMockExpect(UNITY_LINE_TYPE cmock_line, float fPvalue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setLnaPidProportionalValue_CALL_INSTANCE));
  CMOCK_setLnaPidProportionalValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidProportionalValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setLnaPidProportionalValue_CallInstance = CMock_Guts_MemChain(Mock.setLnaPidProportionalValue_CallInstance, cmock_guts_index);
  Mock.setLnaPidProportionalValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_setLnaPidProportionalValue(cmock_call_instance, fPvalue);
}

void setLnaPidProportionalValue_AddCallback(CMOCK_setLnaPidProportionalValue_CALLBACK Callback)
{
  Mock.setLnaPidProportionalValue_IgnoreBool = (char)0;
  Mock.setLnaPidProportionalValue_CallbackBool = (char)1;
  Mock.setLnaPidProportionalValue_CallbackFunctionPointer = Callback;
}

void setLnaPidProportionalValue_Stub(CMOCK_setLnaPidProportionalValue_CALLBACK Callback)
{
  Mock.setLnaPidProportionalValue_IgnoreBool = (char)0;
  Mock.setLnaPidProportionalValue_CallbackBool = (char)0;
  Mock.setLnaPidProportionalValue_CallbackFunctionPointer = Callback;
}

void setLnaPidProportionalValue_CMockIgnoreArg_fPvalue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_setLnaPidProportionalValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidProportionalValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.setLnaPidProportionalValue_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fPvalue = 1;
}

void setLnaPidIntegralValue(float fPvalue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setLnaPidIntegralValue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setLnaPidIntegralValue);
  cmock_call_instance = (CMOCK_setLnaPidIntegralValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setLnaPidIntegralValue_CallInstance);
  Mock.setLnaPidIntegralValue_CallInstance = CMock_Guts_MemNext(Mock.setLnaPidIntegralValue_CallInstance);
  if (Mock.setLnaPidIntegralValue_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.setLnaPidIntegralValue_CallbackBool &&
      Mock.setLnaPidIntegralValue_CallbackFunctionPointer != NULL)
  {
    Mock.setLnaPidIntegralValue_CallbackFunctionPointer(fPvalue, Mock.setLnaPidIntegralValue_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fPvalue)
  {
    UNITY_SET_DETAILS(CMockString_setLnaPidIntegralValue,CMockString_fPvalue);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fPvalue, fPvalue, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.setLnaPidIntegralValue_CallbackFunctionPointer != NULL)
  {
    Mock.setLnaPidIntegralValue_CallbackFunctionPointer(fPvalue, Mock.setLnaPidIntegralValue_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_setLnaPidIntegralValue(CMOCK_setLnaPidIntegralValue_CALL_INSTANCE* cmock_call_instance, float fPvalue);
void CMockExpectParameters_setLnaPidIntegralValue(CMOCK_setLnaPidIntegralValue_CALL_INSTANCE* cmock_call_instance, float fPvalue)
{
  cmock_call_instance->Expected_fPvalue = fPvalue;
  cmock_call_instance->IgnoreArg_fPvalue = 0;
}

void setLnaPidIntegralValue_CMockIgnore(void)
{
  Mock.setLnaPidIntegralValue_IgnoreBool = (char)1;
}

void setLnaPidIntegralValue_CMockStopIgnore(void)
{
  Mock.setLnaPidIntegralValue_IgnoreBool = (char)0;
}

void setLnaPidIntegralValue_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setLnaPidIntegralValue_CALL_INSTANCE));
  CMOCK_setLnaPidIntegralValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidIntegralValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setLnaPidIntegralValue_CallInstance = CMock_Guts_MemChain(Mock.setLnaPidIntegralValue_CallInstance, cmock_guts_index);
  Mock.setLnaPidIntegralValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void setLnaPidIntegralValue_CMockExpect(UNITY_LINE_TYPE cmock_line, float fPvalue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setLnaPidIntegralValue_CALL_INSTANCE));
  CMOCK_setLnaPidIntegralValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidIntegralValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setLnaPidIntegralValue_CallInstance = CMock_Guts_MemChain(Mock.setLnaPidIntegralValue_CallInstance, cmock_guts_index);
  Mock.setLnaPidIntegralValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_setLnaPidIntegralValue(cmock_call_instance, fPvalue);
}

void setLnaPidIntegralValue_AddCallback(CMOCK_setLnaPidIntegralValue_CALLBACK Callback)
{
  Mock.setLnaPidIntegralValue_IgnoreBool = (char)0;
  Mock.setLnaPidIntegralValue_CallbackBool = (char)1;
  Mock.setLnaPidIntegralValue_CallbackFunctionPointer = Callback;
}

void setLnaPidIntegralValue_Stub(CMOCK_setLnaPidIntegralValue_CALLBACK Callback)
{
  Mock.setLnaPidIntegralValue_IgnoreBool = (char)0;
  Mock.setLnaPidIntegralValue_CallbackBool = (char)0;
  Mock.setLnaPidIntegralValue_CallbackFunctionPointer = Callback;
}

void setLnaPidIntegralValue_CMockIgnoreArg_fPvalue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_setLnaPidIntegralValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidIntegralValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.setLnaPidIntegralValue_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fPvalue = 1;
}

void setLnaPidDerivativeValue(float fPvalue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setLnaPidDerivativeValue);
  cmock_call_instance = (CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setLnaPidDerivativeValue_CallInstance);
  Mock.setLnaPidDerivativeValue_CallInstance = CMock_Guts_MemNext(Mock.setLnaPidDerivativeValue_CallInstance);
  if (Mock.setLnaPidDerivativeValue_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.setLnaPidDerivativeValue_CallbackBool &&
      Mock.setLnaPidDerivativeValue_CallbackFunctionPointer != NULL)
  {
    Mock.setLnaPidDerivativeValue_CallbackFunctionPointer(fPvalue, Mock.setLnaPidDerivativeValue_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fPvalue)
  {
    UNITY_SET_DETAILS(CMockString_setLnaPidDerivativeValue,CMockString_fPvalue);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fPvalue, fPvalue, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.setLnaPidDerivativeValue_CallbackFunctionPointer != NULL)
  {
    Mock.setLnaPidDerivativeValue_CallbackFunctionPointer(fPvalue, Mock.setLnaPidDerivativeValue_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_setLnaPidDerivativeValue(CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE* cmock_call_instance, float fPvalue);
void CMockExpectParameters_setLnaPidDerivativeValue(CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE* cmock_call_instance, float fPvalue)
{
  cmock_call_instance->Expected_fPvalue = fPvalue;
  cmock_call_instance->IgnoreArg_fPvalue = 0;
}

void setLnaPidDerivativeValue_CMockIgnore(void)
{
  Mock.setLnaPidDerivativeValue_IgnoreBool = (char)1;
}

void setLnaPidDerivativeValue_CMockStopIgnore(void)
{
  Mock.setLnaPidDerivativeValue_IgnoreBool = (char)0;
}

void setLnaPidDerivativeValue_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE));
  CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setLnaPidDerivativeValue_CallInstance = CMock_Guts_MemChain(Mock.setLnaPidDerivativeValue_CallInstance, cmock_guts_index);
  Mock.setLnaPidDerivativeValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void setLnaPidDerivativeValue_CMockExpect(UNITY_LINE_TYPE cmock_line, float fPvalue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE));
  CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setLnaPidDerivativeValue_CallInstance = CMock_Guts_MemChain(Mock.setLnaPidDerivativeValue_CallInstance, cmock_guts_index);
  Mock.setLnaPidDerivativeValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_setLnaPidDerivativeValue(cmock_call_instance, fPvalue);
}

void setLnaPidDerivativeValue_AddCallback(CMOCK_setLnaPidDerivativeValue_CALLBACK Callback)
{
  Mock.setLnaPidDerivativeValue_IgnoreBool = (char)0;
  Mock.setLnaPidDerivativeValue_CallbackBool = (char)1;
  Mock.setLnaPidDerivativeValue_CallbackFunctionPointer = Callback;
}

void setLnaPidDerivativeValue_Stub(CMOCK_setLnaPidDerivativeValue_CALLBACK Callback)
{
  Mock.setLnaPidDerivativeValue_IgnoreBool = (char)0;
  Mock.setLnaPidDerivativeValue_CallbackBool = (char)0;
  Mock.setLnaPidDerivativeValue_CallbackFunctionPointer = Callback;
}

void setLnaPidDerivativeValue_CMockIgnoreArg_fPvalue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_setLnaPidDerivativeValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.setLnaPidDerivativeValue_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fPvalue = 1;
}

uint8_t cGetresetCause(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_cGetresetCause_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_cGetresetCause);
  cmock_call_instance = (CMOCK_cGetresetCause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.cGetresetCause_CallInstance);
  Mock.cGetresetCause_CallInstance = CMock_Guts_MemNext(Mock.cGetresetCause_CallInstance);
  if (Mock.cGetresetCause_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.cGetresetCause_FinalReturn;
    Mock.cGetresetCause_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.cGetresetCause_CallbackBool &&
      Mock.cGetresetCause_CallbackFunctionPointer != NULL)
  {
    uint8_t cmock_cb_ret = Mock.cGetresetCause_CallbackFunctionPointer(Mock.cGetresetCause_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.cGetresetCause_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.cGetresetCause_CallbackFunctionPointer(Mock.cGetresetCause_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void cGetresetCause_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cGetresetCause_CALL_INSTANCE));
  CMOCK_cGetresetCause_CALL_INSTANCE* cmock_call_instance = (CMOCK_cGetresetCause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.cGetresetCause_CallInstance = CMock_Guts_MemChain(Mock.cGetresetCause_CallInstance, cmock_guts_index);
  Mock.cGetresetCause_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.cGetresetCause_IgnoreBool = (char)1;
}

void cGetresetCause_CMockStopIgnore(void)
{
  if(Mock.cGetresetCause_IgnoreBool)
    Mock.cGetresetCause_CallInstance = CMock_Guts_MemNext(Mock.cGetresetCause_CallInstance);
  Mock.cGetresetCause_IgnoreBool = (char)0;
}

void cGetresetCause_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cGetresetCause_CALL_INSTANCE));
  CMOCK_cGetresetCause_CALL_INSTANCE* cmock_call_instance = (CMOCK_cGetresetCause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.cGetresetCause_CallInstance = CMock_Guts_MemChain(Mock.cGetresetCause_CallInstance, cmock_guts_index);
  Mock.cGetresetCause_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void cGetresetCause_AddCallback(CMOCK_cGetresetCause_CALLBACK Callback)
{
  Mock.cGetresetCause_IgnoreBool = (char)0;
  Mock.cGetresetCause_CallbackBool = (char)1;
  Mock.cGetresetCause_CallbackFunctionPointer = Callback;
}

void cGetresetCause_Stub(CMOCK_cGetresetCause_CALLBACK Callback)
{
  Mock.cGetresetCause_IgnoreBool = (char)0;
  Mock.cGetresetCause_CallbackBool = (char)0;
  Mock.cGetresetCause_CallbackFunctionPointer = Callback;
}

void setInternalCriticalErrorFlag(eBool_t value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setInternalCriticalErrorFlag);
  cmock_call_instance = (CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setInternalCriticalErrorFlag_CallInstance);
  Mock.setInternalCriticalErrorFlag_CallInstance = CMock_Guts_MemNext(Mock.setInternalCriticalErrorFlag_CallInstance);
  if (Mock.setInternalCriticalErrorFlag_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.setInternalCriticalErrorFlag_CallbackBool &&
      Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer != NULL)
  {
    Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer(value, Mock.setInternalCriticalErrorFlag_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_value)
  {
    UNITY_SET_DETAILS(CMockString_setInternalCriticalErrorFlag,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_value), (void*)(&value), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer != NULL)
  {
    Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer(value, Mock.setInternalCriticalErrorFlag_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_setInternalCriticalErrorFlag(CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE* cmock_call_instance, eBool_t value);
void CMockExpectParameters_setInternalCriticalErrorFlag(CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE* cmock_call_instance, eBool_t value)
{
  memcpy((void*)(&cmock_call_instance->Expected_value), (void*)(&value),
         sizeof(eBool_t[sizeof(value) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_value = 0;
}

void setInternalCriticalErrorFlag_CMockIgnore(void)
{
  Mock.setInternalCriticalErrorFlag_IgnoreBool = (char)1;
}

void setInternalCriticalErrorFlag_CMockStopIgnore(void)
{
  Mock.setInternalCriticalErrorFlag_IgnoreBool = (char)0;
}

void setInternalCriticalErrorFlag_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE));
  CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE* cmock_call_instance = (CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setInternalCriticalErrorFlag_CallInstance = CMock_Guts_MemChain(Mock.setInternalCriticalErrorFlag_CallInstance, cmock_guts_index);
  Mock.setInternalCriticalErrorFlag_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void setInternalCriticalErrorFlag_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t value)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE));
  CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE* cmock_call_instance = (CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setInternalCriticalErrorFlag_CallInstance = CMock_Guts_MemChain(Mock.setInternalCriticalErrorFlag_CallInstance, cmock_guts_index);
  Mock.setInternalCriticalErrorFlag_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_setInternalCriticalErrorFlag(cmock_call_instance, value);
}

void setInternalCriticalErrorFlag_AddCallback(CMOCK_setInternalCriticalErrorFlag_CALLBACK Callback)
{
  Mock.setInternalCriticalErrorFlag_IgnoreBool = (char)0;
  Mock.setInternalCriticalErrorFlag_CallbackBool = (char)1;
  Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer = Callback;
}

void setInternalCriticalErrorFlag_Stub(CMOCK_setInternalCriticalErrorFlag_CALLBACK Callback)
{
  Mock.setInternalCriticalErrorFlag_IgnoreBool = (char)0;
  Mock.setInternalCriticalErrorFlag_CallbackBool = (char)0;
  Mock.setInternalCriticalErrorFlag_CallbackFunctionPointer = Callback;
}

void setInternalCriticalErrorFlag_CMockIgnoreArg_value(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE* cmock_call_instance = (CMOCK_setInternalCriticalErrorFlag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.setInternalCriticalErrorFlag_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_value = 1;
}

void vInitWithFullResetRequest(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vInitWithFullResetRequest_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vInitWithFullResetRequest);
  cmock_call_instance = (CMOCK_vInitWithFullResetRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vInitWithFullResetRequest_CallInstance);
  Mock.vInitWithFullResetRequest_CallInstance = CMock_Guts_MemNext(Mock.vInitWithFullResetRequest_CallInstance);
  if (Mock.vInitWithFullResetRequest_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vInitWithFullResetRequest_CallbackBool &&
      Mock.vInitWithFullResetRequest_CallbackFunctionPointer != NULL)
  {
    Mock.vInitWithFullResetRequest_CallbackFunctionPointer(Mock.vInitWithFullResetRequest_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vInitWithFullResetRequest_CallbackFunctionPointer != NULL)
  {
    Mock.vInitWithFullResetRequest_CallbackFunctionPointer(Mock.vInitWithFullResetRequest_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vInitWithFullResetRequest_CMockIgnore(void)
{
  Mock.vInitWithFullResetRequest_IgnoreBool = (char)1;
}

void vInitWithFullResetRequest_CMockStopIgnore(void)
{
  Mock.vInitWithFullResetRequest_IgnoreBool = (char)0;
}

void vInitWithFullResetRequest_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vInitWithFullResetRequest_CALL_INSTANCE));
  CMOCK_vInitWithFullResetRequest_CALL_INSTANCE* cmock_call_instance = (CMOCK_vInitWithFullResetRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vInitWithFullResetRequest_CallInstance = CMock_Guts_MemChain(Mock.vInitWithFullResetRequest_CallInstance, cmock_guts_index);
  Mock.vInitWithFullResetRequest_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vInitWithFullResetRequest_AddCallback(CMOCK_vInitWithFullResetRequest_CALLBACK Callback)
{
  Mock.vInitWithFullResetRequest_IgnoreBool = (char)0;
  Mock.vInitWithFullResetRequest_CallbackBool = (char)1;
  Mock.vInitWithFullResetRequest_CallbackFunctionPointer = Callback;
}

void vInitWithFullResetRequest_Stub(CMOCK_vInitWithFullResetRequest_CALLBACK Callback)
{
  Mock.vInitWithFullResetRequest_IgnoreBool = (char)0;
  Mock.vInitWithFullResetRequest_CallbackBool = (char)0;
  Mock.vInitWithFullResetRequest_CallbackFunctionPointer = Callback;
}

void vIncreaseSpiAdcErrors(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vIncreaseSpiAdcErrors);
  cmock_call_instance = (CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vIncreaseSpiAdcErrors_CallInstance);
  Mock.vIncreaseSpiAdcErrors_CallInstance = CMock_Guts_MemNext(Mock.vIncreaseSpiAdcErrors_CallInstance);
  if (Mock.vIncreaseSpiAdcErrors_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vIncreaseSpiAdcErrors_CallbackBool &&
      Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer(Mock.vIncreaseSpiAdcErrors_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer(Mock.vIncreaseSpiAdcErrors_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vIncreaseSpiAdcErrors_CMockIgnore(void)
{
  Mock.vIncreaseSpiAdcErrors_IgnoreBool = (char)1;
}

void vIncreaseSpiAdcErrors_CMockStopIgnore(void)
{
  Mock.vIncreaseSpiAdcErrors_IgnoreBool = (char)0;
}

void vIncreaseSpiAdcErrors_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE));
  CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE* cmock_call_instance = (CMOCK_vIncreaseSpiAdcErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vIncreaseSpiAdcErrors_CallInstance = CMock_Guts_MemChain(Mock.vIncreaseSpiAdcErrors_CallInstance, cmock_guts_index);
  Mock.vIncreaseSpiAdcErrors_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vIncreaseSpiAdcErrors_AddCallback(CMOCK_vIncreaseSpiAdcErrors_CALLBACK Callback)
{
  Mock.vIncreaseSpiAdcErrors_IgnoreBool = (char)0;
  Mock.vIncreaseSpiAdcErrors_CallbackBool = (char)1;
  Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer = Callback;
}

void vIncreaseSpiAdcErrors_Stub(CMOCK_vIncreaseSpiAdcErrors_CALLBACK Callback)
{
  Mock.vIncreaseSpiAdcErrors_IgnoreBool = (char)0;
  Mock.vIncreaseSpiAdcErrors_CallbackBool = (char)0;
  Mock.vIncreaseSpiAdcErrors_CallbackFunctionPointer = Callback;
}

void vClearSpiAdcErrors(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vClearSpiAdcErrors_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vClearSpiAdcErrors);
  cmock_call_instance = (CMOCK_vClearSpiAdcErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vClearSpiAdcErrors_CallInstance);
  Mock.vClearSpiAdcErrors_CallInstance = CMock_Guts_MemNext(Mock.vClearSpiAdcErrors_CallInstance);
  if (Mock.vClearSpiAdcErrors_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vClearSpiAdcErrors_CallbackBool &&
      Mock.vClearSpiAdcErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vClearSpiAdcErrors_CallbackFunctionPointer(Mock.vClearSpiAdcErrors_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vClearSpiAdcErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vClearSpiAdcErrors_CallbackFunctionPointer(Mock.vClearSpiAdcErrors_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vClearSpiAdcErrors_CMockIgnore(void)
{
  Mock.vClearSpiAdcErrors_IgnoreBool = (char)1;
}

void vClearSpiAdcErrors_CMockStopIgnore(void)
{
  Mock.vClearSpiAdcErrors_IgnoreBool = (char)0;
}

void vClearSpiAdcErrors_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vClearSpiAdcErrors_CALL_INSTANCE));
  CMOCK_vClearSpiAdcErrors_CALL_INSTANCE* cmock_call_instance = (CMOCK_vClearSpiAdcErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vClearSpiAdcErrors_CallInstance = CMock_Guts_MemChain(Mock.vClearSpiAdcErrors_CallInstance, cmock_guts_index);
  Mock.vClearSpiAdcErrors_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vClearSpiAdcErrors_AddCallback(CMOCK_vClearSpiAdcErrors_CALLBACK Callback)
{
  Mock.vClearSpiAdcErrors_IgnoreBool = (char)0;
  Mock.vClearSpiAdcErrors_CallbackBool = (char)1;
  Mock.vClearSpiAdcErrors_CallbackFunctionPointer = Callback;
}

void vClearSpiAdcErrors_Stub(CMOCK_vClearSpiAdcErrors_CALLBACK Callback)
{
  Mock.vClearSpiAdcErrors_IgnoreBool = (char)0;
  Mock.vClearSpiAdcErrors_CallbackBool = (char)0;
  Mock.vClearSpiAdcErrors_CallbackFunctionPointer = Callback;
}

void vIncreaseSpiFramErrors(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vIncreaseSpiFramErrors);
  cmock_call_instance = (CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vIncreaseSpiFramErrors_CallInstance);
  Mock.vIncreaseSpiFramErrors_CallInstance = CMock_Guts_MemNext(Mock.vIncreaseSpiFramErrors_CallInstance);
  if (Mock.vIncreaseSpiFramErrors_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vIncreaseSpiFramErrors_CallbackBool &&
      Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer(Mock.vIncreaseSpiFramErrors_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer(Mock.vIncreaseSpiFramErrors_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vIncreaseSpiFramErrors_CMockIgnore(void)
{
  Mock.vIncreaseSpiFramErrors_IgnoreBool = (char)1;
}

void vIncreaseSpiFramErrors_CMockStopIgnore(void)
{
  Mock.vIncreaseSpiFramErrors_IgnoreBool = (char)0;
}

void vIncreaseSpiFramErrors_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE));
  CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE* cmock_call_instance = (CMOCK_vIncreaseSpiFramErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vIncreaseSpiFramErrors_CallInstance = CMock_Guts_MemChain(Mock.vIncreaseSpiFramErrors_CallInstance, cmock_guts_index);
  Mock.vIncreaseSpiFramErrors_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vIncreaseSpiFramErrors_AddCallback(CMOCK_vIncreaseSpiFramErrors_CALLBACK Callback)
{
  Mock.vIncreaseSpiFramErrors_IgnoreBool = (char)0;
  Mock.vIncreaseSpiFramErrors_CallbackBool = (char)1;
  Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer = Callback;
}

void vIncreaseSpiFramErrors_Stub(CMOCK_vIncreaseSpiFramErrors_CALLBACK Callback)
{
  Mock.vIncreaseSpiFramErrors_IgnoreBool = (char)0;
  Mock.vIncreaseSpiFramErrors_CallbackBool = (char)0;
  Mock.vIncreaseSpiFramErrors_CallbackFunctionPointer = Callback;
}

void vClearSpiFramErrors(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vClearSpiFramErrors_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vClearSpiFramErrors);
  cmock_call_instance = (CMOCK_vClearSpiFramErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vClearSpiFramErrors_CallInstance);
  Mock.vClearSpiFramErrors_CallInstance = CMock_Guts_MemNext(Mock.vClearSpiFramErrors_CallInstance);
  if (Mock.vClearSpiFramErrors_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vClearSpiFramErrors_CallbackBool &&
      Mock.vClearSpiFramErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vClearSpiFramErrors_CallbackFunctionPointer(Mock.vClearSpiFramErrors_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vClearSpiFramErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vClearSpiFramErrors_CallbackFunctionPointer(Mock.vClearSpiFramErrors_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vClearSpiFramErrors_CMockIgnore(void)
{
  Mock.vClearSpiFramErrors_IgnoreBool = (char)1;
}

void vClearSpiFramErrors_CMockStopIgnore(void)
{
  Mock.vClearSpiFramErrors_IgnoreBool = (char)0;
}

void vClearSpiFramErrors_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vClearSpiFramErrors_CALL_INSTANCE));
  CMOCK_vClearSpiFramErrors_CALL_INSTANCE* cmock_call_instance = (CMOCK_vClearSpiFramErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vClearSpiFramErrors_CallInstance = CMock_Guts_MemChain(Mock.vClearSpiFramErrors_CallInstance, cmock_guts_index);
  Mock.vClearSpiFramErrors_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vClearSpiFramErrors_AddCallback(CMOCK_vClearSpiFramErrors_CALLBACK Callback)
{
  Mock.vClearSpiFramErrors_IgnoreBool = (char)0;
  Mock.vClearSpiFramErrors_CallbackBool = (char)1;
  Mock.vClearSpiFramErrors_CallbackFunctionPointer = Callback;
}

void vClearSpiFramErrors_Stub(CMOCK_vClearSpiFramErrors_CALLBACK Callback)
{
  Mock.vClearSpiFramErrors_IgnoreBool = (char)0;
  Mock.vClearSpiFramErrors_CallbackBool = (char)0;
  Mock.vClearSpiFramErrors_CallbackFunctionPointer = Callback;
}

void vIncreaseCanErrors(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vIncreaseCanErrors_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vIncreaseCanErrors);
  cmock_call_instance = (CMOCK_vIncreaseCanErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vIncreaseCanErrors_CallInstance);
  Mock.vIncreaseCanErrors_CallInstance = CMock_Guts_MemNext(Mock.vIncreaseCanErrors_CallInstance);
  if (Mock.vIncreaseCanErrors_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vIncreaseCanErrors_CallbackBool &&
      Mock.vIncreaseCanErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vIncreaseCanErrors_CallbackFunctionPointer(Mock.vIncreaseCanErrors_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vIncreaseCanErrors_CallbackFunctionPointer != NULL)
  {
    Mock.vIncreaseCanErrors_CallbackFunctionPointer(Mock.vIncreaseCanErrors_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vIncreaseCanErrors_CMockIgnore(void)
{
  Mock.vIncreaseCanErrors_IgnoreBool = (char)1;
}

void vIncreaseCanErrors_CMockStopIgnore(void)
{
  Mock.vIncreaseCanErrors_IgnoreBool = (char)0;
}

void vIncreaseCanErrors_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vIncreaseCanErrors_CALL_INSTANCE));
  CMOCK_vIncreaseCanErrors_CALL_INSTANCE* cmock_call_instance = (CMOCK_vIncreaseCanErrors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vIncreaseCanErrors_CallInstance = CMock_Guts_MemChain(Mock.vIncreaseCanErrors_CallInstance, cmock_guts_index);
  Mock.vIncreaseCanErrors_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vIncreaseCanErrors_AddCallback(CMOCK_vIncreaseCanErrors_CALLBACK Callback)
{
  Mock.vIncreaseCanErrors_IgnoreBool = (char)0;
  Mock.vIncreaseCanErrors_CallbackBool = (char)1;
  Mock.vIncreaseCanErrors_CallbackFunctionPointer = Callback;
}

void vIncreaseCanErrors_Stub(CMOCK_vIncreaseCanErrors_CALLBACK Callback)
{
  Mock.vIncreaseCanErrors_IgnoreBool = (char)0;
  Mock.vIncreaseCanErrors_CallbackBool = (char)0;
  Mock.vIncreaseCanErrors_CallbackFunctionPointer = Callback;
}

eBool_t vGetUpdateMemoryWriteNeeded(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetUpdateMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetUpdateMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateMemoryWriteNeeded_CallInstance);
  if (Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetUpdateMemoryWriteNeeded_FinalReturn;
    memcpy((void*)(&Mock.vGetUpdateMemoryWriteNeeded_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetUpdateMemoryWriteNeeded_CallbackBool &&
      Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetUpdateMemoryWriteNeeded_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vGetUpdateMemoryWriteNeeded_CMockStopIgnore(void)
{
  if(Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool)
    Mock.vGetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vGetUpdateMemoryWriteNeeded_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void vGetUpdateMemoryWriteNeeded_AddCallback(CMOCK_vGetUpdateMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vGetUpdateMemoryWriteNeeded_Stub(CMOCK_vGetUpdateMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vGetUpdateMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

eBool_t bResetIsDemanded(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bResetIsDemanded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bResetIsDemanded);
  cmock_call_instance = (CMOCK_bResetIsDemanded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bResetIsDemanded_CallInstance);
  Mock.bResetIsDemanded_CallInstance = CMock_Guts_MemNext(Mock.bResetIsDemanded_CallInstance);
  if (Mock.bResetIsDemanded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bResetIsDemanded_FinalReturn;
    memcpy((void*)(&Mock.bResetIsDemanded_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bResetIsDemanded_CallbackBool &&
      Mock.bResetIsDemanded_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bResetIsDemanded_CallbackFunctionPointer(Mock.bResetIsDemanded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.bResetIsDemanded_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bResetIsDemanded_CallbackFunctionPointer(Mock.bResetIsDemanded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void bResetIsDemanded_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bResetIsDemanded_CALL_INSTANCE));
  CMOCK_bResetIsDemanded_CALL_INSTANCE* cmock_call_instance = (CMOCK_bResetIsDemanded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bResetIsDemanded_CallInstance = CMock_Guts_MemChain(Mock.bResetIsDemanded_CallInstance, cmock_guts_index);
  Mock.bResetIsDemanded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bResetIsDemanded_IgnoreBool = (char)1;
}

void bResetIsDemanded_CMockStopIgnore(void)
{
  if(Mock.bResetIsDemanded_IgnoreBool)
    Mock.bResetIsDemanded_CallInstance = CMock_Guts_MemNext(Mock.bResetIsDemanded_CallInstance);
  Mock.bResetIsDemanded_IgnoreBool = (char)0;
}

void bResetIsDemanded_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bResetIsDemanded_CALL_INSTANCE));
  CMOCK_bResetIsDemanded_CALL_INSTANCE* cmock_call_instance = (CMOCK_bResetIsDemanded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bResetIsDemanded_CallInstance = CMock_Guts_MemChain(Mock.bResetIsDemanded_CallInstance, cmock_guts_index);
  Mock.bResetIsDemanded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bResetIsDemanded_AddCallback(CMOCK_bResetIsDemanded_CALLBACK Callback)
{
  Mock.bResetIsDemanded_IgnoreBool = (char)0;
  Mock.bResetIsDemanded_CallbackBool = (char)1;
  Mock.bResetIsDemanded_CallbackFunctionPointer = Callback;
}

void bResetIsDemanded_Stub(CMOCK_bResetIsDemanded_CALLBACK Callback)
{
  Mock.bResetIsDemanded_IgnoreBool = (char)0;
  Mock.bResetIsDemanded_CallbackBool = (char)0;
  Mock.bResetIsDemanded_CallbackFunctionPointer = Callback;
}

eBool_t vGetUpdateCommonMemoryWriteNeeded(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetUpdateCommonMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance);
  if (Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetUpdateCommonMemoryWriteNeeded_FinalReturn;
    memcpy((void*)(&Mock.vGetUpdateCommonMemoryWriteNeeded_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackBool &&
      Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetUpdateCommonMemoryWriteNeeded_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vGetUpdateCommonMemoryWriteNeeded_CMockStopIgnore(void)
{
  if(Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool)
    Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vGetUpdateCommonMemoryWriteNeeded_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateCommonMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void vGetUpdateCommonMemoryWriteNeeded_AddCallback(CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vGetUpdateCommonMemoryWriteNeeded_Stub(CMOCK_vGetUpdateCommonMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vGetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

eBool_t vGetUpdateLnaMemoryWriteNeeded(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetUpdateLnaMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance);
  if (Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetUpdateLnaMemoryWriteNeeded_FinalReturn;
    memcpy((void*)(&Mock.vGetUpdateLnaMemoryWriteNeeded_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackBool &&
      Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetUpdateLnaMemoryWriteNeeded_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vGetUpdateLnaMemoryWriteNeeded_CMockStopIgnore(void)
{
  if(Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool)
    Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vGetUpdateLnaMemoryWriteNeeded_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateLnaMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void vGetUpdateLnaMemoryWriteNeeded_AddCallback(CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vGetUpdateLnaMemoryWriteNeeded_Stub(CMOCK_vGetUpdateLnaMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vGetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

eBool_t vGetUpdateBoosterMemoryWriteNeeded(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetUpdateBoosterMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance);
  if (Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vGetUpdateBoosterMemoryWriteNeeded_FinalReturn;
    memcpy((void*)(&Mock.vGetUpdateBoosterMemoryWriteNeeded_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackBool &&
      Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vGetUpdateBoosterMemoryWriteNeeded_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vGetUpdateBoosterMemoryWriteNeeded_CMockStopIgnore(void)
{
  if(Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool)
    Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance);
  Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vGetUpdateBoosterMemoryWriteNeeded_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vGetUpdateBoosterMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void vGetUpdateBoosterMemoryWriteNeeded_AddCallback(CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vGetUpdateBoosterMemoryWriteNeeded_Stub(CMOCK_vGetUpdateBoosterMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vGetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vGetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateMemoryWriteNeeded(eBool_t bWriteMemoryNeeded)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetUpdateMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetUpdateMemoryWriteNeeded_CallInstance);
  Mock.vSetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vSetUpdateMemoryWriteNeeded_CallInstance);
  if (Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetUpdateMemoryWriteNeeded_CallbackBool &&
      Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bWriteMemoryNeeded)
  {
    UNITY_SET_DETAILS(CMockString_vSetUpdateMemoryWriteNeeded,CMockString_bWriteMemoryNeeded);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetUpdateMemoryWriteNeeded(CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded);
void CMockExpectParameters_vSetUpdateMemoryWriteNeeded(CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded)
{
  memcpy((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded),
         sizeof(eBool_t[sizeof(bWriteMemoryNeeded) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 0;
}

void vSetUpdateMemoryWriteNeeded_CMockIgnore(void)
{
  Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vSetUpdateMemoryWriteNeeded_CMockStopIgnore(void)
{
  Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vSetUpdateMemoryWriteNeeded_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetUpdateMemoryWriteNeeded_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bWriteMemoryNeeded)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetUpdateMemoryWriteNeeded(cmock_call_instance, bWriteMemoryNeeded);
}

void vSetUpdateMemoryWriteNeeded_AddCallback(CMOCK_vSetUpdateMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateMemoryWriteNeeded_Stub(CMOCK_vSetUpdateMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vSetUpdateMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateMemoryWriteNeeded_CMockIgnoreArg_bWriteMemoryNeeded(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetUpdateMemoryWriteNeeded_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 1;
}

void vSetUpdateCommonMemoryWriteNeeded(eBool_t bWriteMemoryNeeded)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetUpdateCommonMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance);
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance);
  if (Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackBool &&
      Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bWriteMemoryNeeded)
  {
    UNITY_SET_DETAILS(CMockString_vSetUpdateCommonMemoryWriteNeeded,CMockString_bWriteMemoryNeeded);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetUpdateCommonMemoryWriteNeeded(CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded);
void CMockExpectParameters_vSetUpdateCommonMemoryWriteNeeded(CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded)
{
  memcpy((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded),
         sizeof(eBool_t[sizeof(bWriteMemoryNeeded) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 0;
}

void vSetUpdateCommonMemoryWriteNeeded_CMockIgnore(void)
{
  Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vSetUpdateCommonMemoryWriteNeeded_CMockStopIgnore(void)
{
  Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vSetUpdateCommonMemoryWriteNeeded_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetUpdateCommonMemoryWriteNeeded_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bWriteMemoryNeeded)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetUpdateCommonMemoryWriteNeeded(cmock_call_instance, bWriteMemoryNeeded);
}

void vSetUpdateCommonMemoryWriteNeeded_AddCallback(CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateCommonMemoryWriteNeeded_Stub(CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateCommonMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vSetUpdateCommonMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateCommonMemoryWriteNeeded_CMockIgnoreArg_bWriteMemoryNeeded(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateCommonMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetUpdateCommonMemoryWriteNeeded_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 1;
}

void vSetUpdateLnaMemoryWriteNeeded(eBool_t bWriteMemoryNeeded)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetUpdateLnaMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance);
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance);
  if (Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackBool &&
      Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bWriteMemoryNeeded)
  {
    UNITY_SET_DETAILS(CMockString_vSetUpdateLnaMemoryWriteNeeded,CMockString_bWriteMemoryNeeded);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetUpdateLnaMemoryWriteNeeded(CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded);
void CMockExpectParameters_vSetUpdateLnaMemoryWriteNeeded(CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded)
{
  memcpy((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded),
         sizeof(eBool_t[sizeof(bWriteMemoryNeeded) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 0;
}

void vSetUpdateLnaMemoryWriteNeeded_CMockIgnore(void)
{
  Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vSetUpdateLnaMemoryWriteNeeded_CMockStopIgnore(void)
{
  Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vSetUpdateLnaMemoryWriteNeeded_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetUpdateLnaMemoryWriteNeeded_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bWriteMemoryNeeded)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetUpdateLnaMemoryWriteNeeded(cmock_call_instance, bWriteMemoryNeeded);
}

void vSetUpdateLnaMemoryWriteNeeded_AddCallback(CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateLnaMemoryWriteNeeded_Stub(CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateLnaMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vSetUpdateLnaMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateLnaMemoryWriteNeeded_CMockIgnoreArg_bWriteMemoryNeeded(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateLnaMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetUpdateLnaMemoryWriteNeeded_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 1;
}

void vSetUpdateBoosterMemoryWriteNeeded(eBool_t bWriteMemoryNeeded)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetUpdateBoosterMemoryWriteNeeded);
  cmock_call_instance = (CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance);
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemNext(Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance);
  if (Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackBool &&
      Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bWriteMemoryNeeded)
  {
    UNITY_SET_DETAILS(CMockString_vSetUpdateBoosterMemoryWriteNeeded,CMockString_bWriteMemoryNeeded);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer != NULL)
  {
    Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer(bWriteMemoryNeeded, Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetUpdateBoosterMemoryWriteNeeded(CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded);
void CMockExpectParameters_vSetUpdateBoosterMemoryWriteNeeded(CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance, eBool_t bWriteMemoryNeeded)
{
  memcpy((void*)(&cmock_call_instance->Expected_bWriteMemoryNeeded), (void*)(&bWriteMemoryNeeded),
         sizeof(eBool_t[sizeof(bWriteMemoryNeeded) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 0;
}

void vSetUpdateBoosterMemoryWriteNeeded_CMockIgnore(void)
{
  Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)1;
}

void vSetUpdateBoosterMemoryWriteNeeded_CMockStopIgnore(void)
{
  Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
}

void vSetUpdateBoosterMemoryWriteNeeded_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetUpdateBoosterMemoryWriteNeeded_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bWriteMemoryNeeded)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE));
  CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance = CMock_Guts_MemChain(Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance, cmock_guts_index);
  Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetUpdateBoosterMemoryWriteNeeded(cmock_call_instance, bWriteMemoryNeeded);
}

void vSetUpdateBoosterMemoryWriteNeeded_AddCallback(CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackBool = (char)1;
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateBoosterMemoryWriteNeeded_Stub(CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALLBACK Callback)
{
  Mock.vSetUpdateBoosterMemoryWriteNeeded_IgnoreBool = (char)0;
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackBool = (char)0;
  Mock.vSetUpdateBoosterMemoryWriteNeeded_CallbackFunctionPointer = Callback;
}

void vSetUpdateBoosterMemoryWriteNeeded_CMockIgnoreArg_bWriteMemoryNeeded(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetUpdateBoosterMemoryWriteNeeded_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetUpdateBoosterMemoryWriteNeeded_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bWriteMemoryNeeded = 1;
}

void vCopyImageCommonNvm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vCopyImageCommonNvm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vCopyImageCommonNvm);
  cmock_call_instance = (CMOCK_vCopyImageCommonNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vCopyImageCommonNvm_CallInstance);
  Mock.vCopyImageCommonNvm_CallInstance = CMock_Guts_MemNext(Mock.vCopyImageCommonNvm_CallInstance);
  if (Mock.vCopyImageCommonNvm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vCopyImageCommonNvm_CallbackBool &&
      Mock.vCopyImageCommonNvm_CallbackFunctionPointer != NULL)
  {
    Mock.vCopyImageCommonNvm_CallbackFunctionPointer(Mock.vCopyImageCommonNvm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vCopyImageCommonNvm_CallbackFunctionPointer != NULL)
  {
    Mock.vCopyImageCommonNvm_CallbackFunctionPointer(Mock.vCopyImageCommonNvm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vCopyImageCommonNvm_CMockIgnore(void)
{
  Mock.vCopyImageCommonNvm_IgnoreBool = (char)1;
}

void vCopyImageCommonNvm_CMockStopIgnore(void)
{
  Mock.vCopyImageCommonNvm_IgnoreBool = (char)0;
}

void vCopyImageCommonNvm_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vCopyImageCommonNvm_CALL_INSTANCE));
  CMOCK_vCopyImageCommonNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vCopyImageCommonNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vCopyImageCommonNvm_CallInstance = CMock_Guts_MemChain(Mock.vCopyImageCommonNvm_CallInstance, cmock_guts_index);
  Mock.vCopyImageCommonNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vCopyImageCommonNvm_AddCallback(CMOCK_vCopyImageCommonNvm_CALLBACK Callback)
{
  Mock.vCopyImageCommonNvm_IgnoreBool = (char)0;
  Mock.vCopyImageCommonNvm_CallbackBool = (char)1;
  Mock.vCopyImageCommonNvm_CallbackFunctionPointer = Callback;
}

void vCopyImageCommonNvm_Stub(CMOCK_vCopyImageCommonNvm_CALLBACK Callback)
{
  Mock.vCopyImageCommonNvm_IgnoreBool = (char)0;
  Mock.vCopyImageCommonNvm_CallbackBool = (char)0;
  Mock.vCopyImageCommonNvm_CallbackFunctionPointer = Callback;
}

void vCopyImageLnaNvm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vCopyImageLnaNvm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vCopyImageLnaNvm);
  cmock_call_instance = (CMOCK_vCopyImageLnaNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vCopyImageLnaNvm_CallInstance);
  Mock.vCopyImageLnaNvm_CallInstance = CMock_Guts_MemNext(Mock.vCopyImageLnaNvm_CallInstance);
  if (Mock.vCopyImageLnaNvm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vCopyImageLnaNvm_CallbackBool &&
      Mock.vCopyImageLnaNvm_CallbackFunctionPointer != NULL)
  {
    Mock.vCopyImageLnaNvm_CallbackFunctionPointer(Mock.vCopyImageLnaNvm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vCopyImageLnaNvm_CallbackFunctionPointer != NULL)
  {
    Mock.vCopyImageLnaNvm_CallbackFunctionPointer(Mock.vCopyImageLnaNvm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vCopyImageLnaNvm_CMockIgnore(void)
{
  Mock.vCopyImageLnaNvm_IgnoreBool = (char)1;
}

void vCopyImageLnaNvm_CMockStopIgnore(void)
{
  Mock.vCopyImageLnaNvm_IgnoreBool = (char)0;
}

void vCopyImageLnaNvm_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vCopyImageLnaNvm_CALL_INSTANCE));
  CMOCK_vCopyImageLnaNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vCopyImageLnaNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vCopyImageLnaNvm_CallInstance = CMock_Guts_MemChain(Mock.vCopyImageLnaNvm_CallInstance, cmock_guts_index);
  Mock.vCopyImageLnaNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vCopyImageLnaNvm_AddCallback(CMOCK_vCopyImageLnaNvm_CALLBACK Callback)
{
  Mock.vCopyImageLnaNvm_IgnoreBool = (char)0;
  Mock.vCopyImageLnaNvm_CallbackBool = (char)1;
  Mock.vCopyImageLnaNvm_CallbackFunctionPointer = Callback;
}

void vCopyImageLnaNvm_Stub(CMOCK_vCopyImageLnaNvm_CALLBACK Callback)
{
  Mock.vCopyImageLnaNvm_IgnoreBool = (char)0;
  Mock.vCopyImageLnaNvm_CallbackBool = (char)0;
  Mock.vCopyImageLnaNvm_CallbackFunctionPointer = Callback;
}

void vCopyImageBoosterNvm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vCopyImageBoosterNvm);
  cmock_call_instance = (CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vCopyImageBoosterNvm_CallInstance);
  Mock.vCopyImageBoosterNvm_CallInstance = CMock_Guts_MemNext(Mock.vCopyImageBoosterNvm_CallInstance);
  if (Mock.vCopyImageBoosterNvm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vCopyImageBoosterNvm_CallbackBool &&
      Mock.vCopyImageBoosterNvm_CallbackFunctionPointer != NULL)
  {
    Mock.vCopyImageBoosterNvm_CallbackFunctionPointer(Mock.vCopyImageBoosterNvm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vCopyImageBoosterNvm_CallbackFunctionPointer != NULL)
  {
    Mock.vCopyImageBoosterNvm_CallbackFunctionPointer(Mock.vCopyImageBoosterNvm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vCopyImageBoosterNvm_CMockIgnore(void)
{
  Mock.vCopyImageBoosterNvm_IgnoreBool = (char)1;
}

void vCopyImageBoosterNvm_CMockStopIgnore(void)
{
  Mock.vCopyImageBoosterNvm_IgnoreBool = (char)0;
}

void vCopyImageBoosterNvm_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE));
  CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vCopyImageBoosterNvm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vCopyImageBoosterNvm_CallInstance = CMock_Guts_MemChain(Mock.vCopyImageBoosterNvm_CallInstance, cmock_guts_index);
  Mock.vCopyImageBoosterNvm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vCopyImageBoosterNvm_AddCallback(CMOCK_vCopyImageBoosterNvm_CALLBACK Callback)
{
  Mock.vCopyImageBoosterNvm_IgnoreBool = (char)0;
  Mock.vCopyImageBoosterNvm_CallbackBool = (char)1;
  Mock.vCopyImageBoosterNvm_CallbackFunctionPointer = Callback;
}

void vCopyImageBoosterNvm_Stub(CMOCK_vCopyImageBoosterNvm_CALLBACK Callback)
{
  Mock.vCopyImageBoosterNvm_IgnoreBool = (char)0;
  Mock.vCopyImageBoosterNvm_CallbackBool = (char)0;
  Mock.vCopyImageBoosterNvm_CallbackFunctionPointer = Callback;
}

void vLaserSetCurrentAlarm(eBool_t bAlarmExist)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vLaserSetCurrentAlarm);
  cmock_call_instance = (CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vLaserSetCurrentAlarm_CallInstance);
  Mock.vLaserSetCurrentAlarm_CallInstance = CMock_Guts_MemNext(Mock.vLaserSetCurrentAlarm_CallInstance);
  if (Mock.vLaserSetCurrentAlarm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vLaserSetCurrentAlarm_CallbackBool &&
      Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer(bAlarmExist, Mock.vLaserSetCurrentAlarm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bAlarmExist)
  {
    UNITY_SET_DETAILS(CMockString_vLaserSetCurrentAlarm,CMockString_bAlarmExist);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bAlarmExist), (void*)(&bAlarmExist), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer != NULL)
  {
    Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer(bAlarmExist, Mock.vLaserSetCurrentAlarm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vLaserSetCurrentAlarm(CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE* cmock_call_instance, eBool_t bAlarmExist);
void CMockExpectParameters_vLaserSetCurrentAlarm(CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE* cmock_call_instance, eBool_t bAlarmExist)
{
  memcpy((void*)(&cmock_call_instance->Expected_bAlarmExist), (void*)(&bAlarmExist),
         sizeof(eBool_t[sizeof(bAlarmExist) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bAlarmExist = 0;
}

void vLaserSetCurrentAlarm_CMockIgnore(void)
{
  Mock.vLaserSetCurrentAlarm_IgnoreBool = (char)1;
}

void vLaserSetCurrentAlarm_CMockStopIgnore(void)
{
  Mock.vLaserSetCurrentAlarm_IgnoreBool = (char)0;
}

void vLaserSetCurrentAlarm_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE));
  CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserSetCurrentAlarm_CallInstance = CMock_Guts_MemChain(Mock.vLaserSetCurrentAlarm_CallInstance, cmock_guts_index);
  Mock.vLaserSetCurrentAlarm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vLaserSetCurrentAlarm_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bAlarmExist)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE));
  CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vLaserSetCurrentAlarm_CallInstance = CMock_Guts_MemChain(Mock.vLaserSetCurrentAlarm_CallInstance, cmock_guts_index);
  Mock.vLaserSetCurrentAlarm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vLaserSetCurrentAlarm(cmock_call_instance, bAlarmExist);
}

void vLaserSetCurrentAlarm_AddCallback(CMOCK_vLaserSetCurrentAlarm_CALLBACK Callback)
{
  Mock.vLaserSetCurrentAlarm_IgnoreBool = (char)0;
  Mock.vLaserSetCurrentAlarm_CallbackBool = (char)1;
  Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer = Callback;
}

void vLaserSetCurrentAlarm_Stub(CMOCK_vLaserSetCurrentAlarm_CALLBACK Callback)
{
  Mock.vLaserSetCurrentAlarm_IgnoreBool = (char)0;
  Mock.vLaserSetCurrentAlarm_CallbackBool = (char)0;
  Mock.vLaserSetCurrentAlarm_CallbackFunctionPointer = Callback;
}

void vLaserSetCurrentAlarm_CMockIgnoreArg_bAlarmExist(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE* cmock_call_instance = (CMOCK_vLaserSetCurrentAlarm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vLaserSetCurrentAlarm_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bAlarmExist = 1;
}

void vUpdateLnaPIDValues(float fLnasingleProportional, float fLnasingleIntegralGain, float fLnasingleDerivativeGain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateLnaPIDValues);
  cmock_call_instance = (CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateLnaPIDValues_CallInstance);
  Mock.vUpdateLnaPIDValues_CallInstance = CMock_Guts_MemNext(Mock.vUpdateLnaPIDValues_CallInstance);
  if (Mock.vUpdateLnaPIDValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateLnaPIDValues_CallbackBool &&
      Mock.vUpdateLnaPIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateLnaPIDValues_CallbackFunctionPointer(fLnasingleProportional, fLnasingleIntegralGain, fLnasingleDerivativeGain, Mock.vUpdateLnaPIDValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fLnasingleProportional)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateLnaPIDValues,CMockString_fLnasingleProportional);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fLnasingleProportional, fLnasingleProportional, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fLnasingleIntegralGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateLnaPIDValues,CMockString_fLnasingleIntegralGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fLnasingleIntegralGain, fLnasingleIntegralGain, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fLnasingleDerivativeGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateLnaPIDValues,CMockString_fLnasingleDerivativeGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fLnasingleDerivativeGain, fLnasingleDerivativeGain, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vUpdateLnaPIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateLnaPIDValues_CallbackFunctionPointer(fLnasingleProportional, fLnasingleIntegralGain, fLnasingleDerivativeGain, Mock.vUpdateLnaPIDValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vUpdateLnaPIDValues(CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance, float fLnasingleProportional, float fLnasingleIntegralGain, float fLnasingleDerivativeGain);
void CMockExpectParameters_vUpdateLnaPIDValues(CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance, float fLnasingleProportional, float fLnasingleIntegralGain, float fLnasingleDerivativeGain)
{
  cmock_call_instance->Expected_fLnasingleProportional = fLnasingleProportional;
  cmock_call_instance->IgnoreArg_fLnasingleProportional = 0;
  cmock_call_instance->Expected_fLnasingleIntegralGain = fLnasingleIntegralGain;
  cmock_call_instance->IgnoreArg_fLnasingleIntegralGain = 0;
  cmock_call_instance->Expected_fLnasingleDerivativeGain = fLnasingleDerivativeGain;
  cmock_call_instance->IgnoreArg_fLnasingleDerivativeGain = 0;
}

void vUpdateLnaPIDValues_CMockIgnore(void)
{
  Mock.vUpdateLnaPIDValues_IgnoreBool = (char)1;
}

void vUpdateLnaPIDValues_CMockStopIgnore(void)
{
  Mock.vUpdateLnaPIDValues_IgnoreBool = (char)0;
}

void vUpdateLnaPIDValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE));
  CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateLnaPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateLnaPIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateLnaPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vUpdateLnaPIDValues_CMockExpect(UNITY_LINE_TYPE cmock_line, float fLnasingleProportional, float fLnasingleIntegralGain, float fLnasingleDerivativeGain)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE));
  CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateLnaPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateLnaPIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateLnaPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUpdateLnaPIDValues(cmock_call_instance, fLnasingleProportional, fLnasingleIntegralGain, fLnasingleDerivativeGain);
}

void vUpdateLnaPIDValues_AddCallback(CMOCK_vUpdateLnaPIDValues_CALLBACK Callback)
{
  Mock.vUpdateLnaPIDValues_IgnoreBool = (char)0;
  Mock.vUpdateLnaPIDValues_CallbackBool = (char)1;
  Mock.vUpdateLnaPIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateLnaPIDValues_Stub(CMOCK_vUpdateLnaPIDValues_CALLBACK Callback)
{
  Mock.vUpdateLnaPIDValues_IgnoreBool = (char)0;
  Mock.vUpdateLnaPIDValues_CallbackBool = (char)0;
  Mock.vUpdateLnaPIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateLnaPIDValues_CMockIgnoreArg_fLnasingleProportional(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateLnaPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fLnasingleProportional = 1;
}

void vUpdateLnaPIDValues_CMockIgnoreArg_fLnasingleIntegralGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateLnaPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fLnasingleIntegralGain = 1;
}

void vUpdateLnaPIDValues_CMockIgnoreArg_fLnasingleDerivativeGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateLnaPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateLnaPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fLnasingleDerivativeGain = 1;
}

void vUpdateHpaSmPIDValues(float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateHpaSmPIDValues);
  cmock_call_instance = (CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateHpaSmPIDValues_CallInstance);
  Mock.vUpdateHpaSmPIDValues_CallInstance = CMock_Guts_MemNext(Mock.vUpdateHpaSmPIDValues_CallInstance);
  if (Mock.vUpdateHpaSmPIDValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateHpaSmPIDValues_CallbackBool &&
      Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer(fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain, Mock.vUpdateHpaSmPIDValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fHpaSingleProportional)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaSmPIDValues,CMockString_fHpaSingleProportional);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleProportional, fHpaSingleProportional, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaSmPIDValues,CMockString_fHpaSingleIntegralGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleIntegralGain, fHpaSingleIntegralGain, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaSmPIDValues,CMockString_fHpaSingleDerivativeGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleDerivativeGain, fHpaSingleDerivativeGain, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer(fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain, Mock.vUpdateHpaSmPIDValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vUpdateHpaSmPIDValues(CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain);
void CMockExpectParameters_vUpdateHpaSmPIDValues(CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  cmock_call_instance->Expected_fHpaSingleProportional = fHpaSingleProportional;
  cmock_call_instance->IgnoreArg_fHpaSingleProportional = 0;
  cmock_call_instance->Expected_fHpaSingleIntegralGain = fHpaSingleIntegralGain;
  cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain = 0;
  cmock_call_instance->Expected_fHpaSingleDerivativeGain = fHpaSingleDerivativeGain;
  cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain = 0;
}

void vUpdateHpaSmPIDValues_CMockIgnore(void)
{
  Mock.vUpdateHpaSmPIDValues_IgnoreBool = (char)1;
}

void vUpdateHpaSmPIDValues_CMockStopIgnore(void)
{
  Mock.vUpdateHpaSmPIDValues_IgnoreBool = (char)0;
}

void vUpdateHpaSmPIDValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaSmPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaSmPIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaSmPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vUpdateHpaSmPIDValues_CMockExpect(UNITY_LINE_TYPE cmock_line, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaSmPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaSmPIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaSmPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUpdateHpaSmPIDValues(cmock_call_instance, fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain);
}

void vUpdateHpaSmPIDValues_AddCallback(CMOCK_vUpdateHpaSmPIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaSmPIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaSmPIDValues_CallbackBool = (char)1;
  Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaSmPIDValues_Stub(CMOCK_vUpdateHpaSmPIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaSmPIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaSmPIDValues_CallbackBool = (char)0;
  Mock.vUpdateHpaSmPIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaSmPIDValues_CMockIgnoreArg_fHpaSingleProportional(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleProportional = 1;
}

void vUpdateHpaSmPIDValues_CMockIgnoreArg_fHpaSingleIntegralGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain = 1;
}

void vUpdateHpaSmPIDValues_CMockIgnoreArg_fHpaSingleDerivativeGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain = 1;
}

void vUploadHpaSmPIDValues(float* pfHpaSingleProportional, float* pfHpasingleIntegralGain, float* pfHpasingleDerivativeGain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUploadHpaSmPIDValues);
  cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUploadHpaSmPIDValues_CallInstance);
  Mock.vUploadHpaSmPIDValues_CallInstance = CMock_Guts_MemNext(Mock.vUploadHpaSmPIDValues_CallInstance);
  if (Mock.vUploadHpaSmPIDValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUploadHpaSmPIDValues_CallbackBool &&
      Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer(pfHpaSingleProportional, pfHpasingleIntegralGain, pfHpasingleDerivativeGain, Mock.vUploadHpaSmPIDValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pfHpaSingleProportional)
  {
    UNITY_SET_DETAILS(CMockString_vUploadHpaSmPIDValues,CMockString_pfHpaSingleProportional);
    if (cmock_call_instance->Expected_pfHpaSingleProportional == NULL)
      { UNITY_TEST_ASSERT_NULL(pfHpaSingleProportional, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfHpaSingleProportional, pfHpaSingleProportional, cmock_call_instance->Expected_pfHpaSingleProportional_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pfHpasingleIntegralGain)
  {
    UNITY_SET_DETAILS(CMockString_vUploadHpaSmPIDValues,CMockString_pfHpasingleIntegralGain);
    if (cmock_call_instance->Expected_pfHpasingleIntegralGain == NULL)
      { UNITY_TEST_ASSERT_NULL(pfHpasingleIntegralGain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfHpasingleIntegralGain, pfHpasingleIntegralGain, cmock_call_instance->Expected_pfHpasingleIntegralGain_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pfHpasingleDerivativeGain)
  {
    UNITY_SET_DETAILS(CMockString_vUploadHpaSmPIDValues,CMockString_pfHpasingleDerivativeGain);
    if (cmock_call_instance->Expected_pfHpasingleDerivativeGain == NULL)
      { UNITY_TEST_ASSERT_NULL(pfHpasingleDerivativeGain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfHpasingleDerivativeGain, pfHpasingleDerivativeGain, cmock_call_instance->Expected_pfHpasingleDerivativeGain_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer(pfHpaSingleProportional, pfHpasingleIntegralGain, pfHpasingleDerivativeGain, Mock.vUploadHpaSmPIDValues_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfHpaSingleProportional, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfHpaSingleProportional, (void*)cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Val,
      cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfHpasingleIntegralGain, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfHpasingleIntegralGain, (void*)cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Val,
      cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfHpasingleDerivativeGain, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfHpasingleDerivativeGain, (void*)cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Val,
      cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vUploadHpaSmPIDValues(CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance, float* pfHpaSingleProportional, int pfHpaSingleProportional_Depth, float* pfHpasingleIntegralGain, int pfHpasingleIntegralGain_Depth, float* pfHpasingleDerivativeGain, int pfHpasingleDerivativeGain_Depth);
void CMockExpectParameters_vUploadHpaSmPIDValues(CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance, float* pfHpaSingleProportional, int pfHpaSingleProportional_Depth, float* pfHpasingleIntegralGain, int pfHpasingleIntegralGain_Depth, float* pfHpasingleDerivativeGain, int pfHpasingleDerivativeGain_Depth)
{
  cmock_call_instance->Expected_pfHpaSingleProportional = pfHpaSingleProportional;
  cmock_call_instance->Expected_pfHpaSingleProportional_Depth = pfHpaSingleProportional_Depth;
  cmock_call_instance->IgnoreArg_pfHpaSingleProportional = 0;
  cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Used = 0;
  cmock_call_instance->Expected_pfHpasingleIntegralGain = pfHpasingleIntegralGain;
  cmock_call_instance->Expected_pfHpasingleIntegralGain_Depth = pfHpasingleIntegralGain_Depth;
  cmock_call_instance->IgnoreArg_pfHpasingleIntegralGain = 0;
  cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Used = 0;
  cmock_call_instance->Expected_pfHpasingleDerivativeGain = pfHpasingleDerivativeGain;
  cmock_call_instance->Expected_pfHpasingleDerivativeGain_Depth = pfHpasingleDerivativeGain_Depth;
  cmock_call_instance->IgnoreArg_pfHpasingleDerivativeGain = 0;
  cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Used = 0;
}

void vUploadHpaSmPIDValues_CMockIgnore(void)
{
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)1;
}

void vUploadHpaSmPIDValues_CMockStopIgnore(void)
{
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)0;
}

void vUploadHpaSmPIDValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE));
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUploadHpaSmPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUploadHpaSmPIDValues_CallInstance, cmock_guts_index);
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vUploadHpaSmPIDValues_CMockExpect(UNITY_LINE_TYPE cmock_line, float* pfHpaSingleProportional, float* pfHpasingleIntegralGain, float* pfHpasingleDerivativeGain)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE));
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUploadHpaSmPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUploadHpaSmPIDValues_CallInstance, cmock_guts_index);
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUploadHpaSmPIDValues(cmock_call_instance, pfHpaSingleProportional, 1, pfHpasingleIntegralGain, 1, pfHpasingleDerivativeGain, 1);
}

void vUploadHpaSmPIDValues_AddCallback(CMOCK_vUploadHpaSmPIDValues_CALLBACK Callback)
{
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)0;
  Mock.vUploadHpaSmPIDValues_CallbackBool = (char)1;
  Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer = Callback;
}

void vUploadHpaSmPIDValues_Stub(CMOCK_vUploadHpaSmPIDValues_CALLBACK Callback)
{
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)0;
  Mock.vUploadHpaSmPIDValues_CallbackBool = (char)0;
  Mock.vUploadHpaSmPIDValues_CallbackFunctionPointer = Callback;
}

void vUploadHpaSmPIDValues_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, float* pfHpaSingleProportional, int pfHpaSingleProportional_Depth, float* pfHpasingleIntegralGain, int pfHpasingleIntegralGain_Depth, float* pfHpasingleDerivativeGain, int pfHpasingleDerivativeGain_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE));
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUploadHpaSmPIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUploadHpaSmPIDValues_CallInstance, cmock_guts_index);
  Mock.vUploadHpaSmPIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUploadHpaSmPIDValues(cmock_call_instance, pfHpaSingleProportional, pfHpaSingleProportional_Depth, pfHpasingleIntegralGain, pfHpasingleIntegralGain_Depth, pfHpasingleDerivativeGain, pfHpasingleDerivativeGain_Depth);
}

void vUploadHpaSmPIDValues_CMockReturnMemThruPtr_pfHpaSingleProportional(UNITY_LINE_TYPE cmock_line, float* pfHpaSingleProportional, size_t cmock_size)
{
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUploadHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Val = pfHpaSingleProportional;
  cmock_call_instance->ReturnThruPtr_pfHpaSingleProportional_Size = cmock_size;
}

void vUploadHpaSmPIDValues_CMockReturnMemThruPtr_pfHpasingleIntegralGain(UNITY_LINE_TYPE cmock_line, float* pfHpasingleIntegralGain, size_t cmock_size)
{
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUploadHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Val = pfHpasingleIntegralGain;
  cmock_call_instance->ReturnThruPtr_pfHpasingleIntegralGain_Size = cmock_size;
}

void vUploadHpaSmPIDValues_CMockReturnMemThruPtr_pfHpasingleDerivativeGain(UNITY_LINE_TYPE cmock_line, float* pfHpasingleDerivativeGain, size_t cmock_size)
{
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUploadHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Val = pfHpasingleDerivativeGain;
  cmock_call_instance->ReturnThruPtr_pfHpasingleDerivativeGain_Size = cmock_size;
}

void vUploadHpaSmPIDValues_CMockIgnoreArg_pfHpaSingleProportional(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUploadHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfHpaSingleProportional = 1;
}

void vUploadHpaSmPIDValues_CMockIgnoreArg_pfHpasingleIntegralGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUploadHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfHpasingleIntegralGain = 1;
}

void vUploadHpaSmPIDValues_CMockIgnoreArg_pfHpasingleDerivativeGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUploadHpaSmPIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUploadHpaSmPIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfHpasingleDerivativeGain = 1;
}

void vUpdateHpaMm1PIDValues(float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateHpaMm1PIDValues);
  cmock_call_instance = (CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateHpaMm1PIDValues_CallInstance);
  Mock.vUpdateHpaMm1PIDValues_CallInstance = CMock_Guts_MemNext(Mock.vUpdateHpaMm1PIDValues_CallInstance);
  if (Mock.vUpdateHpaMm1PIDValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateHpaMm1PIDValues_CallbackBool &&
      Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer(fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain, Mock.vUpdateHpaMm1PIDValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fHpaSingleProportional)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm1PIDValues,CMockString_fHpaSingleProportional);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleProportional, fHpaSingleProportional, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm1PIDValues,CMockString_fHpaSingleIntegralGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleIntegralGain, fHpaSingleIntegralGain, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm1PIDValues,CMockString_fHpaSingleDerivativeGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleDerivativeGain, fHpaSingleDerivativeGain, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer(fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain, Mock.vUpdateHpaMm1PIDValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vUpdateHpaMm1PIDValues(CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain);
void CMockExpectParameters_vUpdateHpaMm1PIDValues(CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  cmock_call_instance->Expected_fHpaSingleProportional = fHpaSingleProportional;
  cmock_call_instance->IgnoreArg_fHpaSingleProportional = 0;
  cmock_call_instance->Expected_fHpaSingleIntegralGain = fHpaSingleIntegralGain;
  cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain = 0;
  cmock_call_instance->Expected_fHpaSingleDerivativeGain = fHpaSingleDerivativeGain;
  cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain = 0;
}

void vUpdateHpaMm1PIDValues_CMockIgnore(void)
{
  Mock.vUpdateHpaMm1PIDValues_IgnoreBool = (char)1;
}

void vUpdateHpaMm1PIDValues_CMockStopIgnore(void)
{
  Mock.vUpdateHpaMm1PIDValues_IgnoreBool = (char)0;
}

void vUpdateHpaMm1PIDValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaMm1PIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaMm1PIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaMm1PIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vUpdateHpaMm1PIDValues_CMockExpect(UNITY_LINE_TYPE cmock_line, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaMm1PIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaMm1PIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaMm1PIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUpdateHpaMm1PIDValues(cmock_call_instance, fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain);
}

void vUpdateHpaMm1PIDValues_AddCallback(CMOCK_vUpdateHpaMm1PIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaMm1PIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaMm1PIDValues_CallbackBool = (char)1;
  Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaMm1PIDValues_Stub(CMOCK_vUpdateHpaMm1PIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaMm1PIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaMm1PIDValues_CallbackBool = (char)0;
  Mock.vUpdateHpaMm1PIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaMm1PIDValues_CMockIgnoreArg_fHpaSingleProportional(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm1PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleProportional = 1;
}

void vUpdateHpaMm1PIDValues_CMockIgnoreArg_fHpaSingleIntegralGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm1PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain = 1;
}

void vUpdateHpaMm1PIDValues_CMockIgnoreArg_fHpaSingleDerivativeGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm1PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain = 1;
}

void vUpdateHpaMm2PIDValues(float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateHpaMm2PIDValues);
  cmock_call_instance = (CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateHpaMm2PIDValues_CallInstance);
  Mock.vUpdateHpaMm2PIDValues_CallInstance = CMock_Guts_MemNext(Mock.vUpdateHpaMm2PIDValues_CallInstance);
  if (Mock.vUpdateHpaMm2PIDValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateHpaMm2PIDValues_CallbackBool &&
      Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer(fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain, Mock.vUpdateHpaMm2PIDValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fHpaSingleProportional)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm2PIDValues,CMockString_fHpaSingleProportional);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleProportional, fHpaSingleProportional, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm2PIDValues,CMockString_fHpaSingleIntegralGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleIntegralGain, fHpaSingleIntegralGain, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm2PIDValues,CMockString_fHpaSingleDerivativeGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaSingleDerivativeGain, fHpaSingleDerivativeGain, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer(fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain, Mock.vUpdateHpaMm2PIDValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vUpdateHpaMm2PIDValues(CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain);
void CMockExpectParameters_vUpdateHpaMm2PIDValues(CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  cmock_call_instance->Expected_fHpaSingleProportional = fHpaSingleProportional;
  cmock_call_instance->IgnoreArg_fHpaSingleProportional = 0;
  cmock_call_instance->Expected_fHpaSingleIntegralGain = fHpaSingleIntegralGain;
  cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain = 0;
  cmock_call_instance->Expected_fHpaSingleDerivativeGain = fHpaSingleDerivativeGain;
  cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain = 0;
}

void vUpdateHpaMm2PIDValues_CMockIgnore(void)
{
  Mock.vUpdateHpaMm2PIDValues_IgnoreBool = (char)1;
}

void vUpdateHpaMm2PIDValues_CMockStopIgnore(void)
{
  Mock.vUpdateHpaMm2PIDValues_IgnoreBool = (char)0;
}

void vUpdateHpaMm2PIDValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaMm2PIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaMm2PIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaMm2PIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vUpdateHpaMm2PIDValues_CMockExpect(UNITY_LINE_TYPE cmock_line, float fHpaSingleProportional, float fHpaSingleIntegralGain, float fHpaSingleDerivativeGain)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaMm2PIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaMm2PIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaMm2PIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUpdateHpaMm2PIDValues(cmock_call_instance, fHpaSingleProportional, fHpaSingleIntegralGain, fHpaSingleDerivativeGain);
}

void vUpdateHpaMm2PIDValues_AddCallback(CMOCK_vUpdateHpaMm2PIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaMm2PIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaMm2PIDValues_CallbackBool = (char)1;
  Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaMm2PIDValues_Stub(CMOCK_vUpdateHpaMm2PIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaMm2PIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaMm2PIDValues_CallbackBool = (char)0;
  Mock.vUpdateHpaMm2PIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaMm2PIDValues_CMockIgnoreArg_fHpaSingleProportional(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm2PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleProportional = 1;
}

void vUpdateHpaMm2PIDValues_CMockIgnoreArg_fHpaSingleIntegralGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm2PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleIntegralGain = 1;
}

void vUpdateHpaMm2PIDValues_CMockIgnoreArg_fHpaSingleDerivativeGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm2PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaSingleDerivativeGain = 1;
}

void vUpdateHpaMm1and2PIDValues(float fHpaMM1and2Proportional, float fHpaMM1and2IntegralGain, float fHpaMM1and2DerivativeGain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vUpdateHpaMm1and2PIDValues);
  cmock_call_instance = (CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vUpdateHpaMm1and2PIDValues_CallInstance);
  Mock.vUpdateHpaMm1and2PIDValues_CallInstance = CMock_Guts_MemNext(Mock.vUpdateHpaMm1and2PIDValues_CallInstance);
  if (Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vUpdateHpaMm1and2PIDValues_CallbackBool &&
      Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer(fHpaMM1and2Proportional, fHpaMM1and2IntegralGain, fHpaMM1and2DerivativeGain, Mock.vUpdateHpaMm1and2PIDValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fHpaMM1and2Proportional)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm1and2PIDValues,CMockString_fHpaMM1and2Proportional);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaMM1and2Proportional, fHpaMM1and2Proportional, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaMM1and2IntegralGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm1and2PIDValues,CMockString_fHpaMM1and2IntegralGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaMM1and2IntegralGain, fHpaMM1and2IntegralGain, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fHpaMM1and2DerivativeGain)
  {
    UNITY_SET_DETAILS(CMockString_vUpdateHpaMm1and2PIDValues,CMockString_fHpaMM1and2DerivativeGain);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fHpaMM1and2DerivativeGain, fHpaMM1and2DerivativeGain, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer != NULL)
  {
    Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer(fHpaMM1and2Proportional, fHpaMM1and2IntegralGain, fHpaMM1and2DerivativeGain, Mock.vUpdateHpaMm1and2PIDValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vUpdateHpaMm1and2PIDValues(CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaMM1and2Proportional, float fHpaMM1and2IntegralGain, float fHpaMM1and2DerivativeGain);
void CMockExpectParameters_vUpdateHpaMm1and2PIDValues(CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance, float fHpaMM1and2Proportional, float fHpaMM1and2IntegralGain, float fHpaMM1and2DerivativeGain)
{
  cmock_call_instance->Expected_fHpaMM1and2Proportional = fHpaMM1and2Proportional;
  cmock_call_instance->IgnoreArg_fHpaMM1and2Proportional = 0;
  cmock_call_instance->Expected_fHpaMM1and2IntegralGain = fHpaMM1and2IntegralGain;
  cmock_call_instance->IgnoreArg_fHpaMM1and2IntegralGain = 0;
  cmock_call_instance->Expected_fHpaMM1and2DerivativeGain = fHpaMM1and2DerivativeGain;
  cmock_call_instance->IgnoreArg_fHpaMM1and2DerivativeGain = 0;
}

void vUpdateHpaMm1and2PIDValues_CMockIgnore(void)
{
  Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool = (char)1;
}

void vUpdateHpaMm1and2PIDValues_CMockStopIgnore(void)
{
  Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool = (char)0;
}

void vUpdateHpaMm1and2PIDValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaMm1and2PIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaMm1and2PIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vUpdateHpaMm1and2PIDValues_CMockExpect(UNITY_LINE_TYPE cmock_line, float fHpaMM1and2Proportional, float fHpaMM1and2IntegralGain, float fHpaMM1and2DerivativeGain)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE));
  CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vUpdateHpaMm1and2PIDValues_CallInstance = CMock_Guts_MemChain(Mock.vUpdateHpaMm1and2PIDValues_CallInstance, cmock_guts_index);
  Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vUpdateHpaMm1and2PIDValues(cmock_call_instance, fHpaMM1and2Proportional, fHpaMM1and2IntegralGain, fHpaMM1and2DerivativeGain);
}

void vUpdateHpaMm1and2PIDValues_AddCallback(CMOCK_vUpdateHpaMm1and2PIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaMm1and2PIDValues_CallbackBool = (char)1;
  Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaMm1and2PIDValues_Stub(CMOCK_vUpdateHpaMm1and2PIDValues_CALLBACK Callback)
{
  Mock.vUpdateHpaMm1and2PIDValues_IgnoreBool = (char)0;
  Mock.vUpdateHpaMm1and2PIDValues_CallbackBool = (char)0;
  Mock.vUpdateHpaMm1and2PIDValues_CallbackFunctionPointer = Callback;
}

void vUpdateHpaMm1and2PIDValues_CMockIgnoreArg_fHpaMM1and2Proportional(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm1and2PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaMM1and2Proportional = 1;
}

void vUpdateHpaMm1and2PIDValues_CMockIgnoreArg_fHpaMM1and2IntegralGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm1and2PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaMM1and2IntegralGain = 1;
}

void vUpdateHpaMm1and2PIDValues_CMockIgnoreArg_fHpaMM1and2DerivativeGain(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vUpdateHpaMm1and2PIDValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vUpdateHpaMm1and2PIDValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fHpaMM1and2DerivativeGain = 1;
}

void vEnableLna(eBool_t bEnable)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEnableLna_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEnableLna);
  cmock_call_instance = (CMOCK_vEnableLna_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEnableLna_CallInstance);
  Mock.vEnableLna_CallInstance = CMock_Guts_MemNext(Mock.vEnableLna_CallInstance);
  if (Mock.vEnableLna_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEnableLna_CallbackBool &&
      Mock.vEnableLna_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableLna_CallbackFunctionPointer(bEnable, Mock.vEnableLna_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bEnable)
  {
    UNITY_SET_DETAILS(CMockString_vEnableLna,CMockString_bEnable);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEnableLna_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableLna_CallbackFunctionPointer(bEnable, Mock.vEnableLna_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEnableLna(CMOCK_vEnableLna_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable);
void CMockExpectParameters_vEnableLna(CMOCK_vEnableLna_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable)
{
  memcpy((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable),
         sizeof(eBool_t[sizeof(bEnable) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bEnable = 0;
}

void vEnableLna_CMockIgnore(void)
{
  Mock.vEnableLna_IgnoreBool = (char)1;
}

void vEnableLna_CMockStopIgnore(void)
{
  Mock.vEnableLna_IgnoreBool = (char)0;
}

void vEnableLna_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableLna_CALL_INSTANCE));
  CMOCK_vEnableLna_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableLna_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableLna_CallInstance = CMock_Guts_MemChain(Mock.vEnableLna_CallInstance, cmock_guts_index);
  Mock.vEnableLna_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEnableLna_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bEnable)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableLna_CALL_INSTANCE));
  CMOCK_vEnableLna_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableLna_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableLna_CallInstance = CMock_Guts_MemChain(Mock.vEnableLna_CallInstance, cmock_guts_index);
  Mock.vEnableLna_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEnableLna(cmock_call_instance, bEnable);
}

void vEnableLna_AddCallback(CMOCK_vEnableLna_CALLBACK Callback)
{
  Mock.vEnableLna_IgnoreBool = (char)0;
  Mock.vEnableLna_CallbackBool = (char)1;
  Mock.vEnableLna_CallbackFunctionPointer = Callback;
}

void vEnableLna_Stub(CMOCK_vEnableLna_CALLBACK Callback)
{
  Mock.vEnableLna_IgnoreBool = (char)0;
  Mock.vEnableLna_CallbackBool = (char)0;
  Mock.vEnableLna_CallbackFunctionPointer = Callback;
}

void vEnableLna_CMockIgnoreArg_bEnable(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEnableLna_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableLna_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEnableLna_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bEnable = 1;
}

void vEnableHpaSingleMode(eBool_t bEnable)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEnableHpaSingleMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEnableHpaSingleMode);
  cmock_call_instance = (CMOCK_vEnableHpaSingleMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEnableHpaSingleMode_CallInstance);
  Mock.vEnableHpaSingleMode_CallInstance = CMock_Guts_MemNext(Mock.vEnableHpaSingleMode_CallInstance);
  if (Mock.vEnableHpaSingleMode_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEnableHpaSingleMode_CallbackBool &&
      Mock.vEnableHpaSingleMode_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableHpaSingleMode_CallbackFunctionPointer(bEnable, Mock.vEnableHpaSingleMode_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bEnable)
  {
    UNITY_SET_DETAILS(CMockString_vEnableHpaSingleMode,CMockString_bEnable);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEnableHpaSingleMode_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableHpaSingleMode_CallbackFunctionPointer(bEnable, Mock.vEnableHpaSingleMode_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEnableHpaSingleMode(CMOCK_vEnableHpaSingleMode_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable);
void CMockExpectParameters_vEnableHpaSingleMode(CMOCK_vEnableHpaSingleMode_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable)
{
  memcpy((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable),
         sizeof(eBool_t[sizeof(bEnable) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bEnable = 0;
}

void vEnableHpaSingleMode_CMockIgnore(void)
{
  Mock.vEnableHpaSingleMode_IgnoreBool = (char)1;
}

void vEnableHpaSingleMode_CMockStopIgnore(void)
{
  Mock.vEnableHpaSingleMode_IgnoreBool = (char)0;
}

void vEnableHpaSingleMode_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableHpaSingleMode_CALL_INSTANCE));
  CMOCK_vEnableHpaSingleMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaSingleMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableHpaSingleMode_CallInstance = CMock_Guts_MemChain(Mock.vEnableHpaSingleMode_CallInstance, cmock_guts_index);
  Mock.vEnableHpaSingleMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEnableHpaSingleMode_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bEnable)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableHpaSingleMode_CALL_INSTANCE));
  CMOCK_vEnableHpaSingleMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaSingleMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableHpaSingleMode_CallInstance = CMock_Guts_MemChain(Mock.vEnableHpaSingleMode_CallInstance, cmock_guts_index);
  Mock.vEnableHpaSingleMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEnableHpaSingleMode(cmock_call_instance, bEnable);
}

void vEnableHpaSingleMode_AddCallback(CMOCK_vEnableHpaSingleMode_CALLBACK Callback)
{
  Mock.vEnableHpaSingleMode_IgnoreBool = (char)0;
  Mock.vEnableHpaSingleMode_CallbackBool = (char)1;
  Mock.vEnableHpaSingleMode_CallbackFunctionPointer = Callback;
}

void vEnableHpaSingleMode_Stub(CMOCK_vEnableHpaSingleMode_CALLBACK Callback)
{
  Mock.vEnableHpaSingleMode_IgnoreBool = (char)0;
  Mock.vEnableHpaSingleMode_CallbackBool = (char)0;
  Mock.vEnableHpaSingleMode_CallbackFunctionPointer = Callback;
}

void vEnableHpaSingleMode_CMockIgnoreArg_bEnable(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEnableHpaSingleMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaSingleMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEnableHpaSingleMode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bEnable = 1;
}

void vEnableHpaMultiMode1(eBool_t bEnable)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEnableHpaMultiMode1);
  cmock_call_instance = (CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEnableHpaMultiMode1_CallInstance);
  Mock.vEnableHpaMultiMode1_CallInstance = CMock_Guts_MemNext(Mock.vEnableHpaMultiMode1_CallInstance);
  if (Mock.vEnableHpaMultiMode1_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEnableHpaMultiMode1_CallbackBool &&
      Mock.vEnableHpaMultiMode1_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableHpaMultiMode1_CallbackFunctionPointer(bEnable, Mock.vEnableHpaMultiMode1_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bEnable)
  {
    UNITY_SET_DETAILS(CMockString_vEnableHpaMultiMode1,CMockString_bEnable);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEnableHpaMultiMode1_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableHpaMultiMode1_CallbackFunctionPointer(bEnable, Mock.vEnableHpaMultiMode1_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEnableHpaMultiMode1(CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable);
void CMockExpectParameters_vEnableHpaMultiMode1(CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable)
{
  memcpy((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable),
         sizeof(eBool_t[sizeof(bEnable) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bEnable = 0;
}

void vEnableHpaMultiMode1_CMockIgnore(void)
{
  Mock.vEnableHpaMultiMode1_IgnoreBool = (char)1;
}

void vEnableHpaMultiMode1_CMockStopIgnore(void)
{
  Mock.vEnableHpaMultiMode1_IgnoreBool = (char)0;
}

void vEnableHpaMultiMode1_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE));
  CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableHpaMultiMode1_CallInstance = CMock_Guts_MemChain(Mock.vEnableHpaMultiMode1_CallInstance, cmock_guts_index);
  Mock.vEnableHpaMultiMode1_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEnableHpaMultiMode1_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bEnable)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE));
  CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableHpaMultiMode1_CallInstance = CMock_Guts_MemChain(Mock.vEnableHpaMultiMode1_CallInstance, cmock_guts_index);
  Mock.vEnableHpaMultiMode1_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEnableHpaMultiMode1(cmock_call_instance, bEnable);
}

void vEnableHpaMultiMode1_AddCallback(CMOCK_vEnableHpaMultiMode1_CALLBACK Callback)
{
  Mock.vEnableHpaMultiMode1_IgnoreBool = (char)0;
  Mock.vEnableHpaMultiMode1_CallbackBool = (char)1;
  Mock.vEnableHpaMultiMode1_CallbackFunctionPointer = Callback;
}

void vEnableHpaMultiMode1_Stub(CMOCK_vEnableHpaMultiMode1_CALLBACK Callback)
{
  Mock.vEnableHpaMultiMode1_IgnoreBool = (char)0;
  Mock.vEnableHpaMultiMode1_CallbackBool = (char)0;
  Mock.vEnableHpaMultiMode1_CallbackFunctionPointer = Callback;
}

void vEnableHpaMultiMode1_CMockIgnoreArg_bEnable(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaMultiMode1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEnableHpaMultiMode1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bEnable = 1;
}

void vEnableHpaMultiMode2(eBool_t bEnable)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEnableHpaMultiMode2);
  cmock_call_instance = (CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEnableHpaMultiMode2_CallInstance);
  Mock.vEnableHpaMultiMode2_CallInstance = CMock_Guts_MemNext(Mock.vEnableHpaMultiMode2_CallInstance);
  if (Mock.vEnableHpaMultiMode2_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEnableHpaMultiMode2_CallbackBool &&
      Mock.vEnableHpaMultiMode2_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableHpaMultiMode2_CallbackFunctionPointer(bEnable, Mock.vEnableHpaMultiMode2_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_bEnable)
  {
    UNITY_SET_DETAILS(CMockString_vEnableHpaMultiMode2,CMockString_bEnable);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable), sizeof(eBool_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEnableHpaMultiMode2_CallbackFunctionPointer != NULL)
  {
    Mock.vEnableHpaMultiMode2_CallbackFunctionPointer(bEnable, Mock.vEnableHpaMultiMode2_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEnableHpaMultiMode2(CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable);
void CMockExpectParameters_vEnableHpaMultiMode2(CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE* cmock_call_instance, eBool_t bEnable)
{
  memcpy((void*)(&cmock_call_instance->Expected_bEnable), (void*)(&bEnable),
         sizeof(eBool_t[sizeof(bEnable) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bEnable = 0;
}

void vEnableHpaMultiMode2_CMockIgnore(void)
{
  Mock.vEnableHpaMultiMode2_IgnoreBool = (char)1;
}

void vEnableHpaMultiMode2_CMockStopIgnore(void)
{
  Mock.vEnableHpaMultiMode2_IgnoreBool = (char)0;
}

void vEnableHpaMultiMode2_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE));
  CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableHpaMultiMode2_CallInstance = CMock_Guts_MemChain(Mock.vEnableHpaMultiMode2_CallInstance, cmock_guts_index);
  Mock.vEnableHpaMultiMode2_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEnableHpaMultiMode2_CMockExpect(UNITY_LINE_TYPE cmock_line, eBool_t bEnable)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE));
  CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEnableHpaMultiMode2_CallInstance = CMock_Guts_MemChain(Mock.vEnableHpaMultiMode2_CallInstance, cmock_guts_index);
  Mock.vEnableHpaMultiMode2_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEnableHpaMultiMode2(cmock_call_instance, bEnable);
}

void vEnableHpaMultiMode2_AddCallback(CMOCK_vEnableHpaMultiMode2_CALLBACK Callback)
{
  Mock.vEnableHpaMultiMode2_IgnoreBool = (char)0;
  Mock.vEnableHpaMultiMode2_CallbackBool = (char)1;
  Mock.vEnableHpaMultiMode2_CallbackFunctionPointer = Callback;
}

void vEnableHpaMultiMode2_Stub(CMOCK_vEnableHpaMultiMode2_CALLBACK Callback)
{
  Mock.vEnableHpaMultiMode2_IgnoreBool = (char)0;
  Mock.vEnableHpaMultiMode2_CallbackBool = (char)0;
  Mock.vEnableHpaMultiMode2_CallbackFunctionPointer = Callback;
}

void vEnableHpaMultiMode2_CMockIgnoreArg_bEnable(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEnableHpaMultiMode2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEnableHpaMultiMode2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bEnable = 1;
}

xPumpTemperaturesLimits_t* vpGetPumpTemperatureLimits(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vpGetPumpTemperatureLimits);
  cmock_call_instance = (CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vpGetPumpTemperatureLimits_CallInstance);
  Mock.vpGetPumpTemperatureLimits_CallInstance = CMock_Guts_MemNext(Mock.vpGetPumpTemperatureLimits_CallInstance);
  if (Mock.vpGetPumpTemperatureLimits_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.vpGetPumpTemperatureLimits_FinalReturn;
    Mock.vpGetPumpTemperatureLimits_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.vpGetPumpTemperatureLimits_CallbackBool &&
      Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer != NULL)
  {
    xPumpTemperaturesLimits_t* cmock_cb_ret = Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer(Mock.vpGetPumpTemperatureLimits_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer(Mock.vpGetPumpTemperatureLimits_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void vpGetPumpTemperatureLimits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, xPumpTemperaturesLimits_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE));
  CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE* cmock_call_instance = (CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vpGetPumpTemperatureLimits_CallInstance = CMock_Guts_MemChain(Mock.vpGetPumpTemperatureLimits_CallInstance, cmock_guts_index);
  Mock.vpGetPumpTemperatureLimits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vpGetPumpTemperatureLimits_IgnoreBool = (char)1;
}

void vpGetPumpTemperatureLimits_CMockStopIgnore(void)
{
  if(Mock.vpGetPumpTemperatureLimits_IgnoreBool)
    Mock.vpGetPumpTemperatureLimits_CallInstance = CMock_Guts_MemNext(Mock.vpGetPumpTemperatureLimits_CallInstance);
  Mock.vpGetPumpTemperatureLimits_IgnoreBool = (char)0;
}

void vpGetPumpTemperatureLimits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, xPumpTemperaturesLimits_t* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE));
  CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE* cmock_call_instance = (CMOCK_vpGetPumpTemperatureLimits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vpGetPumpTemperatureLimits_CallInstance = CMock_Guts_MemChain(Mock.vpGetPumpTemperatureLimits_CallInstance, cmock_guts_index);
  Mock.vpGetPumpTemperatureLimits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vpGetPumpTemperatureLimits_AddCallback(CMOCK_vpGetPumpTemperatureLimits_CALLBACK Callback)
{
  Mock.vpGetPumpTemperatureLimits_IgnoreBool = (char)0;
  Mock.vpGetPumpTemperatureLimits_CallbackBool = (char)1;
  Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer = Callback;
}

void vpGetPumpTemperatureLimits_Stub(CMOCK_vpGetPumpTemperatureLimits_CALLBACK Callback)
{
  Mock.vpGetPumpTemperatureLimits_IgnoreBool = (char)0;
  Mock.vpGetPumpTemperatureLimits_CallbackBool = (char)0;
  Mock.vpGetPumpTemperatureLimits_CallbackFunctionPointer = Callback;
}

