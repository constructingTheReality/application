/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_controlLaserPID.h"

static const char* CMockString_bControlLaserDeltaTimeHasChanged = "bControlLaserDeltaTimeHasChanged";
static const char* CMockString_eBeaconId = "eBeaconId";
static const char* CMockString_eBeacon_Id = "eBeacon_Id";
static const char* CMockString_ePIDID = "ePIDID";
static const char* CMockString_fReference = "fReference";
static const char* CMockString_fReferenceFeedback = "fReferenceFeedback";
static const char* CMockString_kd = "kd";
static const char* CMockString_ki = "ki";
static const char* CMockString_kp = "kp";
static const char* CMockString_pfControlCurrent = "pfControlCurrent";
static const char* CMockString_pxPidValues = "pxPidValues";
static const char* CMockString_ulAccLoopControlInterval = "ulAccLoopControlInterval";
static const char* CMockString_ulDeltaTime = "ulDeltaTime";
static const char* CMockString_vControlLaserPIDInit = "vControlLaserPIDInit";
static const char* CMockString_vControlLaserPIDReset = "vControlLaserPIDReset";
static const char* CMockString_vControlLaserPIDUpdate = "vControlLaserPIDUpdate";
static const char* CMockString_vGetPidValues = "vGetPidValues";
static const char* CMockString_vSetHpaPidDefaultValues = "vSetHpaPidDefaultValues";
static const char* CMockString_vSetHpaPidNvmValues = "vSetHpaPidNvmValues";
static const char* CMockString_vSetInternalPidValues = "vSetInternalPidValues";
static const char* CMockString_vSetLnaPidDefaultValues = "vSetLnaPidDefaultValues";
static const char* CMockString_vSetPidValues = "vSetPidValues";

typedef struct _CMOCK_vControlLaserPIDInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  ePIDID_t Expected_ePIDID;
  uint32_t Expected_ulAccLoopControlInterval;
  xPidValues_t* Expected_pxPidValues;
  int Expected_pxPidValues_Depth;
  char ReturnThruPtr_pxPidValues_Used;
  xPidValues_t* ReturnThruPtr_pxPidValues_Val;
  size_t ReturnThruPtr_pxPidValues_Size;
  char IgnoreArg_ePIDID;
  char IgnoreArg_ulAccLoopControlInterval;
  char IgnoreArg_pxPidValues;

} CMOCK_vControlLaserPIDInit_CALL_INSTANCE;

typedef struct _CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE;

typedef struct _CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE;

typedef struct _CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE;

typedef struct _CMOCK_vSetPidValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  handle_t Expected_eBeacon_Id;
  float Expected_kp;
  float Expected_ki;
  float Expected_kd;
  char IgnoreArg_eBeacon_Id;
  char IgnoreArg_kp;
  char IgnoreArg_ki;
  char IgnoreArg_kd;

} CMOCK_vSetPidValues_CALL_INSTANCE;

typedef struct _CMOCK_vSetInternalPidValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  handle_t Expected_eBeacon_Id;
  float Expected_kp;
  float Expected_ki;
  float Expected_kd;
  char IgnoreArg_eBeacon_Id;
  char IgnoreArg_kp;
  char IgnoreArg_ki;
  char IgnoreArg_kd;

} CMOCK_vSetInternalPidValues_CALL_INSTANCE;

typedef struct _CMOCK_vGetPidValues_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  handle_t Expected_eBeacon_Id;
  float* Expected_kp;
  float* Expected_ki;
  float* Expected_kd;
  int Expected_kp_Depth;
  int Expected_ki_Depth;
  int Expected_kd_Depth;
  char ReturnThruPtr_kp_Used;
  float* ReturnThruPtr_kp_Val;
  size_t ReturnThruPtr_kp_Size;
  char ReturnThruPtr_ki_Used;
  float* ReturnThruPtr_ki_Val;
  size_t ReturnThruPtr_ki_Size;
  char ReturnThruPtr_kd_Used;
  float* ReturnThruPtr_kd_Val;
  size_t ReturnThruPtr_kd_Size;
  char IgnoreArg_eBeacon_Id;
  char IgnoreArg_kp;
  char IgnoreArg_ki;
  char IgnoreArg_kd;

} CMOCK_vGetPidValues_CALL_INSTANCE;

typedef struct _CMOCK_vControlLaserPIDReset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  ePIDID_t Expected_ePIDID;
  char IgnoreArg_ePIDID;

} CMOCK_vControlLaserPIDReset_CALL_INSTANCE;

typedef struct _CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eBool_t ReturnVal;
  int CallOrder;
  ePIDID_t Expected_ePIDID;
  uint32_t Expected_ulDeltaTime;
  char IgnoreArg_ePIDID;
  char IgnoreArg_ulDeltaTime;

} CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE;

typedef struct _CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  float Expected_fReference;
  float Expected_fReferenceFeedback;
  uint8_t Expected_eBeaconId;
  float* Expected_pfControlCurrent;
  int Expected_pfControlCurrent_Depth;
  char ReturnThruPtr_pfControlCurrent_Used;
  float* ReturnThruPtr_pfControlCurrent_Val;
  size_t ReturnThruPtr_pfControlCurrent_Size;
  char IgnoreArg_fReference;
  char IgnoreArg_fReferenceFeedback;
  char IgnoreArg_eBeaconId;
  char IgnoreArg_pfControlCurrent;

} CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE;

static struct mock_controlLaserPIDInstance
{
  char vControlLaserPIDInit_IgnoreBool;
  char vControlLaserPIDInit_CallbackBool;
  CMOCK_vControlLaserPIDInit_CALLBACK vControlLaserPIDInit_CallbackFunctionPointer;
  int vControlLaserPIDInit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vControlLaserPIDInit_CallInstance;
  char vSetLnaPidDefaultValues_IgnoreBool;
  char vSetLnaPidDefaultValues_CallbackBool;
  CMOCK_vSetLnaPidDefaultValues_CALLBACK vSetLnaPidDefaultValues_CallbackFunctionPointer;
  int vSetLnaPidDefaultValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetLnaPidDefaultValues_CallInstance;
  char vSetHpaPidDefaultValues_IgnoreBool;
  char vSetHpaPidDefaultValues_CallbackBool;
  CMOCK_vSetHpaPidDefaultValues_CALLBACK vSetHpaPidDefaultValues_CallbackFunctionPointer;
  int vSetHpaPidDefaultValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetHpaPidDefaultValues_CallInstance;
  char vSetHpaPidNvmValues_IgnoreBool;
  char vSetHpaPidNvmValues_CallbackBool;
  CMOCK_vSetHpaPidNvmValues_CALLBACK vSetHpaPidNvmValues_CallbackFunctionPointer;
  int vSetHpaPidNvmValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetHpaPidNvmValues_CallInstance;
  char vSetPidValues_IgnoreBool;
  char vSetPidValues_CallbackBool;
  CMOCK_vSetPidValues_CALLBACK vSetPidValues_CallbackFunctionPointer;
  int vSetPidValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetPidValues_CallInstance;
  char vSetInternalPidValues_IgnoreBool;
  char vSetInternalPidValues_CallbackBool;
  CMOCK_vSetInternalPidValues_CALLBACK vSetInternalPidValues_CallbackFunctionPointer;
  int vSetInternalPidValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vSetInternalPidValues_CallInstance;
  char vGetPidValues_IgnoreBool;
  char vGetPidValues_CallbackBool;
  CMOCK_vGetPidValues_CALLBACK vGetPidValues_CallbackFunctionPointer;
  int vGetPidValues_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGetPidValues_CallInstance;
  char vControlLaserPIDReset_IgnoreBool;
  char vControlLaserPIDReset_CallbackBool;
  CMOCK_vControlLaserPIDReset_CALLBACK vControlLaserPIDReset_CallbackFunctionPointer;
  int vControlLaserPIDReset_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vControlLaserPIDReset_CallInstance;
  char bControlLaserDeltaTimeHasChanged_IgnoreBool;
  eBool_t bControlLaserDeltaTimeHasChanged_FinalReturn;
  char bControlLaserDeltaTimeHasChanged_CallbackBool;
  CMOCK_bControlLaserDeltaTimeHasChanged_CALLBACK bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer;
  int bControlLaserDeltaTimeHasChanged_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bControlLaserDeltaTimeHasChanged_CallInstance;
  char vControlLaserPIDUpdate_IgnoreBool;
  char vControlLaserPIDUpdate_CallbackBool;
  CMOCK_vControlLaserPIDUpdate_CALLBACK vControlLaserPIDUpdate_CallbackFunctionPointer;
  int vControlLaserPIDUpdate_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vControlLaserPIDUpdate_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_controlLaserPID_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.vControlLaserPIDInit_CallInstance;
  if (Mock.vControlLaserPIDInit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vControlLaserPIDInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vControlLaserPIDInit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetLnaPidDefaultValues_CallInstance;
  if (Mock.vSetLnaPidDefaultValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetLnaPidDefaultValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetHpaPidDefaultValues_CallInstance;
  if (Mock.vSetHpaPidDefaultValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetHpaPidDefaultValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetHpaPidNvmValues_CallInstance;
  if (Mock.vSetHpaPidNvmValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetHpaPidNvmValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetHpaPidNvmValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetPidValues_CallInstance;
  if (Mock.vSetPidValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetPidValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetPidValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vSetInternalPidValues_CallInstance;
  if (Mock.vSetInternalPidValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vSetInternalPidValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vSetInternalPidValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGetPidValues_CallInstance;
  if (Mock.vGetPidValues_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGetPidValues);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGetPidValues_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vControlLaserPIDReset_CallInstance;
  if (Mock.vControlLaserPIDReset_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vControlLaserPIDReset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vControlLaserPIDReset_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.bControlLaserDeltaTimeHasChanged_CallInstance;
  if (Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_bControlLaserDeltaTimeHasChanged);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vControlLaserPIDUpdate_CallInstance;
  if (Mock.vControlLaserPIDUpdate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vControlLaserPIDUpdate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vControlLaserPIDUpdate_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_controlLaserPID_Init(void)
{
  mock_controlLaserPID_Destroy();
}

void mock_controlLaserPID_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

void vControlLaserPIDInit(ePIDID_t ePIDID, uint32_t ulAccLoopControlInterval, xPidValues_t* pxPidValues)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vControlLaserPIDInit);
  cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vControlLaserPIDInit_CallInstance);
  Mock.vControlLaserPIDInit_CallInstance = CMock_Guts_MemNext(Mock.vControlLaserPIDInit_CallInstance);
  if (Mock.vControlLaserPIDInit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vControlLaserPIDInit_CallbackBool &&
      Mock.vControlLaserPIDInit_CallbackFunctionPointer != NULL)
  {
    Mock.vControlLaserPIDInit_CallbackFunctionPointer(ePIDID, ulAccLoopControlInterval, pxPidValues, Mock.vControlLaserPIDInit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ePIDID)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDInit,CMockString_ePIDID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ePIDID), (void*)(&ePIDID), sizeof(ePIDID_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulAccLoopControlInterval)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDInit,CMockString_ulAccLoopControlInterval);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulAccLoopControlInterval, ulAccLoopControlInterval, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxPidValues)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDInit,CMockString_pxPidValues);
    if (cmock_call_instance->Expected_pxPidValues == NULL)
      { UNITY_TEST_ASSERT_NULL(pxPidValues, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxPidValues), (void*)(pxPidValues), sizeof(xPidValues_t), cmock_call_instance->Expected_pxPidValues_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vControlLaserPIDInit_CallbackFunctionPointer != NULL)
  {
    Mock.vControlLaserPIDInit_CallbackFunctionPointer(ePIDID, ulAccLoopControlInterval, pxPidValues, Mock.vControlLaserPIDInit_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxPidValues_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxPidValues, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxPidValues, (void*)cmock_call_instance->ReturnThruPtr_pxPidValues_Val,
      cmock_call_instance->ReturnThruPtr_pxPidValues_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vControlLaserPIDInit(CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance, ePIDID_t ePIDID, uint32_t ulAccLoopControlInterval, xPidValues_t* pxPidValues, int pxPidValues_Depth);
void CMockExpectParameters_vControlLaserPIDInit(CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance, ePIDID_t ePIDID, uint32_t ulAccLoopControlInterval, xPidValues_t* pxPidValues, int pxPidValues_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_ePIDID), (void*)(&ePIDID),
         sizeof(ePIDID_t[sizeof(ePIDID) == sizeof(ePIDID_t) ? 1 : -1])); /* add ePIDID_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ePIDID = 0;
  cmock_call_instance->Expected_ulAccLoopControlInterval = ulAccLoopControlInterval;
  cmock_call_instance->IgnoreArg_ulAccLoopControlInterval = 0;
  cmock_call_instance->Expected_pxPidValues = pxPidValues;
  cmock_call_instance->Expected_pxPidValues_Depth = pxPidValues_Depth;
  cmock_call_instance->IgnoreArg_pxPidValues = 0;
  cmock_call_instance->ReturnThruPtr_pxPidValues_Used = 0;
}

void vControlLaserPIDInit_CMockIgnore(void)
{
  Mock.vControlLaserPIDInit_IgnoreBool = (char)1;
}

void vControlLaserPIDInit_CMockStopIgnore(void)
{
  Mock.vControlLaserPIDInit_IgnoreBool = (char)0;
}

void vControlLaserPIDInit_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDInit_CALL_INSTANCE));
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDInit_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDInit_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vControlLaserPIDInit_CMockExpect(UNITY_LINE_TYPE cmock_line, ePIDID_t ePIDID, uint32_t ulAccLoopControlInterval, xPidValues_t* pxPidValues)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDInit_CALL_INSTANCE));
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDInit_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDInit_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vControlLaserPIDInit(cmock_call_instance, ePIDID, ulAccLoopControlInterval, pxPidValues, 1);
}

void vControlLaserPIDInit_AddCallback(CMOCK_vControlLaserPIDInit_CALLBACK Callback)
{
  Mock.vControlLaserPIDInit_IgnoreBool = (char)0;
  Mock.vControlLaserPIDInit_CallbackBool = (char)1;
  Mock.vControlLaserPIDInit_CallbackFunctionPointer = Callback;
}

void vControlLaserPIDInit_Stub(CMOCK_vControlLaserPIDInit_CALLBACK Callback)
{
  Mock.vControlLaserPIDInit_IgnoreBool = (char)0;
  Mock.vControlLaserPIDInit_CallbackBool = (char)0;
  Mock.vControlLaserPIDInit_CallbackFunctionPointer = Callback;
}

void vControlLaserPIDInit_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, ePIDID_t ePIDID, uint32_t ulAccLoopControlInterval, xPidValues_t* pxPidValues, int pxPidValues_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDInit_CALL_INSTANCE));
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDInit_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDInit_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vControlLaserPIDInit(cmock_call_instance, ePIDID, ulAccLoopControlInterval, pxPidValues, pxPidValues_Depth);
}

void vControlLaserPIDInit_CMockReturnMemThruPtr_pxPidValues(UNITY_LINE_TYPE cmock_line, xPidValues_t* pxPidValues, size_t cmock_size)
{
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDInit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxPidValues_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxPidValues_Val = pxPidValues;
  cmock_call_instance->ReturnThruPtr_pxPidValues_Size = cmock_size;
}

void vControlLaserPIDInit_CMockIgnoreArg_ePIDID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDInit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ePIDID = 1;
}

void vControlLaserPIDInit_CMockIgnoreArg_ulAccLoopControlInterval(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDInit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulAccLoopControlInterval = 1;
}

void vControlLaserPIDInit_CMockIgnoreArg_pxPidValues(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDInit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxPidValues = 1;
}

void vSetLnaPidDefaultValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetLnaPidDefaultValues);
  cmock_call_instance = (CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetLnaPidDefaultValues_CallInstance);
  Mock.vSetLnaPidDefaultValues_CallInstance = CMock_Guts_MemNext(Mock.vSetLnaPidDefaultValues_CallInstance);
  if (Mock.vSetLnaPidDefaultValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetLnaPidDefaultValues_CallbackBool &&
      Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer(Mock.vSetLnaPidDefaultValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer(Mock.vSetLnaPidDefaultValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vSetLnaPidDefaultValues_CMockIgnore(void)
{
  Mock.vSetLnaPidDefaultValues_IgnoreBool = (char)1;
}

void vSetLnaPidDefaultValues_CMockStopIgnore(void)
{
  Mock.vSetLnaPidDefaultValues_IgnoreBool = (char)0;
}

void vSetLnaPidDefaultValues_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE));
  CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetLnaPidDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetLnaPidDefaultValues_CallInstance = CMock_Guts_MemChain(Mock.vSetLnaPidDefaultValues_CallInstance, cmock_guts_index);
  Mock.vSetLnaPidDefaultValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vSetLnaPidDefaultValues_AddCallback(CMOCK_vSetLnaPidDefaultValues_CALLBACK Callback)
{
  Mock.vSetLnaPidDefaultValues_IgnoreBool = (char)0;
  Mock.vSetLnaPidDefaultValues_CallbackBool = (char)1;
  Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer = Callback;
}

void vSetLnaPidDefaultValues_Stub(CMOCK_vSetLnaPidDefaultValues_CALLBACK Callback)
{
  Mock.vSetLnaPidDefaultValues_IgnoreBool = (char)0;
  Mock.vSetLnaPidDefaultValues_CallbackBool = (char)0;
  Mock.vSetLnaPidDefaultValues_CallbackFunctionPointer = Callback;
}

void vSetHpaPidDefaultValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetHpaPidDefaultValues);
  cmock_call_instance = (CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetHpaPidDefaultValues_CallInstance);
  Mock.vSetHpaPidDefaultValues_CallInstance = CMock_Guts_MemNext(Mock.vSetHpaPidDefaultValues_CallInstance);
  if (Mock.vSetHpaPidDefaultValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetHpaPidDefaultValues_CallbackBool &&
      Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer(Mock.vSetHpaPidDefaultValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer(Mock.vSetHpaPidDefaultValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vSetHpaPidDefaultValues_CMockIgnore(void)
{
  Mock.vSetHpaPidDefaultValues_IgnoreBool = (char)1;
}

void vSetHpaPidDefaultValues_CMockStopIgnore(void)
{
  Mock.vSetHpaPidDefaultValues_IgnoreBool = (char)0;
}

void vSetHpaPidDefaultValues_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE));
  CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetHpaPidDefaultValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetHpaPidDefaultValues_CallInstance = CMock_Guts_MemChain(Mock.vSetHpaPidDefaultValues_CallInstance, cmock_guts_index);
  Mock.vSetHpaPidDefaultValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vSetHpaPidDefaultValues_AddCallback(CMOCK_vSetHpaPidDefaultValues_CALLBACK Callback)
{
  Mock.vSetHpaPidDefaultValues_IgnoreBool = (char)0;
  Mock.vSetHpaPidDefaultValues_CallbackBool = (char)1;
  Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer = Callback;
}

void vSetHpaPidDefaultValues_Stub(CMOCK_vSetHpaPidDefaultValues_CALLBACK Callback)
{
  Mock.vSetHpaPidDefaultValues_IgnoreBool = (char)0;
  Mock.vSetHpaPidDefaultValues_CallbackBool = (char)0;
  Mock.vSetHpaPidDefaultValues_CallbackFunctionPointer = Callback;
}

void vSetHpaPidNvmValues(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetHpaPidNvmValues);
  cmock_call_instance = (CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetHpaPidNvmValues_CallInstance);
  Mock.vSetHpaPidNvmValues_CallInstance = CMock_Guts_MemNext(Mock.vSetHpaPidNvmValues_CallInstance);
  if (Mock.vSetHpaPidNvmValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetHpaPidNvmValues_CallbackBool &&
      Mock.vSetHpaPidNvmValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetHpaPidNvmValues_CallbackFunctionPointer(Mock.vSetHpaPidNvmValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vSetHpaPidNvmValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetHpaPidNvmValues_CallbackFunctionPointer(Mock.vSetHpaPidNvmValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vSetHpaPidNvmValues_CMockIgnore(void)
{
  Mock.vSetHpaPidNvmValues_IgnoreBool = (char)1;
}

void vSetHpaPidNvmValues_CMockStopIgnore(void)
{
  Mock.vSetHpaPidNvmValues_IgnoreBool = (char)0;
}

void vSetHpaPidNvmValues_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE));
  CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetHpaPidNvmValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetHpaPidNvmValues_CallInstance = CMock_Guts_MemChain(Mock.vSetHpaPidNvmValues_CallInstance, cmock_guts_index);
  Mock.vSetHpaPidNvmValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vSetHpaPidNvmValues_AddCallback(CMOCK_vSetHpaPidNvmValues_CALLBACK Callback)
{
  Mock.vSetHpaPidNvmValues_IgnoreBool = (char)0;
  Mock.vSetHpaPidNvmValues_CallbackBool = (char)1;
  Mock.vSetHpaPidNvmValues_CallbackFunctionPointer = Callback;
}

void vSetHpaPidNvmValues_Stub(CMOCK_vSetHpaPidNvmValues_CALLBACK Callback)
{
  Mock.vSetHpaPidNvmValues_IgnoreBool = (char)0;
  Mock.vSetHpaPidNvmValues_CallbackBool = (char)0;
  Mock.vSetHpaPidNvmValues_CallbackFunctionPointer = Callback;
}

void vSetPidValues(handle_t eBeacon_Id, float kp, float ki, float kd)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetPidValues);
  cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetPidValues_CallInstance);
  Mock.vSetPidValues_CallInstance = CMock_Guts_MemNext(Mock.vSetPidValues_CallInstance);
  if (Mock.vSetPidValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetPidValues_CallbackBool &&
      Mock.vSetPidValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetPidValues_CallbackFunctionPointer(eBeacon_Id, kp, ki, kd, Mock.vSetPidValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_eBeacon_Id)
  {
    UNITY_SET_DETAILS(CMockString_vSetPidValues,CMockString_eBeacon_Id);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eBeacon_Id), (void*)(&eBeacon_Id), sizeof(handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_kp)
  {
    UNITY_SET_DETAILS(CMockString_vSetPidValues,CMockString_kp);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_kp, kp, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ki)
  {
    UNITY_SET_DETAILS(CMockString_vSetPidValues,CMockString_ki);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_ki, ki, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_kd)
  {
    UNITY_SET_DETAILS(CMockString_vSetPidValues,CMockString_kd);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_kd, kd, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetPidValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetPidValues_CallbackFunctionPointer(eBeacon_Id, kp, ki, kd, Mock.vSetPidValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetPidValues(CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance, handle_t eBeacon_Id, float kp, float ki, float kd);
void CMockExpectParameters_vSetPidValues(CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance, handle_t eBeacon_Id, float kp, float ki, float kd)
{
  memcpy((void*)(&cmock_call_instance->Expected_eBeacon_Id), (void*)(&eBeacon_Id),
         sizeof(handle_t[sizeof(eBeacon_Id) == sizeof(handle_t) ? 1 : -1])); /* add handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eBeacon_Id = 0;
  cmock_call_instance->Expected_kp = kp;
  cmock_call_instance->IgnoreArg_kp = 0;
  cmock_call_instance->Expected_ki = ki;
  cmock_call_instance->IgnoreArg_ki = 0;
  cmock_call_instance->Expected_kd = kd;
  cmock_call_instance->IgnoreArg_kd = 0;
}

void vSetPidValues_CMockIgnore(void)
{
  Mock.vSetPidValues_IgnoreBool = (char)1;
}

void vSetPidValues_CMockStopIgnore(void)
{
  Mock.vSetPidValues_IgnoreBool = (char)0;
}

void vSetPidValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetPidValues_CALL_INSTANCE));
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetPidValues_CallInstance = CMock_Guts_MemChain(Mock.vSetPidValues_CallInstance, cmock_guts_index);
  Mock.vSetPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetPidValues_CMockExpect(UNITY_LINE_TYPE cmock_line, handle_t eBeacon_Id, float kp, float ki, float kd)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetPidValues_CALL_INSTANCE));
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetPidValues_CallInstance = CMock_Guts_MemChain(Mock.vSetPidValues_CallInstance, cmock_guts_index);
  Mock.vSetPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetPidValues(cmock_call_instance, eBeacon_Id, kp, ki, kd);
}

void vSetPidValues_AddCallback(CMOCK_vSetPidValues_CALLBACK Callback)
{
  Mock.vSetPidValues_IgnoreBool = (char)0;
  Mock.vSetPidValues_CallbackBool = (char)1;
  Mock.vSetPidValues_CallbackFunctionPointer = Callback;
}

void vSetPidValues_Stub(CMOCK_vSetPidValues_CALLBACK Callback)
{
  Mock.vSetPidValues_IgnoreBool = (char)0;
  Mock.vSetPidValues_CallbackBool = (char)0;
  Mock.vSetPidValues_CallbackFunctionPointer = Callback;
}

void vSetPidValues_CMockIgnoreArg_eBeacon_Id(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eBeacon_Id = 1;
}

void vSetPidValues_CMockIgnoreArg_kp(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_kp = 1;
}

void vSetPidValues_CMockIgnoreArg_ki(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ki = 1;
}

void vSetPidValues_CMockIgnoreArg_kd(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_kd = 1;
}

void vSetInternalPidValues(handle_t eBeacon_Id, float kp, float ki, float kd)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vSetInternalPidValues);
  cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vSetInternalPidValues_CallInstance);
  Mock.vSetInternalPidValues_CallInstance = CMock_Guts_MemNext(Mock.vSetInternalPidValues_CallInstance);
  if (Mock.vSetInternalPidValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vSetInternalPidValues_CallbackBool &&
      Mock.vSetInternalPidValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetInternalPidValues_CallbackFunctionPointer(eBeacon_Id, kp, ki, kd, Mock.vSetInternalPidValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_eBeacon_Id)
  {
    UNITY_SET_DETAILS(CMockString_vSetInternalPidValues,CMockString_eBeacon_Id);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eBeacon_Id), (void*)(&eBeacon_Id), sizeof(handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_kp)
  {
    UNITY_SET_DETAILS(CMockString_vSetInternalPidValues,CMockString_kp);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_kp, kp, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ki)
  {
    UNITY_SET_DETAILS(CMockString_vSetInternalPidValues,CMockString_ki);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_ki, ki, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_kd)
  {
    UNITY_SET_DETAILS(CMockString_vSetInternalPidValues,CMockString_kd);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_kd, kd, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vSetInternalPidValues_CallbackFunctionPointer != NULL)
  {
    Mock.vSetInternalPidValues_CallbackFunctionPointer(eBeacon_Id, kp, ki, kd, Mock.vSetInternalPidValues_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vSetInternalPidValues(CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance, handle_t eBeacon_Id, float kp, float ki, float kd);
void CMockExpectParameters_vSetInternalPidValues(CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance, handle_t eBeacon_Id, float kp, float ki, float kd)
{
  memcpy((void*)(&cmock_call_instance->Expected_eBeacon_Id), (void*)(&eBeacon_Id),
         sizeof(handle_t[sizeof(eBeacon_Id) == sizeof(handle_t) ? 1 : -1])); /* add handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eBeacon_Id = 0;
  cmock_call_instance->Expected_kp = kp;
  cmock_call_instance->IgnoreArg_kp = 0;
  cmock_call_instance->Expected_ki = ki;
  cmock_call_instance->IgnoreArg_ki = 0;
  cmock_call_instance->Expected_kd = kd;
  cmock_call_instance->IgnoreArg_kd = 0;
}

void vSetInternalPidValues_CMockIgnore(void)
{
  Mock.vSetInternalPidValues_IgnoreBool = (char)1;
}

void vSetInternalPidValues_CMockStopIgnore(void)
{
  Mock.vSetInternalPidValues_IgnoreBool = (char)0;
}

void vSetInternalPidValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetInternalPidValues_CALL_INSTANCE));
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetInternalPidValues_CallInstance = CMock_Guts_MemChain(Mock.vSetInternalPidValues_CallInstance, cmock_guts_index);
  Mock.vSetInternalPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vSetInternalPidValues_CMockExpect(UNITY_LINE_TYPE cmock_line, handle_t eBeacon_Id, float kp, float ki, float kd)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vSetInternalPidValues_CALL_INSTANCE));
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vSetInternalPidValues_CallInstance = CMock_Guts_MemChain(Mock.vSetInternalPidValues_CallInstance, cmock_guts_index);
  Mock.vSetInternalPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vSetInternalPidValues(cmock_call_instance, eBeacon_Id, kp, ki, kd);
}

void vSetInternalPidValues_AddCallback(CMOCK_vSetInternalPidValues_CALLBACK Callback)
{
  Mock.vSetInternalPidValues_IgnoreBool = (char)0;
  Mock.vSetInternalPidValues_CallbackBool = (char)1;
  Mock.vSetInternalPidValues_CallbackFunctionPointer = Callback;
}

void vSetInternalPidValues_Stub(CMOCK_vSetInternalPidValues_CALLBACK Callback)
{
  Mock.vSetInternalPidValues_IgnoreBool = (char)0;
  Mock.vSetInternalPidValues_CallbackBool = (char)0;
  Mock.vSetInternalPidValues_CallbackFunctionPointer = Callback;
}

void vSetInternalPidValues_CMockIgnoreArg_eBeacon_Id(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetInternalPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eBeacon_Id = 1;
}

void vSetInternalPidValues_CMockIgnoreArg_kp(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetInternalPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_kp = 1;
}

void vSetInternalPidValues_CMockIgnoreArg_ki(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetInternalPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ki = 1;
}

void vSetInternalPidValues_CMockIgnoreArg_kd(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vSetInternalPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vSetInternalPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vSetInternalPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_kd = 1;
}

void vGetPidValues(handle_t eBeacon_Id, float* kp, float* ki, float* kd)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGetPidValues);
  cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGetPidValues_CallInstance);
  Mock.vGetPidValues_CallInstance = CMock_Guts_MemNext(Mock.vGetPidValues_CallInstance);
  if (Mock.vGetPidValues_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vGetPidValues_CallbackBool &&
      Mock.vGetPidValues_CallbackFunctionPointer != NULL)
  {
    Mock.vGetPidValues_CallbackFunctionPointer(eBeacon_Id, kp, ki, kd, Mock.vGetPidValues_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_eBeacon_Id)
  {
    UNITY_SET_DETAILS(CMockString_vGetPidValues,CMockString_eBeacon_Id);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eBeacon_Id), (void*)(&eBeacon_Id), sizeof(handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_kp)
  {
    UNITY_SET_DETAILS(CMockString_vGetPidValues,CMockString_kp);
    if (cmock_call_instance->Expected_kp == NULL)
      { UNITY_TEST_ASSERT_NULL(kp, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_kp, kp, cmock_call_instance->Expected_kp_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ki)
  {
    UNITY_SET_DETAILS(CMockString_vGetPidValues,CMockString_ki);
    if (cmock_call_instance->Expected_ki == NULL)
      { UNITY_TEST_ASSERT_NULL(ki, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_ki, ki, cmock_call_instance->Expected_ki_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_kd)
  {
    UNITY_SET_DETAILS(CMockString_vGetPidValues,CMockString_kd);
    if (cmock_call_instance->Expected_kd == NULL)
      { UNITY_TEST_ASSERT_NULL(kd, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_kd, kd, cmock_call_instance->Expected_kd_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vGetPidValues_CallbackFunctionPointer != NULL)
  {
    Mock.vGetPidValues_CallbackFunctionPointer(eBeacon_Id, kp, ki, kd, Mock.vGetPidValues_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_kp_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(kp, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)kp, (void*)cmock_call_instance->ReturnThruPtr_kp_Val,
      cmock_call_instance->ReturnThruPtr_kp_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ki_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ki, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ki, (void*)cmock_call_instance->ReturnThruPtr_ki_Val,
      cmock_call_instance->ReturnThruPtr_ki_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_kd_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(kd, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)kd, (void*)cmock_call_instance->ReturnThruPtr_kd_Val,
      cmock_call_instance->ReturnThruPtr_kd_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vGetPidValues(CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance, handle_t eBeacon_Id, float* kp, int kp_Depth, float* ki, int ki_Depth, float* kd, int kd_Depth);
void CMockExpectParameters_vGetPidValues(CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance, handle_t eBeacon_Id, float* kp, int kp_Depth, float* ki, int ki_Depth, float* kd, int kd_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_eBeacon_Id), (void*)(&eBeacon_Id),
         sizeof(handle_t[sizeof(eBeacon_Id) == sizeof(handle_t) ? 1 : -1])); /* add handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eBeacon_Id = 0;
  cmock_call_instance->Expected_kp = kp;
  cmock_call_instance->Expected_kp_Depth = kp_Depth;
  cmock_call_instance->IgnoreArg_kp = 0;
  cmock_call_instance->ReturnThruPtr_kp_Used = 0;
  cmock_call_instance->Expected_ki = ki;
  cmock_call_instance->Expected_ki_Depth = ki_Depth;
  cmock_call_instance->IgnoreArg_ki = 0;
  cmock_call_instance->ReturnThruPtr_ki_Used = 0;
  cmock_call_instance->Expected_kd = kd;
  cmock_call_instance->Expected_kd_Depth = kd_Depth;
  cmock_call_instance->IgnoreArg_kd = 0;
  cmock_call_instance->ReturnThruPtr_kd_Used = 0;
}

void vGetPidValues_CMockIgnore(void)
{
  Mock.vGetPidValues_IgnoreBool = (char)1;
}

void vGetPidValues_CMockStopIgnore(void)
{
  Mock.vGetPidValues_IgnoreBool = (char)0;
}

void vGetPidValues_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetPidValues_CALL_INSTANCE));
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetPidValues_CallInstance = CMock_Guts_MemChain(Mock.vGetPidValues_CallInstance, cmock_guts_index);
  Mock.vGetPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vGetPidValues_CMockExpect(UNITY_LINE_TYPE cmock_line, handle_t eBeacon_Id, float* kp, float* ki, float* kd)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetPidValues_CALL_INSTANCE));
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetPidValues_CallInstance = CMock_Guts_MemChain(Mock.vGetPidValues_CallInstance, cmock_guts_index);
  Mock.vGetPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGetPidValues(cmock_call_instance, eBeacon_Id, kp, 1, ki, 1, kd, 1);
}

void vGetPidValues_AddCallback(CMOCK_vGetPidValues_CALLBACK Callback)
{
  Mock.vGetPidValues_IgnoreBool = (char)0;
  Mock.vGetPidValues_CallbackBool = (char)1;
  Mock.vGetPidValues_CallbackFunctionPointer = Callback;
}

void vGetPidValues_Stub(CMOCK_vGetPidValues_CALLBACK Callback)
{
  Mock.vGetPidValues_IgnoreBool = (char)0;
  Mock.vGetPidValues_CallbackBool = (char)0;
  Mock.vGetPidValues_CallbackFunctionPointer = Callback;
}

void vGetPidValues_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, handle_t eBeacon_Id, float* kp, int kp_Depth, float* ki, int ki_Depth, float* kd, int kd_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGetPidValues_CALL_INSTANCE));
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGetPidValues_CallInstance = CMock_Guts_MemChain(Mock.vGetPidValues_CallInstance, cmock_guts_index);
  Mock.vGetPidValues_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGetPidValues(cmock_call_instance, eBeacon_Id, kp, kp_Depth, ki, ki_Depth, kd, kd_Depth);
}

void vGetPidValues_CMockReturnMemThruPtr_kp(UNITY_LINE_TYPE cmock_line, float* kp, size_t cmock_size)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_kp_Used = 1;
  cmock_call_instance->ReturnThruPtr_kp_Val = kp;
  cmock_call_instance->ReturnThruPtr_kp_Size = cmock_size;
}

void vGetPidValues_CMockReturnMemThruPtr_ki(UNITY_LINE_TYPE cmock_line, float* ki, size_t cmock_size)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ki_Used = 1;
  cmock_call_instance->ReturnThruPtr_ki_Val = ki;
  cmock_call_instance->ReturnThruPtr_ki_Size = cmock_size;
}

void vGetPidValues_CMockReturnMemThruPtr_kd(UNITY_LINE_TYPE cmock_line, float* kd, size_t cmock_size)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_kd_Used = 1;
  cmock_call_instance->ReturnThruPtr_kd_Val = kd;
  cmock_call_instance->ReturnThruPtr_kd_Size = cmock_size;
}

void vGetPidValues_CMockIgnoreArg_eBeacon_Id(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eBeacon_Id = 1;
}

void vGetPidValues_CMockIgnoreArg_kp(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_kp = 1;
}

void vGetPidValues_CMockIgnoreArg_ki(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ki = 1;
}

void vGetPidValues_CMockIgnoreArg_kd(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGetPidValues_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGetPidValues_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGetPidValues_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_kd = 1;
}

void vControlLaserPIDReset(ePIDID_t ePIDID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vControlLaserPIDReset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vControlLaserPIDReset);
  cmock_call_instance = (CMOCK_vControlLaserPIDReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vControlLaserPIDReset_CallInstance);
  Mock.vControlLaserPIDReset_CallInstance = CMock_Guts_MemNext(Mock.vControlLaserPIDReset_CallInstance);
  if (Mock.vControlLaserPIDReset_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vControlLaserPIDReset_CallbackBool &&
      Mock.vControlLaserPIDReset_CallbackFunctionPointer != NULL)
  {
    Mock.vControlLaserPIDReset_CallbackFunctionPointer(ePIDID, Mock.vControlLaserPIDReset_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ePIDID)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDReset,CMockString_ePIDID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ePIDID), (void*)(&ePIDID), sizeof(ePIDID_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vControlLaserPIDReset_CallbackFunctionPointer != NULL)
  {
    Mock.vControlLaserPIDReset_CallbackFunctionPointer(ePIDID, Mock.vControlLaserPIDReset_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vControlLaserPIDReset(CMOCK_vControlLaserPIDReset_CALL_INSTANCE* cmock_call_instance, ePIDID_t ePIDID);
void CMockExpectParameters_vControlLaserPIDReset(CMOCK_vControlLaserPIDReset_CALL_INSTANCE* cmock_call_instance, ePIDID_t ePIDID)
{
  memcpy((void*)(&cmock_call_instance->Expected_ePIDID), (void*)(&ePIDID),
         sizeof(ePIDID_t[sizeof(ePIDID) == sizeof(ePIDID_t) ? 1 : -1])); /* add ePIDID_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ePIDID = 0;
}

void vControlLaserPIDReset_CMockIgnore(void)
{
  Mock.vControlLaserPIDReset_IgnoreBool = (char)1;
}

void vControlLaserPIDReset_CMockStopIgnore(void)
{
  Mock.vControlLaserPIDReset_IgnoreBool = (char)0;
}

void vControlLaserPIDReset_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDReset_CALL_INSTANCE));
  CMOCK_vControlLaserPIDReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDReset_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDReset_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vControlLaserPIDReset_CMockExpect(UNITY_LINE_TYPE cmock_line, ePIDID_t ePIDID)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDReset_CALL_INSTANCE));
  CMOCK_vControlLaserPIDReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDReset_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDReset_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vControlLaserPIDReset(cmock_call_instance, ePIDID);
}

void vControlLaserPIDReset_AddCallback(CMOCK_vControlLaserPIDReset_CALLBACK Callback)
{
  Mock.vControlLaserPIDReset_IgnoreBool = (char)0;
  Mock.vControlLaserPIDReset_CallbackBool = (char)1;
  Mock.vControlLaserPIDReset_CallbackFunctionPointer = Callback;
}

void vControlLaserPIDReset_Stub(CMOCK_vControlLaserPIDReset_CALLBACK Callback)
{
  Mock.vControlLaserPIDReset_IgnoreBool = (char)0;
  Mock.vControlLaserPIDReset_CallbackBool = (char)0;
  Mock.vControlLaserPIDReset_CallbackFunctionPointer = Callback;
}

void vControlLaserPIDReset_CMockIgnoreArg_ePIDID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDReset_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ePIDID = 1;
}

eBool_t bControlLaserDeltaTimeHasChanged(ePIDID_t ePIDID, uint32_t ulDeltaTime)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_bControlLaserDeltaTimeHasChanged);
  cmock_call_instance = (CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bControlLaserDeltaTimeHasChanged_CallInstance);
  Mock.bControlLaserDeltaTimeHasChanged_CallInstance = CMock_Guts_MemNext(Mock.bControlLaserDeltaTimeHasChanged_CallInstance);
  if (Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.bControlLaserDeltaTimeHasChanged_FinalReturn;
    memcpy((void*)(&Mock.bControlLaserDeltaTimeHasChanged_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eBool_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.bControlLaserDeltaTimeHasChanged_CallbackBool &&
      Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer != NULL)
  {
    eBool_t cmock_cb_ret = Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer(ePIDID, ulDeltaTime, Mock.bControlLaserDeltaTimeHasChanged_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ePIDID)
  {
    UNITY_SET_DETAILS(CMockString_bControlLaserDeltaTimeHasChanged,CMockString_ePIDID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ePIDID), (void*)(&ePIDID), sizeof(ePIDID_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ulDeltaTime)
  {
    UNITY_SET_DETAILS(CMockString_bControlLaserDeltaTimeHasChanged,CMockString_ulDeltaTime);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulDeltaTime, ulDeltaTime, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer(ePIDID, ulDeltaTime, Mock.bControlLaserDeltaTimeHasChanged_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_bControlLaserDeltaTimeHasChanged(CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance, ePIDID_t ePIDID, uint32_t ulDeltaTime);
void CMockExpectParameters_bControlLaserDeltaTimeHasChanged(CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance, ePIDID_t ePIDID, uint32_t ulDeltaTime)
{
  memcpy((void*)(&cmock_call_instance->Expected_ePIDID), (void*)(&ePIDID),
         sizeof(ePIDID_t[sizeof(ePIDID) == sizeof(ePIDID_t) ? 1 : -1])); /* add ePIDID_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ePIDID = 0;
  cmock_call_instance->Expected_ulDeltaTime = ulDeltaTime;
  cmock_call_instance->IgnoreArg_ulDeltaTime = 0;
}

void bControlLaserDeltaTimeHasChanged_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE));
  CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance = (CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bControlLaserDeltaTimeHasChanged_CallInstance = CMock_Guts_MemChain(Mock.bControlLaserDeltaTimeHasChanged_CallInstance, cmock_guts_index);
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)1;
}

void bControlLaserDeltaTimeHasChanged_CMockStopIgnore(void)
{
  if(Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool)
    Mock.bControlLaserDeltaTimeHasChanged_CallInstance = CMock_Guts_MemNext(Mock.bControlLaserDeltaTimeHasChanged_CallInstance);
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)0;
}

void bControlLaserDeltaTimeHasChanged_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE));
  CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance = (CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bControlLaserDeltaTimeHasChanged_CallInstance = CMock_Guts_MemChain(Mock.bControlLaserDeltaTimeHasChanged_CallInstance, cmock_guts_index);
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void bControlLaserDeltaTimeHasChanged_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ePIDID_t ePIDID, uint32_t ulDeltaTime, eBool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE));
  CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance = (CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.bControlLaserDeltaTimeHasChanged_CallInstance = CMock_Guts_MemChain(Mock.bControlLaserDeltaTimeHasChanged_CallInstance, cmock_guts_index);
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_bControlLaserDeltaTimeHasChanged(cmock_call_instance, ePIDID, ulDeltaTime);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eBool_t[sizeof(cmock_to_return) == sizeof(eBool_t) ? 1 : -1])); /* add eBool_t to :treat_as_array if this causes an error */
}

void bControlLaserDeltaTimeHasChanged_AddCallback(CMOCK_bControlLaserDeltaTimeHasChanged_CALLBACK Callback)
{
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)0;
  Mock.bControlLaserDeltaTimeHasChanged_CallbackBool = (char)1;
  Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer = Callback;
}

void bControlLaserDeltaTimeHasChanged_Stub(CMOCK_bControlLaserDeltaTimeHasChanged_CALLBACK Callback)
{
  Mock.bControlLaserDeltaTimeHasChanged_IgnoreBool = (char)0;
  Mock.bControlLaserDeltaTimeHasChanged_CallbackBool = (char)0;
  Mock.bControlLaserDeltaTimeHasChanged_CallbackFunctionPointer = Callback;
}

void bControlLaserDeltaTimeHasChanged_CMockIgnoreArg_ePIDID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance = (CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.bControlLaserDeltaTimeHasChanged_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ePIDID = 1;
}

void bControlLaserDeltaTimeHasChanged_CMockIgnoreArg_ulDeltaTime(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE* cmock_call_instance = (CMOCK_bControlLaserDeltaTimeHasChanged_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.bControlLaserDeltaTimeHasChanged_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulDeltaTime = 1;
}

void vControlLaserPIDUpdate(float fReference, float fReferenceFeedback, uint8_t eBeaconId, float* pfControlCurrent)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vControlLaserPIDUpdate);
  cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vControlLaserPIDUpdate_CallInstance);
  Mock.vControlLaserPIDUpdate_CallInstance = CMock_Guts_MemNext(Mock.vControlLaserPIDUpdate_CallInstance);
  if (Mock.vControlLaserPIDUpdate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vControlLaserPIDUpdate_CallbackBool &&
      Mock.vControlLaserPIDUpdate_CallbackFunctionPointer != NULL)
  {
    Mock.vControlLaserPIDUpdate_CallbackFunctionPointer(fReference, fReferenceFeedback, eBeaconId, pfControlCurrent, Mock.vControlLaserPIDUpdate_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fReference)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDUpdate,CMockString_fReference);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fReference, fReference, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fReferenceFeedback)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDUpdate,CMockString_fReferenceFeedback);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_fReferenceFeedback, fReferenceFeedback, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eBeaconId)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDUpdate,CMockString_eBeaconId);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_eBeaconId, eBeaconId, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pfControlCurrent)
  {
    UNITY_SET_DETAILS(CMockString_vControlLaserPIDUpdate,CMockString_pfControlCurrent);
    if (cmock_call_instance->Expected_pfControlCurrent == NULL)
      { UNITY_TEST_ASSERT_NULL(pfControlCurrent, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_pfControlCurrent, pfControlCurrent, cmock_call_instance->Expected_pfControlCurrent_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vControlLaserPIDUpdate_CallbackFunctionPointer != NULL)
  {
    Mock.vControlLaserPIDUpdate_CallbackFunctionPointer(fReference, fReferenceFeedback, eBeaconId, pfControlCurrent, Mock.vControlLaserPIDUpdate_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pfControlCurrent_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pfControlCurrent, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pfControlCurrent, (void*)cmock_call_instance->ReturnThruPtr_pfControlCurrent_Val,
      cmock_call_instance->ReturnThruPtr_pfControlCurrent_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vControlLaserPIDUpdate(CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance, float fReference, float fReferenceFeedback, uint8_t eBeaconId, float* pfControlCurrent, int pfControlCurrent_Depth);
void CMockExpectParameters_vControlLaserPIDUpdate(CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance, float fReference, float fReferenceFeedback, uint8_t eBeaconId, float* pfControlCurrent, int pfControlCurrent_Depth)
{
  cmock_call_instance->Expected_fReference = fReference;
  cmock_call_instance->IgnoreArg_fReference = 0;
  cmock_call_instance->Expected_fReferenceFeedback = fReferenceFeedback;
  cmock_call_instance->IgnoreArg_fReferenceFeedback = 0;
  cmock_call_instance->Expected_eBeaconId = eBeaconId;
  cmock_call_instance->IgnoreArg_eBeaconId = 0;
  cmock_call_instance->Expected_pfControlCurrent = pfControlCurrent;
  cmock_call_instance->Expected_pfControlCurrent_Depth = pfControlCurrent_Depth;
  cmock_call_instance->IgnoreArg_pfControlCurrent = 0;
  cmock_call_instance->ReturnThruPtr_pfControlCurrent_Used = 0;
}

void vControlLaserPIDUpdate_CMockIgnore(void)
{
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)1;
}

void vControlLaserPIDUpdate_CMockStopIgnore(void)
{
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)0;
}

void vControlLaserPIDUpdate_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE));
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDUpdate_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDUpdate_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vControlLaserPIDUpdate_CMockExpect(UNITY_LINE_TYPE cmock_line, float fReference, float fReferenceFeedback, uint8_t eBeaconId, float* pfControlCurrent)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE));
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDUpdate_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDUpdate_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vControlLaserPIDUpdate(cmock_call_instance, fReference, fReferenceFeedback, eBeaconId, pfControlCurrent, 1);
}

void vControlLaserPIDUpdate_AddCallback(CMOCK_vControlLaserPIDUpdate_CALLBACK Callback)
{
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)0;
  Mock.vControlLaserPIDUpdate_CallbackBool = (char)1;
  Mock.vControlLaserPIDUpdate_CallbackFunctionPointer = Callback;
}

void vControlLaserPIDUpdate_Stub(CMOCK_vControlLaserPIDUpdate_CALLBACK Callback)
{
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)0;
  Mock.vControlLaserPIDUpdate_CallbackBool = (char)0;
  Mock.vControlLaserPIDUpdate_CallbackFunctionPointer = Callback;
}

void vControlLaserPIDUpdate_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, float fReference, float fReferenceFeedback, uint8_t eBeaconId, float* pfControlCurrent, int pfControlCurrent_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE));
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vControlLaserPIDUpdate_CallInstance = CMock_Guts_MemChain(Mock.vControlLaserPIDUpdate_CallInstance, cmock_guts_index);
  Mock.vControlLaserPIDUpdate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vControlLaserPIDUpdate(cmock_call_instance, fReference, fReferenceFeedback, eBeaconId, pfControlCurrent, pfControlCurrent_Depth);
}

void vControlLaserPIDUpdate_CMockReturnMemThruPtr_pfControlCurrent(UNITY_LINE_TYPE cmock_line, float* pfControlCurrent, size_t cmock_size)
{
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDUpdate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pfControlCurrent_Used = 1;
  cmock_call_instance->ReturnThruPtr_pfControlCurrent_Val = pfControlCurrent;
  cmock_call_instance->ReturnThruPtr_pfControlCurrent_Size = cmock_size;
}

void vControlLaserPIDUpdate_CMockIgnoreArg_fReference(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDUpdate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fReference = 1;
}

void vControlLaserPIDUpdate_CMockIgnoreArg_fReferenceFeedback(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDUpdate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fReferenceFeedback = 1;
}

void vControlLaserPIDUpdate_CMockIgnoreArg_eBeaconId(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDUpdate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eBeaconId = 1;
}

void vControlLaserPIDUpdate_CMockIgnoreArg_pfControlCurrent(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_vControlLaserPIDUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vControlLaserPIDUpdate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfControlCurrent = 1;
}

